/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 147);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_ARR", function() { return EMPTY_ARR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY_OBJ", function() { return EMPTY_OBJ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO", function() { return NO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NOOP", function() { return NOOP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PatchFlagNames", function() { return PatchFlagNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "def", function() { return def; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeHtml", function() { return escapeHtml; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "escapeHtmlComment", function() { return escapeHtmlComment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateCodeFrame", function() { return generateCodeFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasChanged", function() { return hasChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasOwn", function() { return hasOwn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hyphenate", function() { return hyphenate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invokeArrayFns", function() { return invokeArrayFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBooleanAttr", function() { return isBooleanAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFunction", function() { return isFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGloballyWhitelisted", function() { return isGloballyWhitelisted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHTMLTag", function() { return isHTMLTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKnownAttr", function() { return isKnownAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNoUnitNumericStyleProp", function() { return isNoUnitNumericStyleProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOn", function() { return isOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPlainObject", function() { return isPlainObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReservedProp", function() { return isReservedProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSSRSafeAttrName", function() { return isSSRSafeAttrName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSVGTag", function() { return isSVGTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSpecialBooleanAttr", function() { return isSpecialBooleanAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSymbol", function() { return isSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVoidTag", function() { return isVoidTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "looseEqual", function() { return looseEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "looseIndexOf", function() { return looseIndexOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeMap", function() { return makeMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mockError", function() { return mockError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mockWarn", function() { return mockWarn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeClass", function() { return normalizeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeStyle", function() { return normalizeStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objectToString", function() { return objectToString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseStringStyle", function() { return parseStringStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "propsToAttrMap", function() { return propsToAttrMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringifyStyle", function() { return stringifyStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDisplayString", function() { return toDisplayString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toNumber", function() { return toNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRawType", function() { return toRawType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toTypeString", function() { return toTypeString; });
// Make a map and return a function for checking if a key
// is in that map.
//
// IMPORTANT: all calls of this function must be prefixed with /*#__PURE__*/
// So that rollup can tree-shake them if necessary.
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

// Patch flags are optimization hints generated by the compiler.
// when a block with dynamicChildren is encountered during diff, the algorithm
// enters "optimized mode". In this mode, we know that the vdom is produced by
// a render function generated by the compiler, so the algorithm only needs to
// handle updates explicitly marked by these patch flags.
// dev only flag -> name mapping
const PatchFlagNames = {
    [1 /* TEXT */]: `TEXT`,
    [2 /* CLASS */]: `CLASS`,
    [4 /* STYLE */]: `STYLE`,
    [8 /* PROPS */]: `PROPS`,
    [16 /* FULL_PROPS */]: `FULL_PROPS`,
    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
    [512 /* NEED_PATCH */]: `NEED_PATCH`,
    [-1 /* HOISTED */]: `HOISTED`,
    [-2 /* BAIL */]: `BAIL`
};

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                const line = j + 1;
                res.push(`${line}${' '.repeat(3 - String(line).length)}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = Math.max(1, end > count ? lineLength - pad : end - start);
                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.max(Math.min(end - count, lineLength), 1);
                        res.push(`   |  ` + '^'.repeat(length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}

const mockError = () => mockWarn(true);
function mockWarn(asError = false) {
    expect.extend({
        toHaveBeenWarned(received) {
            asserted.add(received);
            const passed = warn.mock.calls.some(args => args[0].indexOf(received) > -1);
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedLast(received) {
            asserted.add(received);
            const passed = warn.mock.calls[warn.mock.calls.length - 1][0].indexOf(received) > -1;
            if (passed) {
                return {
                    pass: true,
                    message: () => `expected "${received}" not to have been warned last.`
                };
            }
            else {
                const msgs = warn.mock.calls.map(args => args[0]).join('\n - ');
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned last.\n\nActual messages:\n\n - ${msgs}`
                };
            }
        },
        toHaveBeenWarnedTimes(received, n) {
            asserted.add(received);
            let found = 0;
            warn.mock.calls.forEach(args => {
                if (args[0].indexOf(received) > -1) {
                    found++;
                }
            });
            if (found === n) {
                return {
                    pass: true,
                    message: () => `expected "${received}" to have been warned ${n} times.`
                };
            }
            else {
                return {
                    pass: false,
                    message: () => `expected "${received}" to have been warned ${n} times but got ${found}.`
                };
            }
        }
    });
    let warn;
    const asserted = new Set();
    beforeEach(() => {
        asserted.clear();
        warn = jest.spyOn(console, asError ? 'error' : 'warn');
        warn.mockImplementation(() => { });
    });
    afterEach(() => {
        const assertedArray = Array.from(asserted);
        const nonAssertedWarnings = warn.mock.calls
            .map(args => args[0])
            .filter(received => {
            return !assertedArray.some(assertedMsg => {
                return received.indexOf(assertedMsg) > -1;
            });
        });
        warn.mockRestore();
        if (nonAssertedWarnings.length) {
            nonAssertedWarnings.forEach(warning => {
                console.warn(warning);
            });
            throw new Error(`test case threw unexpected warnings.`);
        }
    });
}

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * The full list is needed during SSR to produce the correct initial markup.
 */
const isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +
    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +
    `loop,open,required,reversed,scoped,seamless,` +
    `checked,muted,multiple,selected`);
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
    if (attrValidationCache.hasOwnProperty(name)) {
        return attrValidationCache[name];
    }
    const isUnsafe = unsafeAttrCharRE.test(name);
    if (isUnsafe) {
        console.error(`unsafe attribute name: ${name}`);
    }
    return (attrValidationCache[name] = !isUnsafe);
}
const propsToAttrMap = {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
};
/**
 * CSS properties that accept plain numbers
 */
const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +
    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +
    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +
    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +
    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +
    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +
    // SVG
    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +
    `stroke-miterlimit,stroke-opacity,stroke-width`);
/**
 * Known attributes, this is used for stringification of runtime static nodes
 * so that we don't stringify bindings that cannot be set from HTML.
 * Don't also forget to allow `data-*` and `aria-*`!
 * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
 */
const isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +
    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +
    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +
    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +
    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +
    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +
    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +
    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +
    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +
    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +
    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +
    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +
    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +
    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +
    `value,width,wrap`);

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function stringifyStyle(styles) {
    let ret = '';
    if (!styles) {
        return ret;
    }
    for (const key in styles) {
        const value = styles[key];
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        if (isString(value) ||
            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {
            // only render valid values
            ret += `${normalizedKey}:${value};`;
        }
    }
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            res += normalizeClass(value[i]) + ' ';
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,menuitem,' +
    'summary,content,element,shadow,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
    const str = '' + string;
    const match = escapeRE.exec(str);
    if (!match) {
        return str;
    }
    let html = '';
    let escaped;
    let index;
    let lastIndex = 0;
    for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
            case 34: // "
                escaped = '&quot;';
                break;
            case 38: // &
                escaped = '&amp;';
                break;
            case 39: // '
                escaped = '&#39;';
                break;
            case 60: // <
                escaped = '&lt;';
                break;
            case 62: // >
                escaped = '&gt;';
                break;
            default:
                continue;
        }
        if (lastIndex !== index) {
            html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escaped;
    }
    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// https://www.w3.org/TR/html52/syntax.html#comments
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
    return src.replace(commentStripRE, '');
}

function looseEqual(a, b) {
    if (a === b)
        return true;
    const isObjectA = isObject(a);
    const isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            const isArrayA = isArray(a);
            const isArrayB = isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every((e, i) => looseEqual(e, b[i])));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(key => looseEqual(a[key], b[key])));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

// For converting {{ interpolation }} values to displayed strings.
const toDisplayString = (val) => {
    return val == null
        ? ''
        : isObject(val)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
};
const replacer = (_key, val) => {
    if (val instanceof Map) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (val instanceof Set) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( false)
    ? undefined
    : {};
const EMPTY_ARR = [];
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const extend = (a, b) => {
    for (const key in b) {
        a[key] = b[key];
    }
    return a;
};
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isReservedProp = /*#__PURE__*/ makeMap('key,ref,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};




/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ITERATE_KEY", function() { return ITERATE_KEY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return computed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customRef", function() { return customRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "effect", function() { return effect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableTracking", function() { return enableTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isProxy", function() { return isProxy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReactive", function() { return isReactive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadonly", function() { return isReadonly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRef", function() { return isRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "markRaw", function() { return markRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pauseTracking", function() { return pauseTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reactive", function() { return reactive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readonly", function() { return readonly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ref", function() { return ref; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetTracking", function() { return resetTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowReactive", function() { return shallowReactive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowReadonly", function() { return shallowReadonly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowRef", function() { return shallowRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stop", function() { return stop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRaw", function() { return toRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRef", function() { return toRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRefs", function() { return toRefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "track", function() { return track; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trigger", function() { return trigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triggerRef", function() { return triggerRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unref", function() { return unref; });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);


const targetMap = new WeakMap();
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol(( false) ? undefined : '');
const MAP_KEY_ITERATE_KEY = Symbol(( false) ? undefined : '');
function isEffect(fn) {
    return fn && fn._isEffect === true;
}
function effect(fn, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__["EMPTY_OBJ"]) {
    if (isEffect(fn)) {
        fn = fn.raw;
    }
    const effect = createReactiveEffect(fn, options);
    if (!options.lazy) {
        effect();
    }
    return effect;
}
function stop(effect) {
    if (effect.active) {
        cleanup(effect);
        if (effect.options.onStop) {
            effect.options.onStop();
        }
        effect.active = false;
    }
}
let uid = 0;
function createReactiveEffect(fn, options) {
    const effect = function reactiveEffect(...args) {
        if (!effect.active) {
            return options.scheduler ? undefined : fn(...args);
        }
        if (!effectStack.includes(effect)) {
            cleanup(effect);
            try {
                enableTracking();
                effectStack.push(effect);
                activeEffect = effect;
                return fn(...args);
            }
            finally {
                effectStack.pop();
                resetTracking();
                activeEffect = effectStack[effectStack.length - 1];
            }
        }
    };
    effect.id = uid++;
    effect._isEffect = true;
    effect.active = true;
    effect.raw = fn;
    effect.deps = [];
    effect.options = options;
    return effect;
}
function cleanup(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (!shouldTrack || activeEffect === undefined) {
        return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }
    let dep = depsMap.get(key);
    if (!dep) {
        depsMap.set(key, (dep = new Set()));
    }
    if (!dep.has(activeEffect)) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (false) {}
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    const effects = new Set();
    const computedRunners = new Set();
    const add = (effectsToAdd) => {
        if (effectsToAdd) {
            effectsToAdd.forEach(effect => {
                if (effect !== activeEffect || !shouldTrack) {
                    if (effect.options.computed) {
                        computedRunners.add(effect);
                    }
                    else {
                        effects.add(effect);
                    }
                }
            });
        }
    };
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        depsMap.forEach(add);
    }
    else if (key === 'length' && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                add(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            add(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        const isAddOrDelete = type === "add" /* ADD */ ||
            (type === "delete" /* DELETE */ && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(target));
        if (isAddOrDelete ||
            (type === "set" /* SET */ && target instanceof Map)) {
            add(depsMap.get(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(target) ? 'length' : ITERATE_KEY));
        }
        if (isAddOrDelete && target instanceof Map) {
            add(depsMap.get(MAP_KEY_ITERATE_KEY));
        }
    }
    const run = (effect) => {
        if (false) {}
        if (effect.options.scheduler) {
            effect.options.scheduler(effect);
        }
        else {
            effect();
        }
    };
    // Important: computed effects must be run first so that computed getters
    // can be invalidated before any normal effects that depend on them are run.
    computedRunners.forEach(run);
    effects.forEach(run);
}

const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)
    .map(key => Symbol[key])
    .filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isSymbol"]));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = {};
['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
    arrayInstrumentations[key] = function (...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get" /* GET */, i + '');
        }
        // we run the method using the original args first (which may be reactive)
        const res = arr[key](...args);
        if (res === -1 || res === false) {
            // if that didn't work, run it again using raw values.
            return arr[key](...args.map(toRaw));
        }
        else {
            return res;
        }
    };
});
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* isReactive */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* isReadonly */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* raw */) {
            return target;
        }
        const targetIsArray = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(target);
        if (targetIsArray && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasOwn"])(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isSymbol"])(key) && builtInSymbols.has(key) || key === '__proto__') {
            return res;
        }
        if (shallow) {
            !isReadonly && track(target, "get" /* GET */, key);
            return res;
        }
        if (isRef(res)) {
            if (targetIsArray) {
                !isReadonly && track(target, "get" /* GET */, key);
                return res;
            }
            else {
                // ref unwrapping, only for Objects, not for Arrays.
                return res.value;
            }
        }
        !isReadonly && track(target, "get" /* GET */, key);
        return Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(res)
            ? isReadonly
                ? // need to lazy access readonly and reactive here to avoid
                    // circular dependency
                    readonly(res)
                : reactive(res)
            : res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        const oldValue = target[key];
        if (!shallow) {
            value = toRaw(value);
            if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasOwn"])(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasChanged"])(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasOwn"])(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    track(target, "has" /* HAS */, key);
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    has,
    ownKeys,
    set(target, key) {
        if ((false)) {}
        return true;
    },
    deleteProperty(target, key) {
        if ((false)) {}
        return true;
    }
};
const shallowReactiveHandlers = {
    ...mutableHandlers,
    get: shallowGet,
    set: shallowSet
};
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = {
    ...readonlyHandlers,
    get: shallowReadonlyGet
};

const toReactive = (value) => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(value) ? reactive(value) : value;
const toReadonly = (value) => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(value) ? readonly(value) : value;
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, wrap) {
    target = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        track(target, "get" /* GET */, key);
    }
    track(target, "get" /* GET */, rawKey);
    const { has, get } = getProto(target);
    if (has.call(target, key)) {
        return wrap(get.call(target, key));
    }
    else if (has.call(target, rawKey)) {
        return wrap(get.call(target, rawKey));
    }
}
function has$1(key) {
    const target = toRaw(this);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
        track(target, "has" /* HAS */, key);
    }
    track(target, "has" /* HAS */, rawKey);
    const has = getProto(target).has;
    return has.call(target, key) || has.call(target, rawKey);
}
function size(target) {
    target = toRaw(target);
    track(target, "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(getProto(target), 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    const result = proto.add.call(target, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, value, value);
    }
    return result;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get, set } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get.call(target, key);
    const result = set.call(target, key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasChanged"])(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return result;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get, delete: del } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((false)) {}
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = del.call(target, key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( false)
        ? undefined
        : undefined;
    // forward the operation before queueing reactions
    const result = getProto(target).clear.call(target);
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, shallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = toRaw(observed);
        const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive;
        !isReadonly && track(target, "iterate" /* ITERATE */, ITERATE_KEY);
        // important: create sure the callback is
        // 1. invoked with the reactive map as `this` and 3rd arg
        // 2. the value received should be a corresponding reactive/readonly.
        function wrappedCallback(value, key) {
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        }
        return getProto(target).forEach.call(target, wrappedCallback);
    };
}
function createIterableMethod(method, isReadonly, shallow) {
    return function (...args) {
        const target = toRaw(this);
        const isMap = target instanceof Map;
        const isPair = method === 'entries' || (method === Symbol.iterator && isMap);
        const isKeyOnly = method === 'keys' && isMap;
        const innerIterator = getProto(target)[method].apply(target, args);
        const wrap = isReadonly ? toReadonly : shallow ? toShallow : toReactive;
        !isReadonly &&
            track(target, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((false)) {}
        return type === "delete" /* DELETE */ ? false : this;
    };
}
const mutableInstrumentations = {
    get(key) {
        return get$1(this, key, toReactive);
    },
    get size() {
        return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
};
const shallowInstrumentations = {
    get(key) {
        return get$1(this, key, toShallow);
    },
    get size() {
        return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
};
const readonlyInstrumentations = {
    get(key) {
        return get$1(this, key, toReadonly);
    },
    get size() {
        return size(this);
    },
    has: has$1,
    add: createReadonlyMethod("add" /* ADD */),
    set: createReadonlyMethod("set" /* SET */),
    delete: createReadonlyMethod("delete" /* DELETE */),
    clear: createReadonlyMethod("clear" /* CLEAR */),
    forEach: createForEach(true, false)
};
const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
iteratorMethods.forEach(method => {
    mutableInstrumentations[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations[method] = createIterableMethod(method, true, false);
    shallowInstrumentations[method] = createIterableMethod(method, true, true);
});
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* isReactive */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* isReadonly */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* raw */) {
            return target;
        }
        return Reflect.get(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasOwn"])(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: createInstrumentationGetter(true, false)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["toRawType"])(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? `as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const collectionTypes = new Set([Set, Map, WeakMap, WeakSet]);
const isObservableType = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["makeMap"])('Object,Array,Map,Set,WeakMap,WeakSet');
const canObserve = (value) => {
    return (!value.__v_skip &&
        isObservableType(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["toRawType"])(value)) &&
        !Object.isFrozen(value));
};
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (target && target.__v_isReadonly) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);
}
// Return a reactive-copy of the original object, where only the root level
// properties are reactive, and does NOT unwrap refs nor recursively convert
// returned properties.
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);
}
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);
}
// Return a reactive-copy of the original object, where only the root level
// properties are readonly, and does NOT unwrap refs nor recursively convert
// returned properties.
// This is used for creating the props proxy object for stateful components.
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {
    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(target)) {
        if ((false)) {}
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target.__v_raw && !(isReadonly && target.__v_isReactive)) {
        return target;
    }
    // target already has corresponding Proxy
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasOwn"])(target, isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */)) {
        return isReadonly ? target.__v_readonly : target.__v_reactive;
    }
    // only a whitelist of value types can be observed.
    if (!canObserve(target)) {
        return target;
    }
    const observed = new Proxy(target, collectionTypes.has(target.constructor) ? collectionHandlers : baseHandlers);
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["def"])(target, isReadonly ? "__v_readonly" /* readonly */ : "__v_reactive" /* reactive */, observed);
    return observed;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value.__v_raw);
    }
    return !!(value && value.__v_isReactive);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    return (observed && toRaw(observed.__v_raw)) || observed;
}
function markRaw(value) {
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["def"])(value, "__v_skip" /* skip */, true);
    return value;
}

const convert = (val) => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(val) ? reactive(val) : val;
function isRef(r) {
    return r ? r.__v_isRef === true : false;
}
function ref(value) {
    return createRef(value);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow = false) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    let value = shallow ? rawValue : convert(rawValue);
    const r = {
        __v_isRef: true,
        get value() {
            track(r, "get" /* GET */, 'value');
            return value;
        },
        set value(newVal) {
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hasChanged"])(toRaw(newVal), rawValue)) {
                rawValue = newVal;
                value = shallow ? newVal : convert(newVal);
                trigger(r, "set" /* SET */, 'value', ( false) ? undefined : void 0);
            }
        }
    };
    return r;
}
function triggerRef(ref) {
    trigger(ref, "set" /* SET */, 'value', ( false) ? undefined : void 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function customRef(factory) {
    const { get, set } = factory(() => track(r, "get" /* GET */, 'value'), () => trigger(r, "set" /* SET */, 'value'));
    const r = {
        __v_isRef: true,
        get value() {
            return get();
        },
        set value(v) {
            set(v);
        }
    };
    return r;
}
function toRefs(object) {
    if (false) {}
    const ret = {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key) {
    return {
        __v_isRef: true,
        get value() {
            return object[key];
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
}

function computed(getterOrOptions) {
    let getter;
    let setter;
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(getterOrOptions)) {
        getter = getterOrOptions;
        setter = ( false)
            ? undefined
            : _vue_shared__WEBPACK_IMPORTED_MODULE_0__["NOOP"];
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    let dirty = true;
    let value;
    let computed;
    const runner = effect(getter, {
        lazy: true,
        // mark effect as computed so that it gets priority during trigger
        computed: true,
        scheduler: () => {
            if (!dirty) {
                dirty = true;
                trigger(computed, "set" /* SET */, 'value');
            }
        }
    });
    computed = {
        __v_isRef: true,
        // expose effect so computed can be stopped
        effect: runner,
        get value() {
            if (dirty) {
                value = runner();
                dirty = false;
            }
            track(computed, "get" /* GET */, 'value');
            return value;
        },
        set value(newValue) {
            setter(newValue);
        }
    };
    return computed;
}




/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compile", function() { return compile; });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customRef", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["customRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isProxy", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["isProxy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReactive", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["isReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadonly", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["isReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRef", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["isRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "markRaw", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["markRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reactive", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["reactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readonly", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["readonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ref", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["ref"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReactive", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["shallowReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReadonly", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["shallowReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowRef", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["shallowRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRaw", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["toRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRef", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["toRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRefs", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["toRefs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triggerRef", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["triggerRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unref", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["unref"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseTransition", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["BaseTransition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Comment", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Comment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeepAlive", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["KeepAlive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Static", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Static"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Suspense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Teleport", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Teleport"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callWithAsyncErrorHandling", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["callWithAsyncErrorHandling"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callWithErrorHandling", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["callWithErrorHandling"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["camelize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["cloneVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["computed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createBlock", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCommentVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createCommentVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHydrationRenderer", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createHydrationRenderer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRenderer", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createRenderer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSlots", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createSlots"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStaticVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createStaticVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTextVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createTextVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineAsyncComponent", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["defineAsyncComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineComponent", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentInstance", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["getCurrentInstance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "handleError", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["handleError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["inject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isVNode", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["isVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeProps", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["mergeProps"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["nextTick"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onActivated", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onActivated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeMount", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onBeforeMount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeUnmount", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onBeforeUnmount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeUpdate", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onBeforeUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onDeactivated", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onDeactivated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorCaptured", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onErrorCaptured"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onMounted", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onMounted"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onRenderTracked", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onRenderTracked"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onRenderTriggered", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onRenderTriggered"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onUnmounted", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onUnmounted"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onUpdated", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["onUpdated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "openBlock", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["openBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popScopeId", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["popScopeId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "provide", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["provide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pushScopeId", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["pushScopeId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queuePostFlushCb", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["queuePostFlushCb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerRuntimeCompiler", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["registerRuntimeCompiler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderList", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["renderList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderSlot", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["renderSlot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveComponent", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["resolveComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveDirective", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["resolveDirective"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveDynamicComponent", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["resolveDynamicComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveTransitionHooks", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["resolveTransitionHooks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBlockTracking", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["setBlockTracking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setTransitionHooks", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["setTransitionHooks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssrContextKey", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["ssrContextKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssrUtils", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["ssrUtils"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDisplayString", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["toDisplayString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toHandlers", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["toHandlers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformVNodeArgs", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["transformVNodeArgs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCSSModule", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["useCSSModule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSSRContext", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["useSSRContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useTransitionState", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["useTransitionState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "warn", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["warn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "watch", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["watch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "watchEffect", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["watchEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withCtx", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["withCtx"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withDirectives", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["withDirectives"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withScopeId", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["withScopeId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["Transition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransitionGroup", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["TransitionGroup"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createApp", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createApp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSSRApp", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["createSSRApp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["hydrate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vModelCheckbox", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vModelCheckbox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vModelDynamic", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vModelDynamic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vModelRadio", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vModelRadio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vModelSelect", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vModelSelect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vModelText", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vModelText"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "vShow", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["vShow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withKeys", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["withKeys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withModifiers", function() { return _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__["withModifiers"]; });




// This entry exports the runtime only, and is built as
const compile = () => {
    if ((false)) {}
};




/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseTransition", function() { return BaseTransition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Comment", function() { return Comment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return Fragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepAlive", function() { return KeepAlive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Static", function() { return Static; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return Suspense; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Teleport", function() { return Teleport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return Text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callWithAsyncErrorHandling", function() { return callWithAsyncErrorHandling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "callWithErrorHandling", function() { return callWithErrorHandling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return _camelize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneVNode", function() { return cloneVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return computed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBlock", function() { return createBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCommentVNode", function() { return createCommentVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHydrationRenderer", function() { return createHydrationRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRenderer", function() { return createRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSlots", function() { return createSlots; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStaticVNode", function() { return createStaticVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTextVNode", function() { return createTextVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVNode", function() { return createVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineAsyncComponent", function() { return defineAsyncComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineComponent", function() { return defineComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCurrentInstance", function() { return getCurrentInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleError", function() { return handleError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return inject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVNode", function() { return isVNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeProps", function() { return mergeProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return nextTick; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onActivated", function() { return onActivated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onBeforeMount", function() { return onBeforeMount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onBeforeUnmount", function() { return onBeforeUnmount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onBeforeUpdate", function() { return onBeforeUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onDeactivated", function() { return onDeactivated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onErrorCaptured", function() { return onErrorCaptured; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onMounted", function() { return onMounted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onRenderTracked", function() { return onRenderTracked; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onRenderTriggered", function() { return onRenderTriggered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onUnmounted", function() { return onUnmounted; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "onUpdated", function() { return onUpdated; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "openBlock", function() { return openBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popScopeId", function() { return popScopeId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "provide", function() { return provide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushScopeId", function() { return pushScopeId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "queuePostFlushCb", function() { return queuePostFlushCb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRuntimeCompiler", function() { return registerRuntimeCompiler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderList", function() { return renderList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderSlot", function() { return renderSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveComponent", function() { return resolveComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveDirective", function() { return resolveDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveDynamicComponent", function() { return resolveDynamicComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveTransitionHooks", function() { return resolveTransitionHooks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBlockTracking", function() { return setBlockTracking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTransitionHooks", function() { return setTransitionHooks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssrContextKey", function() { return ssrContextKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ssrUtils", function() { return ssrUtils; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDisplayString", function() { return _toDisplayString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toHandlers", function() { return toHandlers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformVNodeArgs", function() { return transformVNodeArgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useCSSModule", function() { return useCSSModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSSRContext", function() { return useSSRContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useTransitionState", function() { return useTransitionState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "warn", function() { return warn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "watch", function() { return watch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "watchEffect", function() { return watchEffect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withCtx", function() { return withCtx; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withDirectives", function() { return withDirectives; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withScopeId", function() { return withScopeId; });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customRef", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["customRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isProxy", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isProxy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReactive", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadonly", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRef", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "markRaw", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["markRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reactive", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["reactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readonly", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["readonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ref", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["ref"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReactive", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["shallowReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReadonly", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["shallowReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowRef", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["shallowRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRaw", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRef", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRefs", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRefs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triggerRef", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["triggerRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unref", function() { return _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["unref"]; });

/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);




const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["pauseTracking"])();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["resetTracking"])();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
function formatProp(key, value, raw) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"])(value)) {
        value = formatProp(key, Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isPromise"])(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( false) ? undefined : type;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo)) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode);
}
function logError(err, type, contextVNode) {
    // default behavior is crash in prod & test, recover in dev.
    if (false) {}
    else {
        throw err;
    }
}

const queue = [];
const postFlushCbs = [];
const p = Promise.resolve();
let isFlushing = false;
let isFlushPending = false;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    return fn ? p.then(fn) : p;
}
function queueJob(job) {
    if (!queue.includes(job)) {
        queue.push(job);
        queueFlush();
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > -1) {
        queue[i] = null;
    }
}
function queuePostFlushCb(cb) {
    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(cb)) {
        postFlushCbs.push(cb);
    }
    else {
        postFlushCbs.push(...cb);
    }
    queueFlush();
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        nextTick(flushJobs);
    }
}
function flushPostFlushCbs(seen) {
    if (postFlushCbs.length) {
        const cbs = [...new Set(postFlushCbs)];
        postFlushCbs.length = 0;
        if ((false)) {}
        for (let i = 0; i < cbs.length; i++) {
            if ((false)) {}
            cbs[i]();
        }
    }
}
const getId = (job) => (job.id == null ? Infinity : job.id);
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    let job;
    if ((false)) {}
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    // Jobs can never be null before flush starts, since they are only invalidated
    // during execution of another flushed job.
    queue.sort((a, b) => getId(a) - getId(b));
    while ((job = queue.shift()) !== undefined) {
        if (job === null) {
            continue;
        }
        if ((false)) {}
        callWithErrorHandling(job, null, 14 /* SCHEDULER */);
    }
    flushPostFlushCbs(seen);
    isFlushing = false;
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
    if (queue.length || postFlushCbs.length) {
        flushJobs(seen);
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            throw new Error('Maximum recursive updates exceeded. ' +
                "You may have code that is mutating state in your component's " +
                'render function or updated hook or watcher source function.');
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

// mark the current rendering instance for asset resolution (e.g.
// resolveComponent, resolveDirective) during render
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
    currentRenderingInstance = instance;
}
// dev only flag to track whether $attrs was used during render.
// If $attrs was used during render then the warning for failed attrs
// fallthrough can be suppressed.
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, parent, vnode, proxy, withProxy, props, slots, attrs, emit, renderCache } = instance;
    let result;
    currentRenderingInstance = instance;
    if ((false)) {}
    try {
        let fallthroughAttrs;
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(instance.render.call(proxyToUse, proxyToUse, renderCache));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (false) {}
            result = normalizeVNode(render.length > 1
                ? render(props, ( false)
                    ? undefined
                    : { attrs, slots, emit })
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props ? attrs : getFallthroughAttrs(attrs);
        }
        // attr merging
        // in dev mode, comments are preserved, and it's possible for a template
        // to have comments along side the root element which makes it a fragment
        let root = result;
        let setRoot = undefined;
        if ((false)) {}
        if (Component.inheritAttrs !== false &&
            fallthroughAttrs &&
            Object.keys(fallthroughAttrs).length) {
            if (root.shapeFlag & 1 /* ELEMENT */ ||
                root.shapeFlag & 6 /* COMPONENT */) {
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (false) {}
        }
        // inherit scopeId
        const parentScopeId = parent && parent.type.__scopeId;
        if (parentScopeId) {
            root = cloneVNode(root, { [parentScopeId]: '' });
        }
        // inherit directives
        if (vnode.dirs) {
            if (false) {}
            root.dirs = vnode.dirs;
        }
        // inherit transition data
        if (vnode.transition) {
            if (false) {}
            root.transition = vnode.transition;
        }
        if (false) {}
        else {
            result = root;
        }
    }
    catch (err) {
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    currentRenderingInstance = null;
    return result;
}
const getChildRoot = (vnode) => {
    if (vnode.type !== Fragment) {
        return [vnode, undefined];
    }
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const children = rawChildren.filter(child => {
        return !(isVNode(child) && child.type === Comment);
    });
    if (children.length !== 1) {
        return [vnode, undefined];
    }
    const childRoot = children[0];
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren
        ? dynamicChildren.indexOf(childRoot)
        : null;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicIndex !== null)
            dynamicChildren[dynamicIndex] = updatedRoot;
    };
    return [normalizeVNode(childRoot), setRoot];
};
const getFallthroughAttrs = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isOn"])(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & 6 /* COMPONENT */ ||
        vnode.shapeFlag & 1 /* ELEMENT */ ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, parentComponent, optimized) {
    const { props: prevProps, children: prevChildren } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (false) {}
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (patchFlag > 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key]) {
                    return true;
                }
            }
        }
    }
    else if (!optimized) {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key]) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense
};
// Force-casted public typing for h and TSX props inference
const Suspense = ( SuspenseImpl
    );
function mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (n2.suspense = createSuspenseBoundary(n2, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, suspense.subTree, hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // mount the fallback tree
        patch(null, suspense.fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, optimized);
        n2.el = suspense.fallbackTree.el;
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, optimized, { p: patch }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    const { content, fallback } = normalizeSuspenseChildren(n2);
    const oldSubTree = suspense.subTree;
    const oldFallbackTree = suspense.fallbackTree;
    if (!suspense.isResolved) {
        patch(oldSubTree, content, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, optimized);
        if (suspense.deps > 0) {
            // still pending. patch the fallback tree.
            patch(oldFallbackTree, fallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
            isSVG, optimized);
            n2.el = fallback.el;
        }
        // If deps somehow becomes 0 after the patch it means the patch caused an
        // async dep component to unmount and removed its dep. It will cause the
        // suspense to resolve and we don't need to do anything here.
    }
    else {
        // just normal patch inner content as a fragment
        patch(oldSubTree, content, container, anchor, parentComponent, suspense, isSVG, optimized);
        n2.el = content.el;
    }
    suspense.subTree = content;
    suspense.fallbackTree = fallback;
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if (false) {}
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode } } = rendererInternals;
    const getCurrentTree = () => suspense.isResolved || suspense.isHydrating
        ? suspense.subTree
        : suspense.fallbackTree;
    const { content, fallback } = normalizeSuspenseChildren(vnode);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        optimized,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        subTree: content,
        fallbackTree: fallback,
        isHydrating,
        isResolved: false,
        isUnmounted: false,
        effects: [],
        resolve() {
            if ((false)) {}
            const { vnode, subTree, fallbackTree, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else {
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount fallback tree
                if (fallbackTree.el) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(fallbackTree);
                    unmount(fallbackTree, parentComponent, suspense, true);
                }
                // move content from off-dom container to actual container
                move(subTree, container, anchor, 0 /* ENTER */);
            }
            const el = (vnode.el = subTree.el);
            // suspense as the root node of a component...
            if (parentComponent && parentComponent.subTree === vnode) {
                parentComponent.vnode.el = el;
                updateHOCHostEl(parentComponent, el);
            }
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (!parent.isResolved) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.isResolved = true;
            suspense.effects = [];
            // invoke @resolve event
            const onResolve = vnode.props && vnode.props.onResolve;
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(onResolve)) {
                onResolve();
            }
        },
        recede() {
            suspense.isResolved = false;
            const { vnode, subTree, fallbackTree, parentComponent, container, hiddenContainer, isSVG, optimized } = suspense;
            // move content tree back to the off-dom container
            const anchor = next(subTree);
            move(subTree, hiddenContainer, null, 1 /* LEAVE */);
            // remount the fallback tree
            patch(null, fallbackTree, container, anchor, parentComponent, null, // fallback tree will not have suspense context
            isSVG, optimized);
            const el = (vnode.el = fallbackTree.el);
            // suspense as the root node of a component...
            if (parentComponent && parentComponent.subTree === vnode) {
                parentComponent.vnode.el = el;
                updateHOCHostEl(parentComponent, el);
            }
            // invoke @recede event
            const onRecede = vnode.props && vnode.props.onRecede;
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(onRecede)) {
                onRecede();
            }
        },
        move(container, anchor, type) {
            move(getCurrentTree(), container, anchor, type);
            suspense.container = container;
        },
        next() {
            return next(getCurrentTree());
        },
        registerDep(instance, setupRenderEffect) {
            // suspense is already resolved, need to recede.
            // use queueJob so it's handled synchronously after patching the current
            // suspense tree
            if (suspense.isResolved) {
                queueJob(() => {
                    suspense.recede();
                });
            }
            const hydratedEl = instance.vnode.el;
            suspense.deps++;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted || suspense.isUnmounted) {
                    return;
                }
                suspense.deps--;
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((false)) {}
                handleSetupResult(instance, asyncSetupResult);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                hydratedEl
                    ? parentNode(hydratedEl)
                    : parentNode(instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                updateHOCHostEl(instance, vnode.el);
                if ((false)) {}
                if (suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            unmount(suspense.subTree, parentComponent, parentSuspense, doRemove);
            if (!suspense.isResolved) {
                unmount(suspense.fallbackTree, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, optimized, rendererInternals, hydrateNode) {
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, suspense.subTree, parentComponent, suspense, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    if (shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const { default: d, fallback } = children;
        return {
            content: normalizeVNode(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(d) ? d() : d),
            fallback: normalizeVNode(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(fallback) ? fallback() : fallback)
        };
    }
    else {
        return {
            content: normalizeVNode(children),
            fallback: normalizeVNode(null)
        };
    }
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && !suspense.isResolved) {
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}

/**
 * Wrap a slot function to memoize current rendering instance
 * @internal
 */
function withCtx(fn, ctx = currentRenderingInstance) {
    if (!ctx)
        return fn;
    return function renderFnWithContext() {
        const owner = currentRenderingInstance;
        setCurrentRenderingInstance(ctx);
        const res = fn.apply(null, arguments);
        setCurrentRenderingInstance(owner);
        return res;
    };
}

// SFC scoped style ID management.
let currentScopeId = null;
const scopeIdStack = [];
/**
 * @internal
 */
function pushScopeId(id) {
    scopeIdStack.push((currentScopeId = id));
}
/**
 * @internal
 */
function popScopeId() {
    scopeIdStack.pop();
    currentScopeId = scopeIdStack[scopeIdStack.length - 1] || null;
}
/**
 * @internal
 */
function withScopeId(id) {
    return ((fn) => withCtx(function () {
        pushScopeId(id);
        const res = fn.apply(this, arguments);
        popScopeId();
        return res;
    }));
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(targetSelector)) {
        if (!select) {
            ( false) &&
                false;
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( false) &&
                    false;
            }
            return target;
        }
    }
    else {
        if (false) {}
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        const { shapeFlag, children } = n2;
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( false)
                ? undefined
                : createText(''));
            const mainAnchor = (n2.anchor = ( false)
                ? undefined
                : createText(''));
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
            }
            else if ((false)) {}
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            if (n2.dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, n2.dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((false)) {}
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, { r: remove, o: { remove: hostRemove } }) {
        const { shapeFlag, children, anchor } = vnode;
        hostRemove(anchor);
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                remove(children[i]);
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, optimized);
            }
            target._lpa = nextSibling(vnode.targetAnchor);
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
function resolveComponent(name) {
    return resolveAsset(COMPONENTS, name) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return component || NULL_DYNAMIC_COMPONENT;
    }
}
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        let camelized, capitalized;
        const registry = instance[type];
        let res = registry[name] ||
            registry[(camelized = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"])(name))] ||
            registry[(capitalized = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["capitalize"])(camelized))];
        if (!res && type === COMPONENTS) {
            const self = instance.type;
            const selfName = self.displayName || self.name;
            if (selfName &&
                (selfName === name ||
                    selfName === camelized ||
                    selfName === capitalized)) {
                res = self;
            }
        }
        if ((false)) {}
        return res;
    }
    else if ((false)) {}
}

const Fragment = Symbol(( false) ? undefined : undefined);
const Text = Symbol(( false) ? undefined : undefined);
const Comment = Symbol(( false) ? undefined : undefined);
const Static = Symbol(( false) ? undefined : undefined);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @internal
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let shouldTrack = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @internal
 */
function setBlockTracking(value) {
    shouldTrack += value;
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @internal
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    const vnode = createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */);
    // save current block children on the block vnode
    vnode.dynamicChildren = currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_ARR"];
    // close block
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (false) {}
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref }) => (ref != null
    ? Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(ref)
        ? ref
        : [currentRenderingInstance, ref]
    : null);
const createVNode = (( false)
    ? undefined
    : _createVNode);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (false) {}
        type = Comment;
    }
    // class component normalization.
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(type) && '__vccOpts' in type) {
        type = type.__vccOpts;
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isProxy"])(props) || InternalObjectKey in props) {
            props = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])({}, props);
        }
        let { class: klass, style } = props;
        if (klass && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(klass)) {
            props.class = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["normalizeClass"])(klass);
        }
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isProxy"])(style) && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(style)) {
                style = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])({}, style);
            }
            props.style = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["normalizeStyle"])(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(type)
        ? 1 /* ELEMENT */
        :  isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (false) {}
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        children: null,
        component: null,
        suspense: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    normalizeChildren(vnode, children);
    // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    if (shouldTrack > 0 &&
        !isBlockNode &&
        currentBlock &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        patchFlag !== 32 /* HYDRATE_EVENTS */ &&
        (patchFlag > 0 ||
            shapeFlag & 128 /* SUSPENSE */ ||
            shapeFlag & 64 /* TELEPORT */ ||
            shapeFlag & 4 /* STATEFUL_COMPONENT */ ||
            shapeFlag & 2 /* FUNCTIONAL_COMPONENT */)) {
        currentBlock.push(vnode);
    }
    return vnode;
}
function cloneVNode(vnode, extraProps) {
    const props = (extraProps
        ? vnode.props
            ? mergeProps(vnode.props, extraProps)
            : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])({}, extraProps)
        : vnode.props);
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    return {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: vnode.scopeId,
        children: vnode.children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to bail out of optimized mode.
        // however we don't want block nodes to de-opt their children, so if the
        // vnode is a block node, we only add the FULL_PROPS flag to it.
        patchFlag: extraProps
            ? vnode.dynamicChildren
                ? vnode.patchFlag | 16 /* FULL_PROPS */
                : -2 /* BAIL */
            : vnode.patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        el: vnode.el,
        anchor: vnode.anchor
    };
}
/**
 * @internal
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @internal
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @internal
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(child)) {
        // fragment
        return createVNode(Fragment, null, child);
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return child.el === null ? child : cloneVNode(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        // Normalize slot to plain children
        if ((shapeFlag & 1 /* ELEMENT */ || shapeFlag & 64 /* TELEPORT */) &&
            children.default) {
            normalizeChildren(vnode, children.default());
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            if (!children._ && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
        }
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
const handlersRE = /^on|^vnode/;
function mergeProps(...args) {
    const ret = {};
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])(ret, args[0]);
    for (let i = 1; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["normalizeClass"])([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["normalizeStyle"])([ret.style, toMerge.style]);
            }
            else if (handlersRE.test(key)) {
                // on*, vnode*
                const existing = ret[key];
                const incoming = toMerge[key];
                if (existing !== incoming) {
                    ret[key] = existing
                        ? [].concat(existing, toMerge[key])
                        : incoming;
                }
            }
            else {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}

function emit(instance, event, ...args) {
    const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
    if ((false)) {}
    let handler = props[`on${Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["capitalize"])(event)}`];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && event.startsWith('update:')) {
        event = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hyphenate"])(event);
        handler = props[`on${Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["capitalize"])(event)}`];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}
function normalizeEmitsOptions(options) {
    if (!options) {
        return;
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(options)) {
        if (options._n) {
            return options._n;
        }
        const normalized = {};
        options.forEach(key => (normalized[key] = null));
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["def"])(options, '_n', normalized);
        return normalized;
    }
    else {
        return options;
    }
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(emits, key) {
    return (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isOn"])(key) &&
        (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])((emits = normalizeEmitsOptions(emits)), key[2].toLowerCase() + key.slice(3)) ||
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(emits, key.slice(2))));
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["def"])(attrs, InternalObjectKey, 1);
    setFullProps(instance, rawProps, props, attrs);
    const options = instance.type.props;
    // validation
    if (false) {}
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["shallowReactive"])(props);
    }
    else {
        if (!options) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawOptions = instance.type.props;
    const rawCurrentProps = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(props);
    const { 0: options } = normalizePropsOptions(rawOptions);
    if ((optimized || patchFlag > 0) && !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(attrs, key)) {
                        attrs[key] = value;
                    }
                    else {
                        const camelizedKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"])(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value);
                    }
                }
                else {
                    attrs[key] = value;
                }
            }
        }
    }
    else {
        // full props update.
        setFullProps(instance, rawProps, props, attrs);
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hyphenate"])(key)) === key || !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps && rawPrevProps[kebabKey] !== undefined) {
                        props[key] = resolvePropValue(options, rawProps || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"], key, undefined);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps || !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(rawProps, key)) {
                    delete attrs[key];
                }
            }
        }
    }
    if (false) {}
}
function setFullProps(instance, rawProps, props, attrs) {
    const { 0: options, 1: needCastKeys } = normalizePropsOptions(instance.type.props);
    const emits = instance.type.emits;
    if (rawProps) {
        for (const key in rawProps) {
            const value = rawProps[key];
            // key, ref are reserved and never passed down
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isReservedProp"])(key)) {
                continue;
            }
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(options, (camelKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"])(key)))) {
                props[camelKey] = value;
            }
            else if (!emits || !isEmitListener(emits, key)) {
                // Any non-declared (either as a prop or an emitted event) props are put
                // into a separate `attrs` object for spreading. Make sure to preserve
                // original key casing
                attrs[key] = value;
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(props);
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, rawCurrentProps[key]);
        }
    }
}
function resolvePropValue(options, props, key, value) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            value = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(defaultValue) ? defaultValue() : defaultValue;
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(props, key) && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hyphenate"])(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(raw) {
    if (!raw) {
        return _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_ARR"];
    }
    if (raw._n) {
        return raw._n;
    }
    const normalized = {};
    const needCastKeys = [];
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (false) {}
            const normalizedKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"])(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
            }
        }
    }
    else {
        if (false) {}
        for (const key in raw) {
            const normalizedKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"])(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(opt) || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const normalizedEntry = [normalized, needCastKeys];
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["def"])(raw, '_n', normalizedEntry);
    return normalizedEntry;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(expectedTypes)) {
        for (let i = 0, len = expectedTypes.length; i < len; i++) {
            if (isSameType(expectedTypes[i], type)) {
                return i;
            }
        }
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
function validateProps(props, rawOptions) {
    const rawValues = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(props);
    const options = normalizePropsOptions(rawOptions)[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, rawValues[key], opt, !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(rawValues, key));
    }
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((false)) {}
    return false;
}
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["makeMap"])('String,Number,Boolean,Function,Symbol');
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["toRawType"])(value) === 'Object';
    }
    else if (expectedType === 'Array') {
        valid = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value);
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["capitalize"]).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["toRawType"])(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => withCtx((props) => {
    if (false) {}
    return normalizeSlotValue(rawSlot(props));
}, ctx);
const normalizeObjectSlots = (rawSlots, slots) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if ((false)) {}
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (false) {}
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        if (children._ === 1) {
            instance.slots = children;
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}));
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["def"])(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        if (children._ === 1) {
            // compiled slots.
            if (
            // bail on dynamic slots (v-if, v-for, reference of scope variables)
            !(vnode.patchFlag & 1024 /* DYNAMIC_SLOTS */) &&
                // bail on HRM updates
                !( false && false)) {
                // compiled AND static.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic - update slots, but skip normalization.
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])(slots, children);
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
const isBuiltInDirective = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["makeMap"])('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text');
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        warn('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( false) && false;
        return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]] = directives[i];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        const hook = binding.dir[name];
        if (hook) {
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
        }
    }
}

function createAppContext() {
    return {
        config: {
            isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NO"],
            devtools: true,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NO"],
            errorHandler: undefined,
            warnHandler: undefined
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null)
    };
}
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (rootProps != null && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(rootProps)) {
            ( false) && false;
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = {
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((false)) {}
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( false) && false;
                }
                else if (plugin && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((false)) {}
                return app;
            },
            mixin(mixin) {
                {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((false)) {}
                }
                return app;
            },
            component(name, component) {
                if ((false)) {}
                if (!component) {
                    return context.components[name];
                }
                if (false) {}
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((false)) {}
                if (!directive) {
                    return context.directives[name];
                }
                if (false) {}
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate) {
                if (!isMounted) {
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((false)) {}
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    return vnode.component.proxy;
                }
                else if ((false)) {}
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                }
                else if ((false)) {}
            },
            provide(key, value) {
                if (false) {}
                // TypeScript doesn't allow symbols as index type
                // https://github.com/Microsoft/TypeScript/issues/24587
                context.provides[key] = value;
                return app;
            }
        };
        return app;
    };
}

// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((false)) {}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).delete(instance);
}
function createRecord(id, comp) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, new Set());
    return true;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record).forEach(instance => {
        if (newRender) {
            instance.render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        instance.renderUpdated = true;
        instance.update();
        instance.renderUpdated = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    // Array.from creates a snapshot which avoids the set being mutated during
    // updates
    Array.from(record).forEach(instance => {
        const comp = instance.type;
        if (!comp.__hmrUpdated) {
            // 1. Update existing comp definition to match new one
            Object.assign(comp, newComp);
            for (const key in comp) {
                if (!(key in newComp)) {
                    delete comp[key];
                }
            }
            // 2. Mark component dirty. This forces the renderer to replace the component
            // on patch.
            comp.__hmrUpdated = true;
            // 3. Make sure to unmark the component after the reload.
            queuePostFlushCb(() => {
                comp.__hmrUpdated = false;
            });
        }
        if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    });
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (false) {}
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null);
        flushPostFlushCbs();
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismtach(node, vnode, parentComponent, parentSuspense, isFragmentStart);
        const { type, shapeFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    return onMismatch();
                }
                if (node.data !== vnode.children) {
                    hasMismatch = true;
                    ( false) &&
                        false;
                    node.data = vnode.children;
                }
                return nextSibling(node);
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    return onMismatch();
                }
                return nextSibling(node);
            case Static:
                if (domType !== 1 /* ELEMENT */) {
                    return onMismatch();
                }
                // determine anchor, adopt content
                let cur = node;
                // if the static vnode has its content stripped during build,
                // adopt it from the server-rendered HTML.
                const needToAdoptContent = !vnode.children.length;
                for (let i = 0; i < vnode.staticCount; i++) {
                    if (needToAdoptContent)
                        vnode.children += cur.outerHTML;
                    if (i === vnode.staticCount - 1) {
                        vnode.anchor = cur;
                    }
                    cur = nextSibling(cur);
                }
                return cur;
            case Fragment:
                if (!isFragmentStart) {
                    return onMismatch();
                }
                return hydrateFragment(node, vnode, parentComponent, parentSuspense, optimized);
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type !== node.tagName.toLowerCase()) {
                        return onMismatch();
                    }
                    return hydrateElement(node, vnode, parentComponent, parentSuspense, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    const container = parentNode(node);
                    const hydrateComponent = () => {
                        mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    };
                    // async component
                    const loadAsync = vnode.type.__asyncLoader;
                    if (loadAsync) {
                        loadAsync().then(hydrateComponent);
                    }
                    else {
                        hydrateComponent();
                    }
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    return isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        return onMismatch();
                    }
                    return vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, optimized, rendererInternals, hydrateChildren);
                }
                else if ( shapeFlag & 128 /* SUSPENSE */) {
                    return vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), optimized, rendererInternals, hydrateNode);
                }
                else if ((false)) {}
                return null;
        }
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { props, patchFlag, shapeFlag, dirs } = vnode;
        // skip props & children if this is hoisted static nodes
        if (patchFlag !== -1 /* HOISTED */) {
            // props
            if (props) {
                if (!optimized ||
                    (patchFlag & 16 /* FULL_PROPS */ ||
                        patchFlag & 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isReservedProp"])(key) && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isOn"])(key)) {
                            patchProp(el, key, null, props[key]);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (false) {}
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( false) &&
                        false;
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, vnode, container, parentComponent, parentSuspense, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const children = vnode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, optimized);
            }
            else {
                hasMismatch = true;
                if (false) {}
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container));
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, optimized) => {
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismtach = (node, vnode, parentComponent, parentSuspense, isFragment) => {
        hasMismatch = true;
        ( false) &&
            false;
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container));
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

const prodEffectOptions = {
    scheduler: queueJob
};
function createDevEffectOptions(instance) {
    return {
        scheduler: queueJob,
        onTrack: instance.rtc ? e => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(instance.rtc, e) : void 0,
        onTrigger: instance.rtg ? e => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(instance.rtg, e) : void 0
    };
}
const queuePostRenderEffect =  queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"], cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) => {
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((false)) {}
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if ( shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, internals);
                }
                else if ((false)) {}
        }
        // set ref
        if (ref != null && parentComponent) {
            const refValue = shapeFlag & 4 /* STATEFUL_COMPONENT */ ? n2.component.proxy : n2.el;
            setRef(ref, n1 && n1.ref, parentComponent, refValue);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    /**
     * Dev / HMR only
     */
    const moveStaticNode = (vnode, container, anchor) => {
        let cur = vnode.el;
        const end = vnode.anchor;
        while (cur && cur !== end) {
            const next = hostNextSibling(cur);
            hostInsert(cur, container, anchor);
            cur = next;
        }
        hostInsert(end, container, anchor);
    };
    /**
     * Dev / HMR only
     */
    const removeStaticNode = (vnode) => {
        let cur = vnode.el;
        while (cur && cur !== vnode.anchor) {
            const next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(vnode.anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, scopeId, patchFlag, dirs } = vnode;
        if (vnode.el &&
            hostCloneNode !== undefined &&
            patchFlag === -1 /* HOISTED */) {
            // If a vnode has non-null el, it means it's being reused.
            // Only static vnodes can be reused, so its mounted DOM nodes should be
            // exactly the same, and we can simply do a clone here.
            el = vnode.el = hostCloneNode(vnode.el);
        }
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
            // props
            if (props) {
                for (const key in props) {
                    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isReservedProp"])(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG);
                    }
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            // scopeId
            if (scopeId) {
                hostSetScopeId(el, scopeId);
            }
            const treeOwnerId = parentComponent && parentComponent.type.__scopeId;
            // vnode's own scopeId and the current patched component's scopeId is
            // different - this is a slot content node.
            if (treeOwnerId && treeOwnerId !== scopeId) {
                hostSetScopeId(el, treeOwnerId + '-s');
            }
            // children
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', optimized || !!vnode.dynamicChildren);
            }
            if (transition && !transition.persisted) {
                transition.beforeEnter(el);
            }
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            (transition && !transition.persisted) ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                transition && !transition.persisted && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        const oldProps = (n1 && n1.props) || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        let vnodeHook;
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        if (false) {}
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        if (prev !== next) {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG);
            if (false) {}
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            oldVNode.type === Fragment ||
                // - In the case of different nodes, there is going to be a replacement
                // which also requires the correct parent container
                !isSameVNodeType(oldVNode, newVNode) ||
                // - In the case of a component, it could contain anything.
                oldVNode.shapeFlag & 6 /* COMPONENT */
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isReservedProp"])(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                if (next !== prev) {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]) {
                for (const key in oldProps) {
                    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isReservedProp"])(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren } = n2;
        if (patchFlag > 0) {
            optimized = true;
        }
        if (false) {}
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG);
                if (false) {}
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, parentComponent, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (false) {}
        if ((false)) {}
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        if ((false)) {}
        setupComponent(instance);
        if ((false)) {}
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if ( instance.asyncDep) {
            if (!parentSuspense) {
                if ((false))
                    {}
                return;
            }
            parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((false)) {}
    };
    const updateComponent = (n1, n2, parentComponent, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, parentComponent, optimized)) {
            if (
                instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((false)) {}
                updateComponentPreRender(instance, n2, optimized);
                if ((false)) {}
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect runner.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.component = n1.component;
            n2.el = n1.el;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        // create reactive effect for rendering
        instance.update = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["effect"])(function componentEffect() {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, a, parent } = instance;
                if ((false)) {}
                const subTree = (instance.subTree = renderComponentRoot(instance));
                if ((false)) {}
                // beforeMount hook
                if (bm) {
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(bm);
                }
                // onVnodeBeforeMount
                if ((vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                if (el && hydrateNode) {
                    if ((false)) {}
                    // vnode has adopted host node - perform hydration instead of mount.
                    hydrateNode(initialVNode.el, subTree, instance, parentSuspense);
                    if ((false)) {}
                }
                else {
                    if ((false)) {}
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((false)) {}
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if ((vnodeHook = props && props.onVnodeMounted)) {
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, initialVNode);
                    }, parentSuspense);
                }
                // activated hook for keep-alive roots.
                if (a &&
                    initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
                    queuePostRenderEffect(a, parentSuspense);
                }
                instance.isMounted = true;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let vnodeHook;
                if ((false)) {}
                if (next) {
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                if ((false)) {}
                const nextTree = renderComponentRoot(instance);
                if ((false)) {}
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                next.el = vnode.el;
                // beforeUpdate hook
                if (bu) {
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                // reset refs
                // only needed if previous patch had refs
                if (instance.refs !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]) {
                    instance.refs = {};
                }
                if ((false)) {}
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((false)) {}
                next.el = nextTree.el;
                if (next === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => {
                        invokeVNodeHook(vnodeHook, parent, next, vnode);
                    }, parentSuspense);
                }
                if ((false)) {}
            }
        }, ( false) ? undefined : prodEffectOptions);
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        if (false) {}
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children);
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_ARR"];
        c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_ARR"];
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (false) {}
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_ARR"];
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if ( shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        // static node move can only happen when force updating HMR
        if (false) {}
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldKeepAlive = shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
        let vnodeHook;
        // unset ref
        if (ref != null && parentComponent) {
            setRef(ref, null, parentComponent, null);
        }
        if ((vnodeHook = props && props.onVnodeBeforeUnmount) && !shouldKeepAlive) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            if (shouldKeepAlive) {
                parentComponent.ctx.deactivate(vnode);
            }
            else {
                unmountComponent(vnode.component, parentSuspense, doRemove);
            }
        }
        else {
            if ( shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            // an unmounted teleport should always remove its children
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, internals);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if (((vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) &&
            !shouldKeepAlive) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            removeFragment(el, anchor);
            return;
        }
        if (false) {}
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (false) {}
        const { bum, effects, update, subTree, um, da, isDeactivated } = instance;
        // beforeUnmount hook
        if (bum) {
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(bum);
        }
        if (effects) {
            for (let i = 0; i < effects.length; i++) {
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["stop"])(effects[i]);
            }
        }
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["stop"])(update);
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        // deactivated hook
        if (da &&
            !isDeactivated &&
            instance.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            queuePostRenderEffect(da, parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (
            parentSuspense &&
            !parentSuspense.isResolved &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if ( vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const setRef = (rawRef, oldRawRef, parent, value) => {
        const [owner, ref] = rawRef;
        if (false) {}
        const oldRef = oldRawRef && oldRawRef[1];
        const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] ? (owner.refs = {}) : owner.refs;
        const setupState = owner.setupState;
        // unset old ref
        if (oldRef != null && oldRef !== ref) {
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(oldRef)) {
                refs[oldRef] = null;
                if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(setupState, oldRef)) {
                    setupState[oldRef] = null;
                }
            }
            else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"])(oldRef)) {
                oldRef.value = null;
            }
        }
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(ref)) {
            refs[ref] = value;
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(setupState, ref)) {
                setupState[ref] = value;
            }
        }
        else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"])(ref)) {
            ref.value = value;
        }
        else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(ref)) {
            callWithErrorHandling(ref, parent, 12 /* FUNCTION_REF */, [value, refs]);
        }
        else if ((false)) {}
    };
    /**
     * #1156
     * When a component is HMR-enabled, we need to make sure that all static nodes
     * inside a block also inherit the DOM element from the previous tree so that
     * HMR updates (which are full updates) can retrieve the element for patching.
     *
     * Dev only.
     */
    const traverseStaticChildren = (n1, n2) => {
        const ch1 = n1.children;
        const ch2 = n2.children;
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(ch1) && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(ch2)) {
            for (let i = 0; i < ch1.length; i++) {
                const c1 = ch1[i];
                const c2 = ch2[i];
                if (isVNode(c1) &&
                    isVNode(c2) &&
                    c2.shapeFlag & 1 /* ELEMENT */ &&
                    !c2.dynamicChildren) {
                    if (c2.patchFlag <= 0) {
                        c2.el = c1.el;
                    }
                    traverseStaticChildren(c1, c2);
                }
            }
        }
    };
    const render = (vnode, container) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = ((u + v) / 2) | 0;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: Function,
        onEnter: Function,
        onAfterEnter: Function,
        onEnterCancelled: Function,
        // leave
        onBeforeLeave: Function,
        onLeave: Function,
        onAfterLeave: Function,
        onLeaveCancelled: Function
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
            const children = slots.default && slots.default();
            if (!children || !children.length) {
                return;
            }
            // warn multiple elements
            if (false) {}
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(props);
            const { mode } = rawProps;
            // check mode
            if (false) {}
            // at this point children has a guaranteed length of 1.
            const child = children[0];
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = (innerChild.transition = resolveTransitionHooks(innerChild, rawProps, state, instance));
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                !isSameVNodeType(innerChild, oldInnerChild)) {
                const prevHooks = oldInnerChild.transition;
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out') {
                    delete prevHooks.delayedLeave;
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, { appear, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled }, state, instance) {
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const hooks = {
        persisted,
        beforeEnter(el) {
            if (!appear && !state.isMounted) {
                return;
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(onBeforeEnter, [el]);
        },
        enter(el) {
            if (!appear && !state.isMounted) {
                return;
            }
            let called = false;
            const afterEnter = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(onEnterCancelled, [el]);
                }
                else {
                    callHook(onAfterEnter, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (onEnter) {
                onEnter(el, afterEnter);
            }
            else {
                afterEnter();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const afterLeave = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                onLeave(el, afterLeave);
            }
            else {
                afterLeave();
            }
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else {
        vnode.transition = hooks;
    }
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const cache = new Map();
        const keys = new Set();
        let current = null;
        const instance = getCurrentInstance();
        const parentSuspense = instance.suspense;
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const child = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(child.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized);
            queuePostRenderEffect(() => {
                child.isDeactivated = false;
                if (child.a) {
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(child.a);
                }
            }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                const component = vnode.component;
                if (component.da) {
                    Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(component.da);
                }
                component.isDeactivated = true;
            }, parentSuspense);
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            vnode.shapeFlag = 4 /* STATEFUL_COMPONENT */;
            _unmount(vnode, instance, parentSuspense);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                current.shapeFlag = 4 /* STATEFUL_COMPONENT */;
            }
            cache.delete(key);
            keys.delete(key);
        }
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => matches(exclude, name));
        });
        onBeforeUnmount(() => {
            cache.forEach(unmount);
        });
        return () => {
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            let vnode = children[0];
            if (children.length > 1) {
                if ((false)) {}
                current = null;
                return children;
            }
            else if (!isVNode(vnode) ||
                !(vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */)) {
                current = null;
                return vnode;
            }
            const comp = vnode.type;
            const name = getName(comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                return vnode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
            }
            cache.set(key, vnode);
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(Array.from(keys)[0]);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return vnode;
        };
    }
};
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function getName(comp) {
    return comp.displayName || comp.name;
}
function matches(pattern, name) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(pattern)) {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["remove"])(keepAliveRoot[type], hook);
    }, target);
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["pauseTracking"])();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                setCurrentInstance(null);
                Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["resetTracking"])();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
    }
    else if ((false)) {}
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR
!isInSSRComponentSetup && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
const onErrorCaptured = (hook, target = currentInstance) => {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
};

const invoke = (fn) => fn();
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (false) {}
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]) {
    if (false) {}
    const warnInvalidSource = (s) => {
        warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(source)) {
        getter = () => source.map(s => {
            if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"])(s)) {
                return s.value;
            }
            else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isReactive"])(s)) {
                return traverse(s);
            }
            else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( false) && false;
            }
        });
    }
    else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isRef"])(source)) {
        getter = () => source.value;
    }
    else if (Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["isReactive"])(source)) {
        getter = () => source;
        deep = true;
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onInvalidate]);
            };
        }
    }
    else {
        getter = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"];
        ( false) && false;
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    const onInvalidate = (fn) => {
        cleanup = runner.options.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    let oldValue = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(source) ? [] : INITIAL_WATCHER_VALUE;
    const applyCb = cb
        ? () => {
            if (instance && instance.isUnmounted) {
                return;
            }
            const newValue = runner();
            if (deep || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasChanged"])(newValue, oldValue)) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onInvalidate
                ]);
                oldValue = newValue;
            }
        }
        : void 0;
    let scheduler;
    if (flush === 'sync') {
        scheduler = invoke;
    }
    else if (flush === 'pre') {
        scheduler = job => {
            if (!instance || instance.isMounted) {
                queueJob(job);
            }
            else {
                // with 'pre' option, the first call must happen before
                // the component is mounted so it is called synchronously.
                job();
            }
        };
    }
    else {
        scheduler = job => queuePostRenderEffect(job, instance && instance.suspense);
    }
    const runner = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["effect"])(getter, {
        lazy: true,
        // so it runs before component update effects in pre flush mode
        computed: true,
        onTrack,
        onTrigger,
        scheduler: applyCb ? () => scheduler(applyCb) : scheduler
    });
    recordInstanceBoundEffect(runner);
    // initial run
    if (applyCb) {
        if (immediate) {
            applyCb();
        }
        else {
            oldValue = runner();
        }
    }
    else {
        runner();
    }
    return () => {
        Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["stop"])(runner);
        if (instance) {
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["remove"])(instance.effects, runner);
        }
    };
}
// this.$watch
function instanceWatch(source, cb, options) {
    const publicThis = this.proxy;
    const getter = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(source)
        ? () => publicThis[source]
        : source.bind(publicThis);
    const stop = watch(getter, cb.bind(publicThis), options);
    onBeforeUnmount(stop, this);
    return stop;
}
function traverse(value, seen = new Set()) {
    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(value) || seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (value instanceof Map) {
        value.forEach((v, key) => {
            // to register mutation dep for existing keys
            traverse(value.get(key), seen);
        });
    }
    else if (value instanceof Set) {
        value.forEach(v => {
            traverse(v, seen);
        });
    }
    else {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function provide(key, value) {
    if (!currentInstance) {
        if ((false)) {}
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        const provides = instance.provides;
        if (key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return defaultValue;
        }
        else if ((false)) {}
    }
    else if ((false)) {}
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
function applyOptions(instance, options, deferredData = [], deferredWatch = [], asMixin = false) {
    const { 
    // composition
    mixins, extends: extendsOptions, 
    // state
    props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // assets
    components, directives, 
    // lifecycle
    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    const globalMixins = instance.appContext.mixins;
    // call it only during dev
    // applyOptions is called non-as-mixin once per instance
    if (!asMixin) {
        callSyncHook('beforeCreate', options, publicThis, globalMixins);
        // global mixins are applied first
        applyMixins(instance, globalMixins, deferredData, deferredWatch);
    }
    // extending a base component...
    if (extendsOptions) {
        applyOptions(instance, extendsOptions, deferredData, deferredWatch, true);
    }
    // local mixins
    if (mixins) {
        applyMixins(instance, mixins, deferredData, deferredWatch);
    }
    const checkDuplicateProperties = ( false) ? undefined : null;
    if (false) {}
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(injectOptions)) {
            for (let i = 0; i < injectOptions.length; i++) {
                const key = injectOptions[i];
                ctx[key] = inject(key);
                if ((false)) {}
            }
        }
        else {
            for (const key in injectOptions) {
                const opt = injectOptions[key];
                if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(opt)) {
                    ctx[key] = inject(opt.from, opt.default);
                }
                else {
                    ctx[key] = inject(opt);
                }
                if ((false)) {}
            }
        }
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(methodHandler)) {
                ctx[key] = methodHandler.bind(publicThis);
                if ((false)) {}
            }
            else if ((false)) {}
        }
    }
    if (dataOptions) {
        if (false) {}
        if (asMixin) {
            deferredData.push(dataOptions);
        }
        else {
            resolveData(instance, dataOptions, publicThis);
        }
    }
    if (!asMixin) {
        if (deferredData.length) {
            deferredData.forEach(dataFn => resolveData(instance, dataFn, publicThis));
        }
        if ((false)) {}
    }
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(opt)
                ? opt.bind(publicThis, publicThis)
                : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"];
            if (false) {}
            const set = !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(opt) && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(opt.set)
                ? opt.set.bind(publicThis)
                : ( false)
                    ? undefined
                    : _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"];
            const c = computed({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((false)) {}
        }
    }
    if (watchOptions) {
        deferredWatch.push(watchOptions);
    }
    if (!asMixin && deferredWatch.length) {
        deferredWatch.forEach(watchOptions => {
            for (const key in watchOptions) {
                createWatcher(watchOptions[key], ctx, publicThis, key);
            }
        });
    }
    if (provideOptions) {
        const provides = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        for (const key in provides) {
            provide(key, provides[key]);
        }
    }
    // asset options
    if (components) {
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])(instance.components, components);
    }
    if (directives) {
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])(instance.directives, directives);
    }
    // lifecycle options
    if (!asMixin) {
        callSyncHook('created', options, publicThis, globalMixins);
    }
    if (beforeMount) {
        onBeforeMount(beforeMount.bind(publicThis));
    }
    if (mounted) {
        onMounted(mounted.bind(publicThis));
    }
    if (beforeUpdate) {
        onBeforeUpdate(beforeUpdate.bind(publicThis));
    }
    if (updated) {
        onUpdated(updated.bind(publicThis));
    }
    if (activated) {
        onActivated(activated.bind(publicThis));
    }
    if (deactivated) {
        onDeactivated(deactivated.bind(publicThis));
    }
    if (errorCaptured) {
        onErrorCaptured(errorCaptured.bind(publicThis));
    }
    if (renderTracked) {
        onRenderTracked(renderTracked.bind(publicThis));
    }
    if (renderTriggered) {
        onRenderTriggered(renderTriggered.bind(publicThis));
    }
    if (beforeUnmount) {
        onBeforeUnmount(beforeUnmount.bind(publicThis));
    }
    if (unmounted) {
        onUnmounted(unmounted.bind(publicThis));
    }
}
function callSyncHook(name, options, ctx, globalMixins) {
    callHookFromMixins(name, globalMixins, ctx);
    const baseHook = options.extends && options.extends[name];
    if (baseHook) {
        baseHook.call(ctx);
    }
    const mixins = options.mixins;
    if (mixins) {
        callHookFromMixins(name, mixins, ctx);
    }
    const selfHook = options[name];
    if (selfHook) {
        selfHook.call(ctx);
    }
}
function callHookFromMixins(name, mixins, ctx) {
    for (let i = 0; i < mixins.length; i++) {
        const fn = mixins[i][name];
        if (fn) {
            fn.call(ctx);
        }
    }
}
function applyMixins(instance, mixins, deferredData, deferredWatch) {
    for (let i = 0; i < mixins.length; i++) {
        applyOptions(instance, mixins[i], deferredData, deferredWatch, true);
    }
}
function resolveData(instance, dataFn, publicThis) {
    const data = dataFn.call(publicThis, publicThis);
    if (false) {}
    if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(data)) {
        ( false) && false;
    }
    else if (instance.data === _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"]) {
        instance.data = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["reactive"])(data);
    }
    else {
        // existing data: this is a mixin or extends.
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["extend"])(instance.data, data);
    }
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = () => publicThis[key];
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(raw)) {
        const handler = ctx[raw];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(handler)) {
            watch(getter, handler);
        }
        else if ((false)) {}
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(raw)) {
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            watch(getter, raw.handler.bind(publicThis), raw);
        }
    }
    else if ((false)) {}
}
function resolveMergedOptions(instance) {
    const raw = instance.type;
    const { __merged, mixins, extends: extendsOptions } = raw;
    if (__merged)
        return __merged;
    const globalMixins = instance.appContext.mixins;
    if (!globalMixins.length && !mixins && !extendsOptions)
        return raw;
    const options = {};
    globalMixins.forEach(m => mergeOptions(options, m, instance));
    extendsOptions && mergeOptions(options, extendsOptions, instance);
    mixins && mixins.forEach(m => mergeOptions(options, m, instance));
    mergeOptions(options, raw, instance);
    return (raw.__merged = options);
}
function mergeOptions(to, from, instance) {
    const strats = instance.appContext.config.optionMergeStrategies;
    for (const key in from) {
        const strat = strats && strats[key];
        if (strat) {
            to[key] = strat(to[key], from[key], instance.proxy, key);
        }
        else if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(to, key)) {
            to[key] = from[key];
        }
    }
}

const publicPropertiesMap = {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( false) ? undefined : i.props),
    $attrs: i => (( false) ? undefined : i.attrs),
    $slots: i => (( false) ? undefined : i.slots),
    $refs: i => (( false) ? undefined : i.refs),
    $parent: i => i.parent && i.parent.proxy,
    $root: i => i.root && i.root.proxy,
    $emit: i => i.emit,
    $options: i => ( resolveMergedOptions(i) ),
    $forceUpdate: i => () => queueJob(i.update),
    $nextTick: () => nextTick,
    $watch:  i => instanceWatch.bind(i) 
};
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // let @vue/reatvitiy know it should never observe Vue public instances.
        if (key === "__v_skip" /* skip */) {
            return true;
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 0 /* SETUP */:
                        return setupState[key];
                    case 1 /* DATA */:
                        return data[key];
                    case 3 /* CONTEXT */:
                        return ctx[key];
                    case 2 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(setupState, key)) {
                accessCache[key] = 0 /* SETUP */;
                return setupState[key];
            }
            else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(data, key)) {
                accessCache[key] = 1 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            type.props &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(normalizePropsOptions(type.props)[0], key)) {
                accessCache[key] = 2 /* PROPS */;
                return props[key];
            }
            else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(ctx, key)) {
                accessCache[key] = 3 /* CONTEXT */;
                return ctx[key];
            }
            else {
                accessCache[key] = 4 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (false) {}
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 3 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(globalProperties, key))) {
            return globalProperties[key];
        }
        else if (false) {}
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(setupState, key)) {
            setupState[key] = value;
        }
        else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(data, key)) {
            data[key] = value;
        }
        else if (key in instance.props) {
            ( false) &&
                false;
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( false) &&
                false;
            return false;
        }
        else {
            if (false) {}
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, type, appContext } }, key) {
        return (accessCache[key] !== undefined ||
            (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(data, key)) ||
            (setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"] && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(setupState, key)) ||
            (type.props && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(normalizePropsOptions(type.props)[0], key)) ||
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(ctx, key) ||
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(publicPropertiesMap, key) ||
            Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hasOwn"])(appContext.config.globalProperties, key));
    }
};
if (false) {}
const RuntimeCompiledPublicInstanceProxyHandlers = {
    ...PublicInstanceProxyHandlers,
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isGloballyWhitelisted"])(key);
        if (false) {}
        return has;
    }
};
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"]
        });
    });
    // expose global properties
    const { globalProperties } = instance.appContext.config;
    Object.keys(globalProperties).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => globalProperties[key],
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"]
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, type: { props: propsOptions } } = instance;
    if (propsOptions) {
        Object.keys(normalizePropsOptions(propsOptions)[0]).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"]
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["toRaw"])(setupState)).forEach(key => {
        Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => setupState[key],
            set: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"]
        });
    });
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid++,
        vnode,
        parent,
        appContext,
        type: vnode.type,
        root: null,
        next: null,
        subTree: null,
        update: null,
        render: null,
        proxy: null,
        withProxy: null,
        effects: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // state
        ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"],
        setupContext: null,
        // per-instance asset storage (mutable during options resolution)
        components: Object.create(appContext.components),
        directives: Object.create(appContext.directives),
        // suspense related
        suspense,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        emit: null // to be set immediately
    };
    if ((false)) {}
    else {
        instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
};
const isBuiltInTag = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["makeMap"])('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NO"];
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children, shapeFlag } = instance.vnode;
    const isStateful = shapeFlag & 4 /* STATEFUL_COMPONENT */;
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    if ((false)) {}
    // 0. create render proxy property access cache
    instance.accessCache = {};
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    if ((false)) {}
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        currentInstance = instance;
        Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["pauseTracking"])();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( false) ? undefined : instance.props, setupContext]);
        Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["resetTracking"])();
        currentInstance = null;
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isPromise"])(setupResult)) {
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult.then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
            }
        }
        else {
            handleSetupResult(instance, setupResult);
        }
    }
    else {
        finishComponentSetup(instance);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(setupResult)) {
        // setup returned an inline render function
        instance.render = setupResult;
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(setupResult)) {
        if (false) {}
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        instance.setupState = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["reactive"])(setupResult);
        if ((false)) {}
    }
    else if (false) {}
    finishComponentSetup(instance);
}
let compile;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
}
function finishComponentSetup(instance, isSSR) {
    const Component = instance.type;
    // template / render function normalization
    if (!instance.render) {
        if (compile && Component.template && !Component.render) {
            if ((false)) {}
            Component.render = compile(Component.template, {
                isCustomElement: instance.appContext.config.isCustomElement || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NO"]
            });
            if ((false)) {}
            Component.render._rc = true;
        }
        if (false) {}
        instance.render = (Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["NOOP"]);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (instance.render._rc) {
            instance.withProxy = new Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    }
    // support for 2.x options
    {
        currentInstance = instance;
        applyOptions(instance, Component);
        currentInstance = null;
    }
}
const attrHandlers = {
    get: (target, key) => {
        if ((false)) {}
        return target[key];
    },
    set: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    },
    deleteProperty: () => {
        warn(`setupContext.attrs is readonly.`);
        return false;
    }
};
function createSetupContext(instance) {
    if ((false)) {}
    else {
        return {
            attrs: instance.attrs,
            slots: instance.slots,
            emit: instance.emit
        };
    }
}
// record effects created during a component's setup() so that they can be
// stopped when the component unmounts
function recordInstanceBoundEffect(effect) {
    if (currentInstance) {
        (currentInstance.effects || (currentInstance.effects = [])).push(effect);
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function formatComponentName(Component, isRoot = false) {
    let name = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(Component)
        ? Component.displayName || Component.name
        : Component.name;
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.vue$/);
        if (match) {
            name = match[1];
        }
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}

function computed(getterOrOptions) {
    const c = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["computed"])(getterOrOptions);
    recordInstanceBoundEffect(c.effect);
    return c;
}

// implementation, close to no-op
function defineComponent(options) {
    return Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(options) ? { setup: options } : options;
}

function defineAsyncComponent(source) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent: loadingComponent, errorComponent: errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest = loader()
                .catch(err => {
                err = err instanceof Error ? err : new Error(String(err));
                if (userOnError) {
                    return new Promise((resolve, reject) => {
                        const userRetry = () => resolve(retry());
                        const userFail = () => reject(err);
                        userOnError(err, userRetry, userFail, retries + 1);
                    });
                }
                else {
                    throw err;
                }
            })
                .then((comp) => {
                if (thisRequest !== pendingRequest && pendingRequest) {
                    return pendingRequest;
                }
                if (false) {}
                // interop module default
                if (comp &&
                    (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                    comp = comp.default;
                }
                if (false) {}
                resolvedComp = comp;
                return comp;
            })));
    };
    return defineComponent({
        __asyncLoader: load,
        name: 'AsyncComponentWrapper',
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */);
            };
            // suspense-controlled or SSR.
            if (( suspensible && instance.suspense) ||
                (false )) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, { error: err })
                        : null;
                });
            }
            const loaded = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["ref"])(false);
            const error = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["ref"])();
            const delayed = Object(_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__["ref"])(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { props, children } }) {
    return createVNode(comp, props, children);
}

// Actual implementation
function h(type, propsOrChildren, children) {
    if (arguments.length === 2) {
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(propsOrChildren) && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const useCSSModule = (name = '$style') => {
    {
        const instance = getCurrentInstance();
        if (!instance) {
            ( false) && false;
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( false) && false;
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        }
        const mod = modules[name];
        if (!mod) {
            ( false) &&
                false;
            return _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        }
        return mod;
    }
};

const ssrContextKey = Symbol(( false) ? undefined : ``);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn(`Server rendering context not provided. Make sure to only call ` +
                `useSsrContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

// actual implementation
function renderList(source, renderItem) {
    let ret;
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(source) || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i);
        }
    }
    else if (typeof source === 'number') {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i);
        }
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, renderItem);
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i);
            }
        }
    }
    else {
        ret = [];
    }
    return ret;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @internal
 */
function toHandlers(obj) {
    const ret = {};
    if (false) {}
    for (const key in obj) {
        ret[`on${key}`] = obj[key];
    }
    return ret;
}

/**
 * Compiler runtime helper for rendering <slot/>
 * @internal
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback) {
    let slot = slots[name];
    if (false) {}
    return (openBlock(),
        createBlock(Fragment, { key: props.key }, slot ? slot(props) : fallback ? fallback() : [], slots._ ? 64 /* STABLE_FRAGMENT */ : -2 /* BAIL */));
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @internal
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

// Core API ------------------------------------------------------------------
const version = "3.0.0-beta.14";
/**
 * @internal
 */
const _toDisplayString = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["toDisplayString"];
/**
 * @internal
 */
const _camelize = _vue_shared__WEBPACK_IMPORTED_MODULE_1__["camelize"];
/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */
const ssrUtils = ( null);




/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(69));
__export(__webpack_require__(72));
__export(__webpack_require__(40));
__export(__webpack_require__(92));
__export(__webpack_require__(49));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLShader_1 = __webpack_require__(23);
class WebGLDefaultShader extends WebGLShader_1.WebGLShader {
    enableAttribs() {
        // Enables the attribs in the shader program.
        const gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));
        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }
        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }
    disableAttribs() {
        // Disables the attribs in the shader program.
        const gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));
        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }
        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }
    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv);
    }
    draw(operation) {
        const gl = this.gl;
        const length = operation.length;
        const renderExecutor = this.context.renderExecutor;
        const indexType = renderExecutor.quadIndexType;
        const indexTypeBytes = renderExecutor.quadIndexType === WebGLRenderingContext.UNSIGNED_INT ? 4 : 2;
        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                const tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (i - pos), indexType, (pos + operation.index) * 6 * indexTypeBytes);
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.drawElements(gl.TRIANGLES, 6 * (length - pos), indexType, (pos + operation.index) * 6 * indexTypeBytes);
            }
        }
    }
}
exports.WebGLDefaultShader = WebGLDefaultShader;
WebGLDefaultShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLDefaultShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = __webpack_require__(18);
const TypeUtils_1 = __webpack_require__(11);
class Container extends Node_1.Node {
    constructor() {
        super(...arguments);
        this.containerElement = this.el;
    }
    getChildren() {
        let c = this.firstChild;
        const items = [];
        while (c) {
            if (c.element) {
                items.push(c);
            }
            c = c.nextSibling;
        }
        return items;
    }
    syncWithTree2d() {
        super.syncWithTree2d();
        const items = [];
        let c = this.firstChild;
        while (c) {
            if (c.element) {
                items.push(c.element);
            }
            c = c.nextSibling;
        }
        this.containerElement.childList.setItems(items);
    }
    set "force-z-index-context"(v) {
        this.el.forceZIndexContext = TypeUtils_1.ensureBoolean(v);
    }
    get clipping() {
        return this.el.clipping;
    }
    set clipping(v) {
        this.el.clipping = TypeUtils_1.ensureBoolean(v);
    }
    get clipbox() {
        return this.el.clipbox;
    }
    set clipbox(v) {
        this.el.clipbox = TypeUtils_1.ensureBoolean(v);
    }
    get "render-to-texture"() {
        return this.el.renderToTexture;
    }
    set "render-to-texture"(v) {
        this.el.renderToTexture = TypeUtils_1.ensureBoolean(v);
    }
    get "render-to-texture-lazy"() {
        return this.el.renderToTextureLazy;
    }
    set "render-to-texture-lazy"(v) {
        this.el.renderToTextureLazy = TypeUtils_1.ensureBoolean(v);
    }
    get "render-to-texture-offscreen"() {
        return this.el.renderToTextureOffscreen;
    }
    set "render-to-texture-offscreen"(v) {
        this.el.renderToTextureOffscreen = TypeUtils_1.ensureBoolean(v);
    }
    get "render-to-texture-colorize"() {
        return this.el.renderToTextureColorize;
    }
    set "render-to-texture-colorize"(v) {
        this.el.renderToTextureColorize = TypeUtils_1.ensureBoolean(v);
    }
    get flex() {
        return this.el.flex;
    }
    set flex(v) {
        this.el.flex = TypeUtils_1.ensureBoolean(v);
    }
    get "flex-direction"() {
        return this.el.flexDirection;
    }
    set "flex-direction"(v) {
        this.el.flexDirection = v;
    }
    get "flex-wrap"() {
        return this.el.flexWrap;
    }
    set "flex-wrap"(v) {
        this.el.flexWrap = TypeUtils_1.ensureBoolean(v);
    }
    get "flex-align-items"() {
        return this.el.flexAlignItems;
    }
    set "flex-align-items"(v) {
        this.el.flexAlignItems = v;
    }
    get "flex-justify-content"() {
        return this.el.flexJustifyContent;
    }
    set "flex-justify-content"(v) {
        this.el.flexJustifyContent = v;
    }
    get "flex-align-content"() {
        return this.el.flexAlignContent;
    }
    set "flex-align-content"(v) {
        this.el.flexAlignContent = v;
    }
    get padding() {
        return this.el.padding;
    }
    set padding(v) {
        this.el.padding = TypeUtils_1.ensureFloat(v);
    }
    get "padding-left"() {
        return this.el.paddingLeft;
    }
    set "padding-left"(v) {
        this.el.paddingLeft = TypeUtils_1.ensureFloat(v);
    }
    get "padding-right"() {
        return this.el.paddingRight;
    }
    set "padding-right"(v) {
        this.el.paddingRight = TypeUtils_1.ensureFloat(v);
    }
    get "padding-top"() {
        return this.el.paddingTop;
    }
    set "padding-top"(v) {
        this.el.paddingTop = TypeUtils_1.ensureFloat(v);
    }
    get "padding-bottom"() {
        return this.el.paddingBottom;
    }
    set "padding-bottom"(v) {
        this.el.paddingBottom = TypeUtils_1.ensureFloat(v);
    }
}
exports.Container = Container;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Utils {
    static isFunction(value) {
        return typeof value === "function";
    }
    static isNumber(value) {
        return typeof value === "number";
    }
    static isInteger(value) {
        return typeof value === "number" && value % 1 === 0;
    }
    static isBoolean(value) {
        return value === true || value === false;
    }
    static isString(value) {
        return typeof value === "string";
    }
    static clone(v) {
        if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
            return Utils.getDeepClone(v);
        }
        else {
            // Copy by value.
            return v;
        }
    }
    static cloneObjShallow(obj) {
        const keys = Object.keys(obj);
        const clone = {};
        for (const k of Object.keys(obj)) {
            clone[k] = obj[k];
        }
        return clone;
    }
    static merge(obj1, obj2) {
        for (const k of Object.keys(obj2)) {
            obj1[k] = obj2[k];
        }
        return obj1;
    }
    static isObject(value) {
        const type = typeof value;
        return !!value && (type === "object" || type === "function");
    }
    static isPlainObject(value) {
        const type = typeof value;
        return !!value && type === "object";
    }
    static isObjectLiteral(value) {
        return typeof value === "object" && value && value.constructor === Object;
    }
    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }
    static getModuloIndex(index, len) {
        if (len === 0)
            return index;
        while (index < 0) {
            index += Math.ceil(-index / len) * len;
        }
        index = index % len;
        return index;
    }
    static getDeepClone(obj) {
        if (Utils.isFunction(obj)) {
            // Copy functions by reference.
            return obj;
        }
        if (Array.isArray(obj)) {
            const c = [];
            for (const key of Object.keys(obj)) {
                const v = obj[key];
                c[key] = Utils.getDeepClone(v);
            }
            return c;
        }
        else if (Utils.isObject(obj)) {
            const c = {};
            for (const key of Object.keys(obj)) {
                const v = obj[key];
                c[key] = Utils.getDeepClone(v);
            }
            return c;
        }
        else {
            return obj;
        }
    }
    static equalValues(v1, v2) {
        if (typeof v1 !== typeof v2)
            return false;
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
        }
        else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2);
        }
        else {
            return v1 === v2;
        }
    }
    static equalObjectLiterals(obj1, obj2) {
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }
        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false;
            }
            const v1 = obj1[k1];
            const v2 = obj2[k2];
            if (!Utils.equalValues(v1, v2)) {
                return false;
            }
        }
        return true;
    }
    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false;
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false;
            }
        }
        return true;
    }
    static setToArray(s) {
        const result = new Array();
        s.forEach((value) => {
            result.push(value);
        });
        return result;
    }
    static iteratorToArray(iterator) {
        const result = [];
        let iteratorResult = iterator.next();
        while (!iteratorResult.done) {
            result.push(iteratorResult.value);
            iteratorResult = iterator.next();
        }
        return result;
    }
    static isUcChar(charcode) {
        return charcode >= 65 && charcode <= 90;
    }
}
exports.Utils = Utils;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Texture {
    constructor(stage) {
        this.stage = stage;
        this.manager = this.stage.textureManager;
        this.id = Texture.id++;
        // All enabled elements that use this texture object (either as texture or displayedTexture).
        this.elements = new Set();
        // The number of enabled elements that are active.
        this._activeCount = 0;
        this._source = undefined;
        // Texture clipping coordinates.
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        // Render precision (0.5 = fuzzy, 1 = normal, 2 = sharp even when scaled twice, etc.).
        this._pixelRatio = 1;
        /**
         * The (maximum) expected texture source dimensions. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         */
        this.mw = 0;
        this.mh = 0;
        // Flag that indicates that this texture uses clipping.
        this.clipping = false;
        // Indicates whether this texture must update (when it becomes used again).
        this._mustUpdate = true;
    }
    get source() {
        return this.getUpdatedSource();
    }
    getUpdatedSource() {
        if (this._mustUpdate || this.stage.hasUpdateTexture(this)) {
            this._performUpdateSource(true);
            this.stage.removeUpdateTexture(this);
        }
        return this._source;
    }
    getSource() {
        return this._source;
    }
    addElement(v) {
        if (!this.elements.has(v)) {
            this.elements.add(v);
            if (this.elements.size === 1) {
                if (this._source) {
                    this._source.addTexture(this);
                }
            }
            if (v.active) {
                this.incActiveCount();
            }
        }
    }
    removeElement(v) {
        if (this.elements.delete(v)) {
            if (this.elements.size === 0) {
                if (this._source) {
                    this._source.removeTexture(this);
                }
            }
            if (v.active) {
                this.decActiveCount();
            }
        }
    }
    getElements() {
        return this.elements;
    }
    incActiveCount() {
        // Ensure that texture source's activeCount has transferred ownership.
        const source = this.source;
        if (source) {
            this._checkForNewerReusableTextureSource();
        }
        this._activeCount++;
        if (this._activeCount === 1) {
            this.becomesUsed();
        }
    }
    decActiveCount() {
        const source = this.getUpdatedSource(); // Force updating the source.
        this._activeCount--;
        if (!this._activeCount) {
            this.becomesUnused();
        }
    }
    becomesUsed() {
        const source = this.getUpdatedSource();
        source === null || source === void 0 ? void 0 : source.incActiveTextureCount();
    }
    onLoad() {
        this.elements.forEach((element) => {
            if (element.active) {
                element.onTextureSourceLoaded();
            }
        });
    }
    _checkForNewerReusableTextureSource() {
        // When this source became unused and cleaned up, it may have disappeared from the reusable texture map.
        // In the meantime another texture may have been generated loaded with the same lookup id.
        // If this is the case, use that one instead to make sure only one active texture source per lookup id exists.
        const source = this.source;
        if (!source.isLoaded()) {
            const reusable = this._getReusableTextureSource();
            if (reusable && reusable.isLoaded() && reusable !== source) {
                this._replaceTextureSource(reusable);
            }
        }
    }
    becomesUnused() {
        if (this.source) {
            this.source.decActiveTextureCount();
        }
    }
    isUsed() {
        return this._activeCount > 0;
    }
    // Returns the lookup id for the current texture settings, to be able to reuse it.
    _getLookupId() {
        // Default: do not reuse texture.
        return undefined;
    }
    /**
     * Generates a loader function that is able to generate the texture for the current settings of this texture.
     * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
     * to stop fetching an image when it is no longer in element, for example.
     */
    _getSourceLoader() {
        throw new Error("Texture.generate must be implemented.");
    }
    get isValid() {
        return this._getIsValid();
    }
    /**
     * If texture is not 'valid', no source can be created for it.
     */
    _getIsValid() {
        return true;
    }
    /**
     * This must be called when the texture source must be re-generated.
     */
    _changed() {
        // If no element is actively using this texture, ignore it altogether.
        if (this.isUsed()) {
            this._updateSource();
        }
        else {
            this._mustUpdate = true;
        }
    }
    _updateSource() {
        // We delay all updateSource calls to the next drawFrame, so that we can bundle them.
        // Otherwise we may reload a texture more often than necessary, when, for example, patching multiple text
        // properties.
        this.stage.addUpdateTexture(this);
    }
    _performUpdateSource(force = false) {
        // If, in the meantime, the texture was no longer used, just remember that it must update until it becomes used
        // again.
        if (force || this.isUsed()) {
            this._mustUpdate = false;
            const source = this._getTextureSource();
            this._replaceTextureSource(source);
        }
    }
    _getTextureSource() {
        let source;
        if (this._getIsValid()) {
            const lookupId = this._getLookupId();
            source = this._getReusableTextureSource(lookupId);
            if (!source) {
                source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
            }
        }
        return source;
    }
    _getReusableTextureSource(lookupId = this._getLookupId()) {
        if (this._getIsValid()) {
            if (lookupId) {
                return this.manager.getReusableTextureSource(lookupId);
            }
        }
        return undefined;
    }
    _replaceTextureSource(newSource) {
        const oldSource = this._source;
        this._source = newSource;
        if (oldSource) {
            if (this._activeCount) {
                oldSource.decActiveTextureCount();
            }
            oldSource.removeTexture(this);
        }
        if (newSource) {
            // Must happen before setDisplayedTexture to ensure sprite map texcoords are used.
            newSource.addTexture(this);
            if (this._activeCount) {
                newSource.incActiveTextureCount();
            }
        }
        if (this.isUsed()) {
            if (newSource) {
                if (newSource.isLoaded()) {
                    this.elements.forEach((element) => {
                        if (element.active) {
                            element.setDisplayedTexture(this);
                        }
                    });
                }
                else {
                    const loadError = newSource.loadError;
                    if (loadError) {
                        this.elements.forEach((element) => {
                            if (element.active) {
                                element.onTextureSourceLoadError(loadError);
                            }
                        });
                    }
                }
            }
            else {
                this.elements.forEach((element) => {
                    if (element.active) {
                        element.setDisplayedTexture(undefined);
                    }
                });
            }
        }
    }
    load() {
        // Make sure that source is up to date.
        if (this.source) {
            if (!this.isLoaded()) {
                this.source.load();
            }
        }
    }
    isLoaded() {
        return this._source ? this._source.isLoaded() : false;
    }
    get loadError() {
        return this._source ? this._source.loadError : undefined;
    }
    free() {
        if (this._source) {
            this._source.free();
        }
    }
    hasClipping() {
        return this.clipping;
    }
    _updateClipping() {
        this.clipping = !!(this._x || this._y || this._w || this._h);
        this.elements.forEach((element) => {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === this) {
                element.onDisplayedTextureClippingChanged();
            }
        });
    }
    _updatePixelRatio() {
        this.elements.forEach((element) => {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === this) {
                element.onPixelRatioChanged();
            }
        });
    }
    getNonDefaults() {
        const nonDefaults = {};
        nonDefaults["type"] = this.constructor.name;
        if (this.x !== 0)
            nonDefaults["x"] = this.x;
        if (this.y !== 0)
            nonDefaults["y"] = this.y;
        if (this.w !== 0)
            nonDefaults["w"] = this.w;
        if (this.h !== 0)
            nonDefaults["h"] = this.h;
        if (this.pixelRatio !== 1)
            nonDefaults["pixelRatio"] = this.pixelRatio;
        return nonDefaults;
    }
    get px() {
        return this._x * this._pixelRatio;
    }
    get py() {
        return this._y * this._pixelRatio;
    }
    get pw() {
        return this._w * this._pixelRatio;
    }
    get ph() {
        return this._h * this._pixelRatio;
    }
    get x() {
        return this._x;
    }
    set x(v) {
        if (this._x !== v) {
            this._x = v;
            this._updateClipping();
        }
    }
    get y() {
        return this._y;
    }
    set y(v) {
        if (this._y !== v) {
            this._y = v;
            this._updateClipping();
        }
    }
    get w() {
        return this._w;
    }
    set w(v) {
        if (this._w !== v) {
            this._w = v;
            this._updateClipping();
        }
    }
    get h() {
        return this._h;
    }
    set h(v) {
        if (this._h !== v) {
            this._h = v;
            this._updateClipping();
        }
    }
    get pixelRatio() {
        return this._pixelRatio;
    }
    set pixelRatio(v) {
        if (this._pixelRatio !== v) {
            this._pixelRatio = v;
            this._updatePixelRatio();
        }
    }
    isAutosizeTexture() {
        return true;
    }
    getRenderWidth() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }
        let w = this._w;
        if (this._source) {
            // Max out to edge of source texture.
            const sourceW = this._source.getRenderWidth() / this._pixelRatio;
            if (w) {
                w = Math.min(sourceW, w);
            }
            else {
                w = sourceW;
            }
            w -= this._x;
        }
        else {
            w = 0;
        }
        return w;
    }
    getRenderHeight() {
        if (!this.isAutosizeTexture()) {
            return 0;
        }
        let h = this._h;
        if (this._source) {
            // Max out to edge of source texture.
            const sourceH = this._source.getRenderHeight() / this._pixelRatio;
            if (h) {
                h = Math.min(sourceH, h);
            }
            else {
                h = sourceH;
            }
            h -= this._y;
        }
        else {
            h = 0;
        }
        return h;
    }
    static getLookupIdFromSettings(obj) {
        if (Array.isArray(obj)) {
            return obj.map((o) => this.getLookupIdFromSettings(o)).join(",");
        }
        else if (Utils_1.Utils.isObjectLiteral(obj)) {
            const parts = [];
            for (const [key, value] of Object.entries(obj)) {
                parts.push(key + "=" + this.getLookupIdFromSettings(value));
            }
            return parts.join("|");
        }
        else if (obj === undefined) {
            return "";
        }
        else {
            return "" + obj;
        }
    }
}
exports.Texture = Texture;
Texture.id = 0;
const Utils_1 = __webpack_require__(7);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(68));
__export(__webpack_require__(17));
__export(__webpack_require__(131));
__export(__webpack_require__(132));
__export(__webpack_require__(133));
__export(__webpack_require__(134));
__export(__webpack_require__(135));
__export(__webpack_require__(57));
__export(__webpack_require__(136));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = __webpack_require__(7);
class ColorUtils {
    static rgb(r, g, b) {
        return (r << 16) + (g << 8) + b + 255 * 16777216;
    }
    static rgba(r, g, b, a) {
        return (r << 16) + (g << 8) + b + ((a * 255) | 0) * 16777216;
    }
    static getRgbString(color) {
        const r = ((color / 65536) | 0) % 256;
        const g = ((color / 256) | 0) % 256;
        const b = color % 256;
        return "rgb(" + r + "," + g + "," + b + ")";
    }
    static getRgbaString(color) {
        const r = ((color / 65536) | 0) % 256;
        const g = ((color / 256) | 0) % 256;
        const b = color % 256;
        const a = ((color / 16777216) | 0) / 255;
        return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(4) + ")";
    }
    static getRgbaStringFromArray(color) {
        const r = Math.floor(color[0] * 255);
        const g = Math.floor(color[1] * 255);
        const b = Math.floor(color[2] * 255);
        const a = Math.floor(color[3] * 255) / 255;
        return "rgba(" + r + "," + g + "," + b + "," + a.toFixed(4) + ")";
    }
    static getRgbaComponentsNormalized(argb) {
        const r = ((argb / 65536) | 0) % 256;
        const g = ((argb / 256) | 0) % 256;
        const b = argb % 256;
        const a = (argb / 16777216) | 0;
        return [r / 255, g / 255, b / 255, a / 255];
    }
    static getRgbComponentsNormalized(argb) {
        const r = ((argb / 65536) | 0) % 256;
        const g = ((argb / 256) | 0) % 256;
        const b = argb % 256;
        return [r / 255, g / 255, b / 255];
    }
    static getRgbaComponents(argb) {
        const r = ((argb / 65536) | 0) % 256;
        const g = ((argb / 256) | 0) % 256;
        const b = argb % 256;
        const a = (argb / 16777216) | 0;
        return [r, g, b, a];
    }
    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xffffffff + v + 1;
        }
        return v;
    }
    static getArgbFromAny(color) {
        if (Utils_1.Utils.isNumber(color))
            return color;
        if (Utils_1.Utils.isString(color))
            return ColorUtils.getArgbFromString(color);
        return 0;
    }
    static getArgbFromString(color) {
        const fromColorName = this.colorNameMap[color.toLowerCase()];
        if (fromColorName !== undefined)
            return fromColorName;
        const fromHex = this.getArgbFromHex(color);
        if (fromHex !== undefined)
            return fromHex;
        const fromRgba = this.getArgbFromRgba(color);
        if (fromRgba !== undefined)
            return fromRgba;
        return 0xffffffff;
    }
    static getArgbFromHex(hex) {
        if (hex.startsWith("#")) {
            return parseInt(hex.slice(1), 16) + 255 * 16777216;
        }
    }
    static getArgbFromRgba(rgba) {
        var _a;
        const matchedRgba = this.rgbaMatcher.exec(rgba);
        if (matchedRgba === null)
            return undefined;
        const red = parseInt(matchedRgba[1]);
        const green = parseInt(matchedRgba[2]);
        const blue = parseInt(matchedRgba[3]);
        const alpha = parseFloat((_a = matchedRgba[4]) !== null && _a !== void 0 ? _a : "1.0");
        return this.rgba(red, green, blue, alpha);
    }
    static mergeColors(c1, c2, p) {
        const r1 = ((c1 / 65536) | 0) % 256;
        const g1 = ((c1 / 256) | 0) % 256;
        const b1 = c1 % 256;
        const a1 = (c1 / 16777216) | 0;
        const r2 = ((c2 / 65536) | 0) % 256;
        const g2 = ((c2 / 256) | 0) % 256;
        const b2 = c2 % 256;
        const a2 = (c2 / 16777216) | 0;
        const r = r1 * p + r2 * (1 - p);
        const g = g1 * p + g2 * (1 - p);
        const b = b1 * p + b2 * (1 - p);
        const a = a1 * p + a2 * (1 - p);
        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    }
    static mergeMultiColors(c, p) {
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        let t = 0;
        const n = c.length;
        for (let i = 0; i < n; i++) {
            const r1 = ((c[i] / 65536) | 0) % 256;
            const g1 = ((c[i] / 256) | 0) % 256;
            const b1 = c[i] % 256;
            const a1 = (c[i] / 16777216) | 0;
            r += r1 * p[i];
            g += g1 * p[i];
            b += b1 * p[i];
            a += a1 * p[i];
            t += p[i];
        }
        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    }
    static mergeMultiColorsEqual(c) {
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        let t = 0;
        const n = c.length;
        for (let i = 0; i < n; i++) {
            const r1 = ((c[i] / 65536) | 0) % 256;
            const g1 = ((c[i] / 256) | 0) % 256;
            const b1 = c[i] % 256;
            const a1 = (c[i] / 16777216) | 0;
            r += r1;
            g += g1;
            b += b1;
            a += a1;
            t += 1.0;
        }
        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    }
    static mergeColorAlpha(c, alpha) {
        const a = (((c / 16777216) | 0) * alpha) | 0;
        return ((((((c >> 16) & 0xff) * a) / 255) & 0xff) +
            ((((c & 0xff00) * a) / 255) & 0xff00) +
            (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
            (a << 24));
    }
}
exports.ColorUtils = ColorUtils;
ColorUtils.rgbaMatcher = new RegExp(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d*\.?\d*))?\)/);
ColorUtils.colorNameMap = {
    aliceblue: 0xfff0f8ff,
    antiquewhite: 0xfffaebd7,
    aqua: 0xff00ffff,
    aquamarine: 0xff7fffd4,
    azure: 0xfff0ffff,
    beige: 0xfff5f5dc,
    bisque: 0xffffe4c4,
    black: 0xff000000,
    blanchedalmond: 0xffffebcd,
    blue: 0xff0000ff,
    blueviolet: 0xff8a2be2,
    brown: 0xffa52a2a,
    burlywood: 0xffdeb887,
    cadetblue: 0xff5f9ea0,
    chartreuse: 0xff7fff00,
    chocolate: 0xffd2691e,
    coral: 0xffff7f50,
    cornflowerblue: 0xff6495ed,
    cornsilk: 0xfffff8dc,
    crimson: 0xffdc143c,
    cyan: 0xff00ffff,
    darkblue: 0xff00008b,
    darkcyan: 0xff008b8b,
    darkgoldenrod: 0xffb8860b,
    darkgray: 0xffa9a9a9,
    darkgreen: 0xff006400,
    darkkhaki: 0xffbdb76b,
    darkmagenta: 0xff8b008b,
    darkolivegreen: 0xff556b2f,
    darkorange: 0xffff8c00,
    darkorchid: 0xff9932cc,
    darkred: 0xff8b0000,
    darksalmon: 0xffe9967a,
    darkseagreen: 0xff8fbc8f,
    darkslateblue: 0xff483d8b,
    darkslategray: 0xff2f4f4f,
    darkturquoise: 0xff00ced1,
    darkviolet: 0xff9400d3,
    deeppink: 0xffff1493,
    deepskyblue: 0xff00bfff,
    dimgray: 0xff696969,
    dodgerblue: 0xff1e90ff,
    firebrick: 0xffb22222,
    floralwhite: 0xfffffaf0,
    forestgreen: 0xff228b22,
    fuchsia: 0xffff00ff,
    gainsboro: 0xffdcdcdc,
    ghostwhite: 0xfff8f8ff,
    gold: 0xffffd700,
    goldenrod: 0xffdaa520,
    gray: 0xff808080,
    green: 0xff008000,
    greenyellow: 0xffadff2f,
    honeydew: 0xfff0fff0,
    hotpink: 0xffff69b4,
    indianred: 0xffcd5c5c,
    indigo: 0xff4b0082,
    ivory: 0xfffffff0,
    khaki: 0xfff0e68c,
    lavender: 0xffe6e6fa,
    lavenderblush: 0xfffff0f5,
    lawngreen: 0xff7cfc00,
    lemonchiffon: 0xfffffacd,
    lightblue: 0xffadd8e6,
    lightcoral: 0xfff08080,
    lightcyan: 0xffe0ffff,
    lightgoldenrodyellow: 0xfffafad2,
    lightgrey: 0xffd3d3d3,
    lightgreen: 0xff90ee90,
    lightpink: 0xffffb6c1,
    lightsalmon: 0xffffa07a,
    lightseagreen: 0xff20b2aa,
    lightskyblue: 0xff87cefa,
    lightslategray: 0xff778899,
    lightsteelblue: 0xffb0c4de,
    lightyellow: 0xffffffe0,
    lime: 0xff00ff00,
    limegreen: 0xff32cd32,
    linen: 0xfffaf0e6,
    magenta: 0xffff00ff,
    maroon: 0xff800000,
    mediumaquamarine: 0xff66cdaa,
    mediumblue: 0xff0000cd,
    mediumorchid: 0xffba55d3,
    mediumpurple: 0xff9370d8,
    mediumseagreen: 0xff3cb371,
    mediumslateblue: 0xff7b68ee,
    mediumspringgreen: 0xff00fa9a,
    mediumturquoise: 0xff48d1cc,
    mediumvioletred: 0xffc71585,
    midnightblue: 0xff191970,
    mintcream: 0xfff5fffa,
    mistyrose: 0xffffe4e1,
    moccasin: 0xffffe4b5,
    navajowhite: 0xffffdead,
    navy: 0xff000080,
    oldlace: 0xfffdf5e6,
    olive: 0xff808000,
    olivedrab: 0xff6b8e23,
    orange: 0xffffa500,
    orangered: 0xffff4500,
    orchid: 0xffda70d6,
    palegoldenrod: 0xffeee8aa,
    palegreen: 0xff98fb98,
    paleturquoise: 0xffafeeee,
    palevioletred: 0xffd87093,
    papayawhip: 0xffffefd5,
    peachpuff: 0xffffdab9,
    peru: 0xffcd853f,
    pink: 0xffffc0cb,
    plum: 0xffdda0dd,
    powderblue: 0xffb0e0e6,
    purple: 0xff800080,
    red: 0xffff0000,
    rosybrown: 0xffbc8f8f,
    royalblue: 0xff4169e1,
    saddlebrown: 0xff8b4513,
    salmon: 0xfffa8072,
    sandybrown: 0xfff4a460,
    seagreen: 0xff2e8b57,
    seashell: 0xfffff5ee,
    sienna: 0xffa0522d,
    silver: 0xffc0c0c0,
    skyblue: 0xff87ceeb,
    slateblue: 0xff6a5acd,
    slategray: 0xff708090,
    snow: 0xfffffafa,
    springgreen: 0xff00ff7f,
    steelblue: 0xff4682b4,
    tan: 0xffd2b48c,
    teal: 0xff008080,
    thistle: 0xffd8bfd8,
    tomato: 0xffff6347,
    turquoise: 0xff40e0d0,
    violet: 0xffee82ee,
    wheat: 0xfff5deb3,
    white: 0xffffffff,
    whitesmoke: 0xfff5f5f5,
    yellow: 0xffffff00,
    yellowgreen: 0xff9acd32,
    darkgrey: 0xffa9a9a9,
    darkslategrey: 0xff2f4f4f,
    dimgrey: 0xff696969,
    grey: 0xff808080,
    lightgray: 0xffd3d3d3,
    lightslategrey: 0xff778899,
    slategrey: 0xff708090,
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tree2d_1 = __webpack_require__(4);
function ensureColor(v) {
    return tree2d_1.ColorUtils.getArgbFromAny(v);
}
exports.ensureColor = ensureColor;
function ensureInt(v) {
    if (typeof v === "number") {
        return v;
    }
    else {
        return parseInt(v) || 0;
    }
}
exports.ensureInt = ensureInt;
function ensureFloat(v) {
    if (typeof v === "number") {
        return v;
    }
    else {
        return parseFloat(v) || 0.0;
    }
}
exports.ensureFloat = ensureFloat;
function ensureBoolean(v) {
    return v !== "false" && !!v;
}
exports.ensureBoolean = ensureBoolean;
function isString(value) {
    return typeof value === "string";
}
exports.isString = isString;
function isNumber(value) {
    return typeof value === "number";
}
exports.isNumber = isNumber;
function parseFloatStrict(value) {
    if (/^([-+])?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value))
        return Number(value);
    return NaN;
}
exports.parseFloatStrict = parseFloatStrict;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const handlers_1 = __webpack_require__(108);
class Patcher {
    static createObject(settings, defaultType, ...cargs) {
        let object;
        if (settings.type) {
            object = new settings.type(...cargs);
        }
        else {
            if (!defaultType) {
                throw new Error("No default type specified");
            }
            object = new defaultType(...cargs);
        }
        this.patchObject(object, settings);
        return object;
    }
    static patchObject(obj, settings) {
        const names = Object.keys(settings);
        for (let i = 0, n = names.length; i < n; i++) {
            const name = names[i];
            const value = settings[name];
            this.patchObjectProperty(obj, name, value);
        }
    }
    static patchObjectProperty(obj, name, value) {
        const handler = this.getHandler(obj, name);
        if (handler) {
            handler.handle(obj, value);
        }
        else {
            this.patchSimpleObjectProperty(obj, name, value);
        }
    }
    static patchSimpleObjectProperty(obj, name, value) {
        if (name !== "type") {
            obj[name] = value;
        }
    }
    static getHandler(obj, prop) {
        return handlers_1.handlers.find((handler) => handler.matches(obj, prop));
    }
}
exports.Patcher = Patcher;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(137));
__export(__webpack_require__(138));
__export(__webpack_require__(139));
__export(__webpack_require__(140));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Shader {
    constructor(context) {
        this.context = context;
        // The (enabled) elements that use this shader.
        this._elements = new Set();
    }
    static getWebGL() {
        return undefined;
    }
    static getC2d() {
        return undefined;
    }
    addElement(elementCore) {
        this._elements.add(elementCore);
    }
    removeElement(elementCore) {
        this._elements.delete(elementCore);
        if (!this._elements) {
            this.cleanup();
        }
    }
    redraw() {
        this._elements.forEach((elementCore) => {
            elementCore.setHasRenderUpdates(2);
        });
    }
    useDefault() {
        // Should return true if this shader is configured (using it's properties) to not have any effect.
        // This may allow the render engine to avoid unnecessary shader program switches or even texture copies.
        return false;
    }
    addEmpty() {
        // Draws this shader even if there are no quads to be added.
        // This is handy for custom shaders.
        return false;
    }
    cleanup() {
        // Called when no more enabled elements have this shader.
    }
}
exports.Shader = Shader;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dShader_1 = __webpack_require__(22);
const ColorUtils_1 = __webpack_require__(10);
class C2dDefaultShader extends C2dShader_1.C2dShader {
    constructor() {
        super(...arguments);
        this._rectangleTexture = this.context.stage.rectangleTexture.getUpdatedSource().nativeTexture;
        this._tintManager = this.context.stage.renderer.tintManager;
    }
    draw(operation, target) {
        const length = operation.length;
        for (let i = 0; i < length; i++) {
            const tx = operation.getTexture(i);
            const elementCore = operation.getElementCore(i);
            const rc = operation.getRenderContext(i);
            const white = operation.getWhite(i);
            const stc = operation.getSimpleTc(i);
            const context = target.context;
            const pixelRatio = this.context.stage.getPixelRatio();
            context.setTransform(rc.ta * pixelRatio, rc.tc * pixelRatio, rc.tb * pixelRatio, rc.td * pixelRatio, rc.px * pixelRatio, rc.py * pixelRatio);
            const rect = tx === this._rectangleTexture;
            const info = { operation, target, index: i, rect };
            if (rect) {
                // Check for gradient.
                if (white) {
                    context.fillStyle = "white";
                }
                else {
                    this._setColorGradient(context, elementCore);
                }
                context.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                context.fillRect(0, 0, elementCore.getLayoutW(), elementCore.getLayoutH());
                this._afterDrawEl(info);
                context.globalAlpha = 1.0;
            }
            else {
                // @todo: set image smoothing based on the texture.
                // @todo: optimize by registering whether identity texcoords are used.
                context.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                // @todo: test if rounding yields better performance.
                // Notice that simple texture coords can be turned on even though vc._ulx etc are not simple, because
                //  we are rendering a render-to-texture (texcoords were stashed). Same is true for 'white' color btw.
                const sourceX = stc ? 0 : elementCore.ulx * tx.w;
                const sourceY = stc ? 0 : elementCore.uly * tx.h;
                const sourceW = (stc ? 1 : elementCore.brx - elementCore.ulx) * tx.w;
                const sourceH = (stc ? 1 : elementCore.bry - elementCore.uly) * tx.h;
                const colorize = !white;
                if (colorize) {
                    // @todo: cache the tint texture for better performance.
                    // Draw to intermediate texture with background color/gradient.
                    // This prevents us from having to create a lot of render texture canvases.
                    // Notice that we don't support (non-rect) gradients, only color tinting for c2d. We'll just take the average color.
                    let color = elementCore.colorUl;
                    if (elementCore.colorUl !== elementCore.colorUr ||
                        elementCore.colorUr !== elementCore.colorBl ||
                        elementCore.colorBr !== elementCore.colorBl) {
                        color = ColorUtils_1.ColorUtils.mergeMultiColorsEqual([
                            elementCore.colorUl,
                            elementCore.colorUr,
                            elementCore.colorBl,
                            elementCore.colorBr,
                        ]);
                    }
                    const alpha = ((color / 16777216) | 0) / 255.0;
                    context.globalAlpha *= alpha;
                    const rgb = color & 0x00ffffff;
                    const tintTexture = this._tintManager.getTintTexture(tx, rgb);
                    // Actually draw result.
                    context.fillStyle = "white";
                    context.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, elementCore.getLayoutW(), elementCore.getLayoutH());
                }
                else {
                    context.fillStyle = "white";
                    context.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, elementCore.getLayoutW(), elementCore.getLayoutH());
                }
                this._afterDrawEl(info);
                context.globalAlpha = 1.0;
            }
        }
    }
    _setColorGradient(context, core, w = core.getLayoutW(), h = core.getLayoutH(), transparency = true) {
        const color = core.colorUl;
        let gradient;
        if (core.colorUl === core.colorUr) {
            if (core.colorBl === core.colorBr) {
                if (core.colorUl === core.colorBl) {
                    // Single color.
                }
                else {
                    // Vertical gradient.
                    gradient = context.createLinearGradient(0, 0, 0, h);
                    if (transparency) {
                        gradient.addColorStop(0, ColorUtils_1.ColorUtils.getRgbaString(core.colorUl));
                        gradient.addColorStop(1, ColorUtils_1.ColorUtils.getRgbaString(core.colorBl));
                    }
                    else {
                        gradient.addColorStop(0, ColorUtils_1.ColorUtils.getRgbString(core.colorUl));
                        gradient.addColorStop(1, ColorUtils_1.ColorUtils.getRgbString(core.colorBl));
                    }
                }
            }
            else {
                // Not supported gradient.
            }
        }
        else {
            if (core.colorUl === core.colorBl && core.colorUr === core.colorBr) {
                // Horizontal gradient.
                gradient = context.createLinearGradient(0, 0, w, 0);
                if (transparency) {
                    gradient.addColorStop(0, ColorUtils_1.ColorUtils.getRgbaString(core.colorUl));
                    gradient.addColorStop(1, ColorUtils_1.ColorUtils.getRgbaString(core.colorBr));
                }
                else {
                    gradient.addColorStop(0, ColorUtils_1.ColorUtils.getRgbString(core.colorUl));
                    gradient.addColorStop(1, ColorUtils_1.ColorUtils.getRgbString(core.colorBr));
                }
            }
        }
        if (gradient) {
            context.fillStyle = gradient;
        }
        else {
            context.fillStyle = transparency ? ColorUtils_1.ColorUtils.getRgbaString(color) : ColorUtils_1.ColorUtils.getRgbString(color);
        }
    }
    _beforeDrawEl(info) {
        // Noop
    }
    _afterDrawEl(info) {
        // Noop
    }
}
exports.C2dDefaultShader = C2dDefaultShader;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Render tree node.
 * Copyright Metrological, 2017
 * Copyright Bas van Meurs, 2020
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ElementCore_1 = __webpack_require__(93);
const ElementChildList_1 = __webpack_require__(47);
const ElementListeners_1 = __webpack_require__(25);
const Utils_1 = __webpack_require__(7);
class Element {
    constructor(stage) {
        this._id = undefined;
        this._ref = undefined;
        // An element is attached if it is a descendant of the stage root.
        this._attached = false;
        // An element is enabled when it is attached and it is visible (worldAlpha > 0).
        this._enabled = false;
        // An element is active when it is enabled and it is within bounds.
        this._active = false;
        this._parent = undefined;
        // The texture that is currently set.
        this._texture = undefined;
        // The currently displayed texture. May differ from this.texture while loading.
        this._displayedTexture = undefined;
        // Contains the child elements.
        this._childList = undefined;
        this.listeners = undefined;
        // Custom data
        this.data = undefined;
        this.stage = stage;
        this._core = new ElementCore_1.ElementCore(this);
    }
    getListeners() {
        if (!this.listeners) {
            this.listeners = new ElementListeners_1.ElementListeners();
        }
        return this.listeners;
    }
    get id() {
        return this._id;
    }
    set id(id) {
        const prevId = this._id;
        this._id = id;
        if (this._attached) {
            if (prevId) {
                this.stage.removeId(prevId, this);
            }
            if (id) {
                this.stage.addId(id, this);
            }
        }
    }
    set ref(ref) {
        if (this._ref !== ref) {
            if (this._ref !== undefined) {
                if (this._parent !== undefined) {
                    this._parent.childList.clearRef(this._ref);
                }
            }
            this._ref = ref;
            if (this._ref) {
                if (this._parent) {
                    this._parent.childList.setRef(this._ref, this);
                }
            }
        }
    }
    get ref() {
        return this._ref;
    }
    get core() {
        return this._core;
    }
    setAsRoot() {
        this._core.setupAsRoot();
        this._updateAttachedFlag();
        this._updateEnabledFlag();
    }
    get isRoot() {
        return this._core.isRoot;
    }
    _setParent(parent) {
        if (this._parent === parent)
            return;
        this._parent = parent;
        this._updateAttachedFlag();
        this._updateEnabledFlag();
        if (this.isRoot && parent) {
            this._throwError("Root should not be added as a child! Results are unspecified!");
        }
    }
    get attached() {
        return this._attached;
    }
    get enabled() {
        return this._enabled;
    }
    get active() {
        return this._active;
    }
    _isAttached() {
        return this._parent ? this._parent._attached : this.isRoot;
    }
    _isEnabled() {
        return this._core.visible && this._core.alpha > 0 && (this._parent ? this._parent._enabled : this.isRoot);
    }
    _isActive() {
        return this._isEnabled() && this.isWithinBoundsMargin();
    }
    _updateAttachedFlag() {
        const newAttached = this._isAttached();
        if (this._attached !== newAttached) {
            this._attached = newAttached;
            if (newAttached) {
                this._onSetup();
            }
            if (this._childList) {
                const children = this._childList.getItems();
                if (children) {
                    const m = children.length;
                    if (m > 0) {
                        for (let i = 0; i < m; i++) {
                            children[i]._updateAttachedFlag();
                        }
                    }
                }
            }
            if (newAttached) {
                this._onAttach();
            }
            else {
                this._onDetach();
            }
        }
    }
    _updateEnabledFlag() {
        const newEnabled = this._isEnabled();
        if (this._enabled !== newEnabled) {
            if (newEnabled) {
                this._onEnabled();
                this._setEnabledFlag();
            }
            else {
                this._onDisabled();
                this._unsetEnabledFlag();
            }
            if (this._childList) {
                const children = this._childList.getItems();
                if (children) {
                    const m = children.length;
                    if (m > 0) {
                        for (let i = 0; i < m; i++) {
                            children[i]._updateEnabledFlag();
                        }
                    }
                }
            }
        }
    }
    _setEnabledFlag() {
        this._enabled = true;
        // Force re-check of texture because dimensions might have changed (cutting).
        this._updateTextureDimensions();
        this.updateTextureCoords();
        if (this._texture) {
            this._texture.addElement(this);
        }
        if (this.isWithinBoundsMargin()) {
            this._setActiveFlag();
        }
        if (this._core.shader) {
            this._core.shader.addElement(this._core);
        }
    }
    _unsetEnabledFlag() {
        if (this._active) {
            this._unsetActiveFlag();
        }
        if (this._texture) {
            this._texture.removeElement(this);
        }
        if (this._core.shader) {
            this._core.shader.removeElement(this._core);
        }
        this._enabled = false;
    }
    _setActiveFlag() {
        this._active = true;
        // This must happen before enabling the texture, because it may already be loaded or load directly.
        if (this._texture) {
            this._texture.incActiveCount();
        }
        if (this._texture) {
            this._enableTexture();
        }
        this._onActive();
    }
    _unsetActiveFlag() {
        if (this._texture) {
            this._texture.decActiveCount();
        }
        this._active = false;
        if (this._texture) {
            this._disableTexture();
        }
        if (this._hasTexturizer()) {
            this.texturizer.deactivate();
        }
        this._onInactive();
    }
    set onSetup(v) {
        this.getListeners().onSetup = v;
    }
    get onSetup() {
        return this.getListeners().onSetup;
    }
    _onSetup() {
        if (this.listeners && this.listeners.onSetup) {
            this.listeners.onSetup({ element: this });
        }
    }
    set onAttach(v) {
        this.getListeners().onAttach = v;
    }
    get onAttach() {
        return this.getListeners().onAttach;
    }
    _onAttach() {
        if (this._id) {
            this.stage.addId(this._id, this);
        }
        if (this.listeners && this.listeners.onAttach) {
            this.listeners.onAttach({ element: this });
        }
    }
    set onDetach(v) {
        this.getListeners().onDetach = v;
    }
    get onDetach() {
        return this.getListeners().onDetach;
    }
    _onDetach() {
        if (this.listeners && this.listeners.onDetach) {
            this.listeners.onDetach({ element: this });
        }
        if (this._id) {
            this.stage.removeId(this._id, this);
        }
    }
    set onEnabled(v) {
        this.getListeners().onEnabled = v;
    }
    get onEnabled() {
        return this.getListeners().onEnabled;
    }
    _onEnabled() {
        if (this.listeners && this.listeners.onEnabled) {
            this.listeners.onEnabled({ element: this });
        }
    }
    set onDisabled(v) {
        this.getListeners().onDisabled = v;
    }
    get onDisabled() {
        return this.getListeners().onDisabled;
    }
    _onDisabled() {
        if (this.listeners && this.listeners.onDisabled) {
            this.listeners.onDisabled({ element: this });
        }
    }
    set onActive(v) {
        this.getListeners().onActive = v;
    }
    get onActive() {
        return this.getListeners().onActive;
    }
    _onActive() {
        if (this.listeners && this.listeners.onActive) {
            this.listeners.onActive({ element: this });
        }
    }
    set onInactive(v) {
        this.getListeners().onInactive = v;
    }
    get onInactive() {
        return this.getListeners().onInactive;
    }
    _onInactive() {
        if (this.listeners && this.listeners.onInactive) {
            this.listeners.onInactive({ element: this });
        }
    }
    set onTextureError(v) {
        this.getListeners().onTextureError = v;
    }
    get onTextureError() {
        return this.getListeners().onTextureError;
    }
    _onTextureError(loadError, texture) {
        if (this.listeners && this.listeners.onTextureError) {
            this.listeners.onTextureError({ element: this, texture, error: loadError });
        }
    }
    set onTextureLoaded(v) {
        this.getListeners().onTextureLoaded = v;
    }
    get onTextureLoaded() {
        return this.getListeners().onTextureLoaded;
    }
    _onTextureLoaded(texture) {
        if (this.listeners && this.listeners.onTextureLoaded) {
            this.listeners.onTextureLoaded({ element: this, texture });
        }
    }
    set onTextureUnloaded(v) {
        this.getListeners().onTextureUnloaded = v;
    }
    get onTextureUnloaded() {
        return this.getListeners().onTextureUnloaded;
    }
    _onTextureUnloaded(texture) {
        if (this.listeners && this.listeners.onTextureUnloaded) {
            this.listeners.onTextureUnloaded({ element: this, texture });
        }
    }
    set onResize(v) {
        this.getListeners().onResize = v;
    }
    get onResize() {
        return this.getListeners().onResize;
    }
    _onResize(w, h) {
        if (this.listeners && this.listeners.onResize) {
            this.listeners.onResize({ element: this, w, h });
        }
    }
    get renderWidth() {
        return this._core.getRenderWidth();
    }
    get renderHeight() {
        return this._core.getRenderHeight();
    }
    get layoutX() {
        return this._core.getLayoutX();
    }
    get layoutY() {
        return this._core.getLayoutY();
    }
    get layoutW() {
        return this._core.getLayoutW();
    }
    get layoutH() {
        return this._core.getLayoutH();
    }
    textureIsLoaded() {
        return this._texture ? this._texture.isLoaded() : false;
    }
    loadTexture() {
        if (this._texture) {
            this._texture.load();
            if (!this._texture.isUsed() || !this._isEnabled()) {
                // As this element is invisible, loading the texture will have no effect on the dimensions of this element.
                // To help the developers, automatically update the dimensions.
                this._updateTextureDimensions();
            }
        }
    }
    _enableTextureError() {
        // txError event should automatically be re-triggered when a element becomes active.
        const loadError = this._texture.loadError;
        if (loadError) {
            this._onTextureError(loadError, this._texture);
        }
    }
    _enableTexture() {
        if (this._texture.isLoaded()) {
            this.setDisplayedTexture(this._texture);
        }
        else {
            // We don't want to retain the old image as it wasn't visible anyway.
            this.setDisplayedTexture(undefined);
            this._enableTextureError();
        }
    }
    _disableTexture() {
        // We disable the displayed texture because, when the texture changes while invisible, we should use that w, h,
        // mw, mh for checking within bounds.
        this.setDisplayedTexture(undefined);
    }
    get texture() {
        return this._texture;
    }
    set texture(v) {
        let texture;
        if (!v) {
            texture = undefined;
        }
        else {
            texture = v;
        }
        const prevTexture = this._texture;
        if (texture !== prevTexture) {
            this._texture = texture;
            if (this._texture) {
                if (this._enabled) {
                    this._texture.addElement(this);
                    if (this.isWithinBoundsMargin()) {
                        if (this._texture.isLoaded()) {
                            this.setDisplayedTexture(this._texture);
                        }
                        else {
                            this._enableTextureError();
                        }
                    }
                }
            }
            else {
                // Make sure that current texture is cleared when the texture is explicitly set to undefined.
                this.setDisplayedTexture(undefined);
            }
            if (prevTexture && prevTexture !== this._displayedTexture) {
                prevTexture.removeElement(this);
            }
            this._updateTextureDimensions();
        }
    }
    get displayedTexture() {
        return this._displayedTexture;
    }
    setDisplayedTexture(v) {
        const prevTexture = this._displayedTexture;
        if (prevTexture && v !== prevTexture) {
            if (this._texture !== prevTexture) {
                // The old displayed texture is deprecated.
                prevTexture.removeElement(this);
            }
        }
        const prevSource = this._core.displayedTextureSource ? this._core.displayedTextureSource : undefined;
        const sourceChanged = (v ? v.getSource() : undefined) !== prevSource;
        this._displayedTexture = v;
        this._updateTextureDimensions();
        if (this._displayedTexture) {
            if (sourceChanged) {
                // We don't need to reference the displayed texture because it was already referenced (this.texture === this.displayedTexture).
                this.updateTextureCoords();
                this._core.setDisplayedTextureSource(this._displayedTexture.getSource());
            }
        }
        else {
            this._core.setDisplayedTextureSource(undefined);
        }
        if (sourceChanged) {
            if (this._displayedTexture) {
                this._onTextureLoaded(this._displayedTexture);
            }
            else if (prevTexture) {
                this._onTextureUnloaded(prevTexture);
            }
        }
    }
    onTextureSourceLoaded() {
        // This function is called when element is enabled, but we only want to set displayed texture for active elements.
        if (this.active) {
            // We may be dealing with a texture reloading, so we must force update.
            this.setDisplayedTexture(this._texture);
        }
    }
    onTextureSourceLoadError(loadError) {
        this._onTextureError(loadError, this._texture);
    }
    forceRenderUpdate() {
        this._core.setHasRenderUpdates(3);
    }
    onDisplayedTextureClippingChanged() {
        this._updateTextureDimensions();
        this.updateTextureCoords();
    }
    onPixelRatioChanged() {
        this._updateTextureDimensions();
    }
    _updateTextureDimensions() {
        let w = 0;
        let h = 0;
        if (this._displayedTexture) {
            w = this._displayedTexture.getRenderWidth();
            h = this._displayedTexture.getRenderHeight();
        }
        else if (this._texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            w = this._texture.getRenderWidth();
            h = this._texture.getRenderHeight();
        }
        let unknownSize = false;
        if (!w || !h) {
            if (!this._displayedTexture && this._texture) {
                // We use a 'max width' replacement instead in the ElementCore calcs.
                // This makes sure that it is able to determine withinBounds.
                w = w || this._texture.mw;
                h = h || this._texture.mh;
                if ((!w || !h) && this._texture.isAutosizeTexture()) {
                    unknownSize = true;
                }
            }
        }
        this._core.setTextureDimensions(w, h, unknownSize);
    }
    updateTextureCoords() {
        if (this.displayedTexture) {
            const displayedTexture = this.displayedTexture;
            const displayedTextureSource = this.displayedTexture.getSource();
            if (displayedTextureSource) {
                let tx1 = 0;
                let ty1 = 0;
                let tx2 = 1.0;
                let ty2 = 1.0;
                if (displayedTexture.hasClipping()) {
                    // Apply texture clipping.
                    const w = displayedTextureSource.getRenderWidth();
                    const h = displayedTextureSource.getRenderHeight();
                    let iw;
                    let ih;
                    let rw;
                    let rh;
                    iw = 1 / w;
                    ih = 1 / h;
                    if (displayedTexture.pw) {
                        rw = displayedTexture.pw * iw;
                    }
                    else {
                        rw = (w - displayedTexture.px) * iw;
                    }
                    if (displayedTexture.ph) {
                        rh = displayedTexture.ph * ih;
                    }
                    else {
                        rh = (h - displayedTexture.py) * ih;
                    }
                    iw *= displayedTexture.px;
                    ih *= displayedTexture.py;
                    tx1 = iw;
                    ty1 = ih;
                    tx2 = tx2 * rw + iw;
                    ty2 = ty2 * rh + ih;
                    tx1 = Math.max(0, tx1);
                    ty1 = Math.max(0, ty1);
                    tx2 = Math.min(1, tx2);
                    ty2 = Math.min(1, ty2);
                }
                this._core.setTextureCoords(tx1, ty1, tx2, ty2);
            }
        }
    }
    getCornerPoints() {
        return this._core.getCornerPoints();
    }
    getByRef(ref) {
        return this.childList.getByRef(ref);
    }
    getLocationString() {
        const i = this._parent ? this._parent.childList.getIndex(this) : "R";
        let str = this._parent ? this._parent.getLocationString() : "";
        if (this.ref) {
            str += ":[" + i + "]" + this.ref;
        }
        else if (this.id) {
            str += ":[" + i + "]#" + this.id;
        }
        else {
            str += ":[" + i + "]";
        }
        return str;
    }
    toString() {
        const obj = this.getSettings();
        return Element.getPrettyString(obj, "");
    }
    static getPrettyString(obj, indent) {
        const children = obj.children;
        delete obj.children;
        // Convert singular json settings object.
        const colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
        let str = JSON.stringify(obj, (k, v) => {
            if (colorKeys.indexOf(k) !== -1) {
                return "COLOR[" + v.toString(16) + "]";
            }
            return v;
        });
        str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");
        if (children) {
            let childStr = "";
            if (Utils_1.Utils.isObjectLiteral(children)) {
                const refs = Object.keys(children);
                childStr = "";
                for (let i = 0, n = refs.length; i < n; i++) {
                    childStr += `\n${indent}  "${refs[i]}":`;
                    delete children[refs[i]].ref;
                    childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                }
                const isEmpty = str === "{}";
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
            }
            else {
                const n = children.length;
                childStr = "[";
                for (let i = 0; i < n; i++) {
                    childStr += Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
                }
                childStr += indent + "]}";
                const isEmpty = str === "{}";
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + '"children":\n' + indent + childStr + "}";
            }
        }
        return str;
    }
    getSettings() {
        const settings = this.getNonDefaults();
        const children = this.childList.getItems();
        if (children) {
            const n = children.length;
            if (n) {
                const childArray = [];
                let missing = false;
                for (let i = 0; i < n; i++) {
                    childArray.push(children[i].getSettings());
                    missing = missing || !children[i].ref;
                }
                if (!missing) {
                    settings.children = {};
                    childArray.forEach((child) => {
                        settings.children[child.ref] = child;
                    });
                }
                else {
                    settings.children = childArray;
                }
            }
        }
        settings.id = this.id;
        return settings;
    }
    getNonDefaults() {
        const settings = {};
        if (this.constructor !== Element) {
            settings.type = this.constructor.name;
        }
        if (this._ref) {
            settings.ref = this._ref;
        }
        if (this.x !== 0)
            settings.x = this.x;
        if (this.y !== 0)
            settings.y = this.y;
        if (this.w !== 0)
            settings.w = this.w;
        if (this.h !== 0)
            settings.h = this.h;
        if (this.scaleX === this.scaleY) {
            if (this.scaleX !== 1)
                settings.scale = this.scaleX;
        }
        else {
            if (this.scaleX !== 1)
                settings.scaleX = this.scaleX;
            if (this.scaleY !== 1)
                settings.scaleY = this.scaleY;
        }
        if (this.pivotX === this.pivotY) {
            if (this.pivotX !== 0.5)
                settings.pivot = this.pivotX;
        }
        else {
            if (this.pivotX !== 0.5)
                settings.pivotX = this.pivotX;
            if (this.pivotY !== 0.5)
                settings.pivotY = this.pivotY;
        }
        if (this.mountX === this.mountY) {
            if (this.mountX !== 0)
                settings.mount = this.mountX;
        }
        else {
            if (this.mountX !== 0)
                settings.mountX = this.mountX;
            if (this.mountY !== 0)
                settings.mountY = this.mountY;
        }
        if (this.alpha !== 1)
            settings.alpha = this.alpha;
        if (!this.visible)
            settings.visible = false;
        if (this.rotation !== 0)
            settings.rotation = this.rotation;
        if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
            if (this.colorUl !== 0xffffffff)
                settings.color = this.colorUl.toString(16);
        }
        else {
            if (this.colorUl !== 0xffffffff)
                settings.colorUl = this.colorUl.toString(16);
            if (this.colorUr !== 0xffffffff)
                settings.colorUr = this.colorUr.toString(16);
            if (this.colorBl !== 0xffffffff)
                settings.colorBl = this.colorBl.toString(16);
            if (this.colorBr !== 0xffffffff)
                settings.colorBr = this.colorBr.toString(16);
        }
        if (this.zIndex)
            settings.zIndex = this.zIndex;
        if (this.forceZIndexContext)
            settings.forceZIndexContext = true;
        if (this.clipping)
            settings.clipping = this.clipping;
        if (!this.clipbox)
            settings.clipbox = this.clipbox;
        if (this._texture) {
            const tnd = this._texture.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.texture = tnd;
            }
        }
        if (this._hasTexturizer()) {
            if (this.texturizer.enabled) {
                settings.renderToTexture = this.texturizer.enabled;
            }
            if (this.texturizer.lazy) {
                settings.renderToTextureLazy = true;
            }
            if (this.texturizer.colorize) {
                settings.colorizeResultTexture = this.texturizer.colorize;
            }
            if (this.texturizer.renderOffscreen) {
                settings.renderOffscreen = this.texturizer.renderOffscreen;
            }
        }
        return settings;
    }
    isWithinBoundsMargin() {
        return this._core.isWithinBoundsMargin();
    }
    _enableWithinBoundsMargin() {
        // Iff enabled, this toggles the active flag.
        if (this._enabled) {
            this._setActiveFlag();
        }
    }
    _disableWithinBoundsMargin() {
        // Iff active, this toggles the active flag.
        if (this._active) {
            this._unsetActiveFlag();
        }
    }
    set boundsMargin(v) {
        if (v === undefined) {
            this._core.boundsMargin = undefined;
        }
        else {
            this._core.boundsMargin = [v, v, v, v];
        }
    }
    get boundsMargin() {
        return this._core.boundsMargin ? this._core.boundsMargin[0] : undefined;
    }
    set boundsMarginLeft(v) {
        if (!this._core.boundsMargin) {
            this._core.boundsMargin = [v, 100, 100, 100];
        }
        else {
            this._core.boundsMargin[0] = v;
        }
    }
    get boundsMarginLeft() {
        return this._core.boundsMargin ? this._core.boundsMargin[0] : 100;
    }
    set boundsMarginTop(v) {
        if (!this._core.boundsMargin) {
            this._core.boundsMargin = [100, v, 100, 100];
        }
        else {
            this._core.boundsMargin[1] = v;
        }
    }
    get boundsMarginTop() {
        return this._core.boundsMargin ? this._core.boundsMargin[1] : 100;
    }
    set boundsMarginRight(v) {
        if (!this._core.boundsMargin) {
            this._core.boundsMargin = [100, 100, v, 100];
        }
        else {
            this._core.boundsMargin[2] = v;
        }
    }
    get boundsMarginRight() {
        return this._core.boundsMargin ? this._core.boundsMargin[2] : 100;
    }
    set boundsMarginBottom(v) {
        if (!this._core.boundsMargin) {
            this._core.boundsMargin = [100, 100, 100, v];
        }
        else {
            this._core.boundsMargin[3] = v;
        }
    }
    get boundsMarginBottom() {
        return this._core.boundsMargin ? this._core.boundsMargin[3] : 100;
    }
    get x() {
        return this._core.x;
    }
    set x(v) {
        this._core.x = v;
    }
    get funcX() {
        return this._core.funcX;
    }
    set funcX(v) {
        this._core.funcX = v;
    }
    get y() {
        return this._core.y;
    }
    set y(v) {
        this._core.y = v;
    }
    get funcY() {
        return this._core.funcY;
    }
    set funcY(v) {
        this._core.funcY = v;
    }
    get w() {
        return this._core.w;
    }
    set w(v) {
        this._core.w = v;
    }
    get funcW() {
        return this._core.funcW;
    }
    set funcW(v) {
        this._core.funcW = v;
    }
    get h() {
        return this._core.h;
    }
    set h(v) {
        this._core.h = v;
    }
    get funcH() {
        return this._core.funcH;
    }
    set funcH(v) {
        this._core.funcH = v;
    }
    get scaleX() {
        return this._core.scaleX;
    }
    set scaleX(v) {
        this._core.scaleX = v;
    }
    get scaleY() {
        return this._core.scaleY;
    }
    set scaleY(v) {
        this._core.scaleY = v;
    }
    get scale() {
        return this._core.scale;
    }
    set scale(v) {
        this._core.scale = v;
    }
    get pivotX() {
        return this._core.pivotX;
    }
    set pivotX(v) {
        this._core.pivotX = v;
    }
    get pivotY() {
        return this._core.pivotY;
    }
    set pivotY(v) {
        this._core.pivotY = v;
    }
    get pivot() {
        return this._core.pivot;
    }
    set pivot(v) {
        this._core.pivot = v;
    }
    get mountX() {
        return this._core.mountX;
    }
    set mountX(v) {
        this._core.mountX = v;
    }
    get mountY() {
        return this._core.mountY;
    }
    set mountY(v) {
        this._core.mountY = v;
    }
    get mount() {
        return this._core.mount;
    }
    set mount(v) {
        this._core.mount = v;
    }
    get rotation() {
        return this._core.rotation;
    }
    set rotation(v) {
        this._core.rotation = v;
    }
    get alpha() {
        return this._core.alpha;
    }
    set alpha(v) {
        this._core.alpha = v;
    }
    get visible() {
        return this._core.visible;
    }
    set visible(v) {
        this._core.visible = v;
    }
    get colorUl() {
        return this._core.colorUl;
    }
    set colorUl(v) {
        this._core.colorUl = v;
    }
    get colorUr() {
        return this._core.colorUr;
    }
    set colorUr(v) {
        this._core.colorUr = v;
    }
    get colorBl() {
        return this._core.colorBl;
    }
    set colorBl(v) {
        this._core.colorBl = v;
    }
    get colorBr() {
        return this._core.colorBr;
    }
    set colorBr(v) {
        this._core.colorBr = v;
    }
    get color() {
        return this._core.colorUl;
    }
    set color(v) {
        if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
            this.colorUl = v;
            this.colorUr = v;
            this.colorBl = v;
            this.colorBr = v;
        }
    }
    get colorTop() {
        return this.colorUl;
    }
    set colorTop(v) {
        if (this.colorUl !== v || this.colorUr !== v) {
            this.colorUl = v;
            this.colorUr = v;
        }
    }
    get colorBottom() {
        return this.colorBl;
    }
    set colorBottom(v) {
        if (this.colorBl !== v || this.colorBr !== v) {
            this.colorBl = v;
            this.colorBr = v;
        }
    }
    get colorLeft() {
        return this.colorUl;
    }
    set colorLeft(v) {
        if (this.colorUl !== v || this.colorBl !== v) {
            this.colorUl = v;
            this.colorBl = v;
        }
    }
    get colorRight() {
        return this.colorUr;
    }
    set colorRight(v) {
        if (this.colorUr !== v || this.colorBr !== v) {
            this.colorUr = v;
            this.colorBr = v;
        }
    }
    get zIndex() {
        return this._core.zIndex;
    }
    set zIndex(v) {
        this._core.zIndex = v;
    }
    get forceZIndexContext() {
        return this._core.forceZIndexContext;
    }
    set forceZIndexContext(v) {
        this._core.forceZIndexContext = v;
    }
    get clipping() {
        return this._core.clipping;
    }
    set clipping(v) {
        this._core.clipping = v;
    }
    get clipbox() {
        return this._core.clipbox;
    }
    set clipbox(v) {
        this._core.clipbox = v;
    }
    get skipInLayout() {
        return this._core.skipInLayout;
    }
    set skipInLayout(v) {
        this._core.skipInLayout = v;
    }
    get childList() {
        if (!this._childList) {
            this._childList = new ElementChildList_1.ElementChildList(this);
        }
        return this._childList;
    }
    hasChildren() {
        return this._childList && this._childList.length > 0;
    }
    get children() {
        return this.childList.getItems();
    }
    set children(items) {
        this.childList.setItems(items);
    }
    get p() {
        return this._parent;
    }
    get parent() {
        return this._parent;
    }
    set mw(v) {
        if (this.texture) {
            this.texture.mw = v;
            this._updateTextureDimensions();
        }
        else {
            this._throwError("Set mw after setting a texture.");
        }
    }
    get mw() {
        return this.texture ? this.texture.mw : 0;
    }
    set mh(v) {
        if (this.texture) {
            this.texture.mh = v;
            this._updateTextureDimensions();
        }
        else {
            this._throwError("Set mh after setting a texture.");
        }
    }
    get mh() {
        return this.texture ? this.texture.mh : 0;
    }
    set onUpdate(f) {
        this._core.onUpdate = f;
    }
    get onUpdate() {
        return this._core.onUpdate;
    }
    set onAfterCalcs(f) {
        this._core.onAfterCalcs = f;
    }
    get onAfterCalcs() {
        return this._core.onAfterCalcs;
    }
    set onAfterUpdate(f) {
        this._core.onAfterUpdate = f;
    }
    get onAfterUpdate() {
        return this._core.onAfterUpdate;
    }
    forceUpdate() {
        // Make sure that the update loop is run.
        this._core._setHasUpdates();
    }
    get shader() {
        return this._core.shader;
    }
    set shader(shader) {
        if (this._enabled && this._core.shader) {
            this._core.shader.removeElement(this._core);
        }
        this._core.shader = shader;
        if (this._enabled && this._core.shader) {
            this._core.shader.addElement(this._core);
        }
    }
    _hasTexturizer() {
        return this._core.hasTexturizer();
    }
    get renderToTexture() {
        return this._hasTexturizer() && this.texturizer.enabled;
    }
    set renderToTexture(v) {
        this.texturizer.enabled = v;
    }
    get renderToTextureLazy() {
        return this._hasTexturizer() && this.texturizer.lazy;
    }
    set renderToTextureLazy(v) {
        this.texturizer.lazy = v;
    }
    get renderToTextureOffscreen() {
        return this._hasTexturizer() && this.texturizer.renderOffscreen;
    }
    set renderToTextureOffscreen(v) {
        this.texturizer.renderOffscreen = v;
    }
    get renderToTextureColorize() {
        return this._hasTexturizer() && this.texturizer.colorize;
    }
    set renderToTextureColorize(v) {
        this.texturizer.colorize = v;
    }
    getTexture() {
        return this.texturizer._getTextureSource();
    }
    get texturizer() {
        return this._core.texturizer;
    }
    _throwError(message) {
        throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
    }
    get _flex() {
        return this._core.layout.flex;
    }
    get _flexItem() {
        return this._core.layout.flexItem;
    }
    set flex(v) {
        this._flex.enabled = v;
    }
    get flex() {
        return this._flex.enabled;
    }
    set flexDirection(v) {
        this._flex.direction = v;
    }
    get flexDirection() {
        return this._flex.direction;
    }
    set flexWrap(v) {
        this._flex.wrap = v;
    }
    get flexWrap() {
        return this._flex.wrap;
    }
    set flexAlignItems(v) {
        this._flex.alignItems = v;
    }
    get flexAlignItems() {
        return this._flex.alignItems;
    }
    set flexJustifyContent(v) {
        this._flex.justifyContent = v;
    }
    get flexJustifyContent() {
        return this._flex.justifyContent;
    }
    set flexAlignContent(v) {
        this._flex.alignContent = v;
    }
    get flexAlignContent() {
        return this._flex.alignContent;
    }
    set flexItem(v) {
        this._flexItem.enabled = v;
    }
    get flexItem() {
        return this._flexItem.enabled;
    }
    set flexGrow(v) {
        this._flexItem.grow = v;
    }
    get flexGrow() {
        return this._flexItem.grow;
    }
    set flexShrink(v) {
        this._flexItem.shrink = v;
    }
    get flexShrink() {
        return this._flexItem.shrink;
    }
    set flexAlignSelf(v) {
        this._flexItem.alignSelf = v;
    }
    get flexAlignSelf() {
        return this._flexItem.alignSelf;
    }
    set padding(v) {
        this._flex.padding = v;
    }
    get padding() {
        return this._flex.padding;
    }
    set paddingLeft(v) {
        this._flex.paddingLeft = v;
    }
    get paddingLeft() {
        return this._flex.paddingLeft;
    }
    set paddingRight(v) {
        this._flex.paddingRight = v;
    }
    get paddingRight() {
        return this._flex.paddingRight;
    }
    set paddingTop(v) {
        this._flex.paddingTop = v;
    }
    get paddingTop() {
        return this._flex.paddingTop;
    }
    set paddingBottom(v) {
        this._flex.paddingBottom = v;
    }
    get paddingBottom() {
        return this._flex.paddingBottom;
    }
    set margin(v) {
        this._flexItem.margin = v;
    }
    get margin() {
        return this._flexItem.margin;
    }
    set marginLeft(v) {
        this._flexItem.marginLeft = v;
    }
    get marginLeft() {
        return this._flexItem.marginLeft;
    }
    set marginRight(v) {
        this._flexItem.marginRight = v;
    }
    get marginRight() {
        return this._flexItem.marginRight;
    }
    set marginTop(v) {
        this._flexItem.marginTop = v;
    }
    get marginTop() {
        return this._flexItem.marginTop;
    }
    set marginBottom(v) {
        this._flexItem.marginBottom = v;
    }
    get marginBottom() {
        return this._flexItem.marginBottom;
    }
    set minWidth(v) {
        this._flexItem.minWidth = v;
    }
    get minWidth() {
        return this._flexItem.minWidth;
    }
    set maxWidth(v) {
        this._flexItem.maxWidth = v;
    }
    get maxWidth() {
        return this._flexItem.maxWidth;
    }
    set minHeight(v) {
        this._flexItem.minHeight = v;
    }
    get minHeight() {
        return this._flexItem.minHeight;
    }
    set maxHeight(v) {
        this._flexItem.maxHeight = v;
    }
    get maxHeight() {
        return this._flexItem.maxHeight;
    }
}
exports.Element = Element;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tree2d_1 = __webpack_require__(4);
const Container_1 = __webpack_require__(6);
class DynamicSizeTexture extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.wrapper = new tree2d_1.Element(this.stage);
        this.background = new tree2d_1.Element(this.stage);
        this.el.childList.add(this.background);
        this.el.childList.add(this.wrapper);
        // Make sure we don't take up space if the el is flex.
        this.background.skipInLayout = true;
        this.wrapper.skipInLayout = true;
        this.wrapper.funcW = (w) => w;
        this.wrapper.funcH = (w, h) => h;
        this.containerElement = this.wrapper;
        this.wrapper.onResize = ({ element, w, h }) => this.handleResize(element, w, h);
        this.background.onTextureLoaded = ({ element, texture }) => this.handleTextureLoaded(element, texture);
        this.background.ref = "background";
    }
    get textureElement() {
        return this.background;
    }
    handleTextureLoaded(element, texture) {
        var _a;
        const renderInfo = (_a = texture.getSource()) === null || _a === void 0 ? void 0 : _a.getRenderInfo();
        this.background.x = -((renderInfo === null || renderInfo === void 0 ? void 0 : renderInfo.offsetX) || 0);
        this.background.y = -((renderInfo === null || renderInfo === void 0 ? void 0 : renderInfo.offsetY) || 0);
    }
}
exports.DynamicSizeTexture = DynamicSizeTexture;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(28);
const tree2d_1 = __webpack_require__(4);
const events_1 = __webpack_require__(29);
const TypeUtils_1 = __webpack_require__(11);
const tree2dEvents_1 = __webpack_require__(130);
class Node extends Base_1.Base {
    constructor(stage, base) {
        super(base || new tree2d_1.Element(stage));
        this._nodeEvents = undefined;
        this.pointerEvents = undefined;
        this.stage = stage;
        if (this.element) {
            this.element.data = this;
        }
    }
    getParentNode() {
        let current = this.parent;
        while (current && !current.el) {
            current = current.parent;
        }
        return current;
    }
    get el() {
        return this.element;
    }
    get id() {
        return this.el.id;
    }
    set id(v) {
        this.el.id = v;
    }
    get "direct-ref"() {
        return this.el.ref;
    }
    set "direct-ref"(v) {
        // The direct ref can be used to reference children in direct containers.
        this.el.ref = v;
    }
    get "pointer-events"() {
        return this.pointerEvents;
    }
    set "pointer-events"(v) {
        this.pointerEvents = v;
    }
    capturePointerEvents() {
        return this.pointerEvents || (this.pointerEvents === undefined && this.getParentCapturePointerEvents());
    }
    getParentCapturePointerEvents() {
        const parentNode = this.getParentNode();
        return parentNode ? parentNode.capturePointerEvents() : true;
    }
    // Returns the element containing the texture. Texture clipping and tinting will be applied to this element.
    get textureElement() {
        return this.element;
    }
    focus() {
        this.stage.eventHelpers.focusManager.setFocus(this);
    }
    dispatchEvent(event) {
        var _a;
        const vueEventType = events_1.eventTranslators[event.type];
        const eventHandler = (_a = this._nodeEvents) === null || _a === void 0 ? void 0 : _a[vueEventType];
        eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler(Object.assign(Object.assign({}, event), { currentTarget: this }));
    }
    /**
     * Dispatches a bubbled event.
     *
     * @param event the event to be dispatched
     * @param ancestorBubble if you want to fake bubble (for example for a mouseleave event) until a certain ancestor, this field should be used.
     * Note that this will also update the target of the event. When setting it to "true", it will effectively bubble all the way down, though updating the target the entire tree.
     */
    dispatchBubbledEvent(event, ancestorBubble = undefined) {
        var _a;
        const vueEventType = events_1.eventTranslators[event.type];
        let currentNode = this;
        while (currentNode !== undefined && currentNode !== ancestorBubble) {
            const eventHandler = (_a = currentNode._nodeEvents) === null || _a === void 0 ? void 0 : _a[vueEventType];
            const newEvent = Object.assign(Object.assign({}, event), { currentTarget: currentNode, target: ancestorBubble !== undefined ? currentNode : event.target });
            eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler(newEvent);
            if (ancestorBubble !== undefined && newEvent.cancelBubble) {
                return;
            }
            currentNode = currentNode.parent;
        }
    }
    // Converts the world (canvas) coordinates to an offset w.r.t. to this Node
    getLocalOffset(worldX, worldY) {
        return this.el.core.convertWorldCoordsToLocal(worldX, worldY);
    }
    get x() {
        return this.el.x;
    }
    set x(v) {
        this.el.x = TypeUtils_1.ensureFloat(v);
    }
    get "func-x"() {
        return this.el.funcX;
    }
    set "func-x"(v) {
        this.el.funcX = ensureRelativeFunction(v);
    }
    get y() {
        return this.el.y;
    }
    set y(v) {
        this.el.y = v;
    }
    get "func-y"() {
        return this.el.funcY;
    }
    set "func-y"(v) {
        this.el.funcY = ensureRelativeFunction(v);
    }
    get w() {
        return this.el.w;
    }
    set w(v) {
        this.el.w = v;
    }
    get "func-w"() {
        return this.el.funcW;
    }
    set "func-w"(v) {
        this.el.funcW = ensureRelativeFunction(v);
    }
    // This can be used to apply properties directly to this node. Can be handy when the setting relies on the stage.
    set "apply-direct"(v) {
        v({ node: this });
    }
    get h() {
        return this.el.h;
    }
    set h(v) {
        this.el.h = v;
    }
    get "func-h"() {
        return this.el.funcH;
    }
    set "func-h"(v) {
        this.el.funcH = ensureRelativeFunction(v);
    }
    get "scale-x"() {
        return this.el.scaleX;
    }
    set "scale-x"(v) {
        this.el.scaleX = TypeUtils_1.ensureFloat(v);
    }
    get "scale-y"() {
        return this.el.scaleY;
    }
    set "scale-y"(v) {
        this.el.scaleY = TypeUtils_1.ensureFloat(v);
    }
    get scale() {
        return this.el.scale;
    }
    set scale(v) {
        this.el.scale = TypeUtils_1.ensureFloat(v);
    }
    get "pivot-x"() {
        return this.el.pivotX;
    }
    set "pivot-x"(v) {
        this.el.pivotX = TypeUtils_1.ensureFloat(v);
    }
    get "pivot-y"() {
        return this.el.pivotY;
    }
    set "pivot-y"(v) {
        this.el.pivotY = TypeUtils_1.ensureFloat(v);
    }
    get pivot() {
        return this.el.pivot;
    }
    set pivot(v) {
        this.el.pivot = TypeUtils_1.ensureFloat(v);
    }
    get "mount-x"() {
        return this.el.mountX;
    }
    set "mount-x"(v) {
        this.el.mountX = TypeUtils_1.ensureFloat(v);
    }
    get "mount-y"() {
        return this.el.mountY;
    }
    set "mount-y"(v) {
        this.el.mountY = TypeUtils_1.ensureFloat(v);
    }
    get mount() {
        return this.el.mount;
    }
    set mount(v) {
        this.el.mount = TypeUtils_1.ensureFloat(v);
    }
    get rotation() {
        return this.el.rotation;
    }
    set rotation(v) {
        this.el.rotation = TypeUtils_1.ensureFloat(v);
    }
    get alpha() {
        return this.el.alpha;
    }
    set alpha(v) {
        this.el.alpha = TypeUtils_1.ensureFloat(v);
    }
    get visible() {
        return this.el.visible;
    }
    set visible(v) {
        this.el.visible = TypeUtils_1.ensureBoolean(v);
    }
    get "color-top-left"() {
        return this.textureElement.colorUl;
    }
    set "color-top-left"(v) {
        this.textureElement.colorUl = TypeUtils_1.ensureColor(v);
    }
    get "color-top-right"() {
        return this.textureElement.colorUr;
    }
    set "color-top-right"(v) {
        this.textureElement.colorUr = TypeUtils_1.ensureColor(v);
    }
    get "color-bottom-left"() {
        return this.textureElement.colorBl;
    }
    set "color-bottom-left"(v) {
        this.textureElement.colorBl = TypeUtils_1.ensureColor(v);
    }
    get "color-bottom-right"() {
        return this.textureElement.colorBr;
    }
    set "color-bottom-right"(v) {
        this.textureElement.colorBr = TypeUtils_1.ensureColor(v);
    }
    get "color-top"() {
        return this.textureElement.colorTop;
    }
    set "color-top"(v) {
        this.textureElement.colorTop = TypeUtils_1.ensureColor(v);
    }
    get "color-bottom"() {
        return this.textureElement.colorBottom;
    }
    set "color-bottom"(v) {
        this.textureElement.colorBottom = TypeUtils_1.ensureColor(v);
    }
    get "color-left"() {
        return this.textureElement.colorLeft;
    }
    set "color-left"(v) {
        this.textureElement.colorLeft = TypeUtils_1.ensureColor(v);
    }
    get "color-right"() {
        return this.textureElement.colorRight;
    }
    set "color-right"(v) {
        this.textureElement.colorRight = TypeUtils_1.ensureColor(v);
    }
    get color() {
        return this.textureElement.color;
    }
    set color(v) {
        this.textureElement.color = TypeUtils_1.ensureColor(v);
    }
    get "clip-x"() {
        var _a;
        return ((_a = this.textureElement.texture) === null || _a === void 0 ? void 0 : _a.x) || 0;
    }
    set "clip-x"(v) {
        if (this.textureElement.texture) {
            this.textureElement.texture.x = v;
        }
    }
    get "clip-y"() {
        var _a;
        return ((_a = this.textureElement.texture) === null || _a === void 0 ? void 0 : _a.y) || 0;
    }
    set "clip-y"(v) {
        if (this.textureElement.texture) {
            this.textureElement.texture.y = v;
        }
    }
    get "clip-w"() {
        var _a;
        return ((_a = this.textureElement.texture) === null || _a === void 0 ? void 0 : _a.w) || 0;
    }
    set "clip-w"(v) {
        if (this.textureElement.texture) {
            this.textureElement.texture.w = v;
        }
    }
    get "clip-h"() {
        var _a;
        return ((_a = this.textureElement.texture) === null || _a === void 0 ? void 0 : _a.h) || 0;
    }
    set "clip-h"(v) {
        if (this.textureElement.texture) {
            this.textureElement.texture.h = v;
        }
    }
    get "pixel-ratio"() {
        var _a;
        return ((_a = this.textureElement.texture) === null || _a === void 0 ? void 0 : _a.pixelRatio) || 1;
    }
    set "pixel-ratio"(v) {
        if (this.textureElement.texture) {
            this.textureElement.texture.pixelRatio = TypeUtils_1.ensureFloat(v);
        }
    }
    get "z-index"() {
        return this.el.zIndex;
    }
    set "z-index"(v) {
        this.el.zIndex = TypeUtils_1.ensureFloat(v);
    }
    get "bounds-margin"() {
        return this.el.boundsMargin;
    }
    set "bounds-margin"(v) {
        this.el.boundsMargin = TypeUtils_1.ensureFloat(v);
    }
    get "bounds-margin-left"() {
        return this.el.boundsMarginLeft;
    }
    set "bounds-margin-left"(v) {
        this.el.boundsMarginLeft = TypeUtils_1.ensureFloat(v);
    }
    get "bounds-margin-top"() {
        return this.el.boundsMarginTop;
    }
    set "bounds-margin-top"(v) {
        this.el.boundsMarginTop = TypeUtils_1.ensureFloat(v);
    }
    get "bounds-margin-right"() {
        return this.el.boundsMarginRight;
    }
    set "bounds-margin-right"(v) {
        this.el.boundsMarginRight = TypeUtils_1.ensureFloat(v);
    }
    get "bounds-margin-bottom"() {
        return this.el.boundsMarginBottom;
    }
    set "bounds-margin-bottom"(v) {
        this.el.boundsMarginBottom = TypeUtils_1.ensureFloat(v);
    }
    get "flex-item"() {
        return this.el.flexItem;
    }
    set "flex-item"(v) {
        this.el.flexItem = TypeUtils_1.ensureBoolean(v);
    }
    get "flex-grow"() {
        return this.el.flexGrow;
    }
    set "flex-grow"(v) {
        this.el.flexGrow = TypeUtils_1.ensureFloat(v);
    }
    get "flex-shrink"() {
        return this.el.flexShrink;
    }
    set "flex-shrink"(v) {
        this.el.flexShrink = TypeUtils_1.ensureFloat(v);
    }
    get "flex-align-self"() {
        return this.el.flexAlignSelf;
    }
    set "flex-align-self"(v) {
        this.el.flexAlignSelf = v;
    }
    get margin() {
        return this.el.margin;
    }
    set margin(v) {
        this.el.margin = TypeUtils_1.ensureFloat(v);
    }
    get "margin-left"() {
        return this.el.marginLeft;
    }
    set "margin-left"(v) {
        this.el.marginLeft = TypeUtils_1.ensureFloat(v);
    }
    get "margin-right"() {
        return this.el.marginRight;
    }
    set "margin-right"(v) {
        this.el.marginRight = TypeUtils_1.ensureFloat(v);
    }
    get "margin-top"() {
        return this.el.marginTop;
    }
    set "margin-top"(v) {
        this.el.marginTop = TypeUtils_1.ensureFloat(v);
    }
    get "margin-bottom"() {
        return this.el.marginBottom;
    }
    set "margin-bottom"(v) {
        this.el.marginBottom = TypeUtils_1.ensureFloat(v);
    }
    get "min-width"() {
        return this.el.minWidth;
    }
    set "min-width"(v) {
        this.el.minWidth = TypeUtils_1.ensureFloat(v);
    }
    get "min-height"() {
        return this.el.minHeight;
    }
    set "min-height"(v) {
        this.el.minHeight = TypeUtils_1.ensureFloat(v);
    }
    get "max-width"() {
        return this.el.maxWidth;
    }
    set "max-width"(v) {
        this.el.maxWidth = TypeUtils_1.ensureFloat(v);
    }
    get "max-height"() {
        return this.el.maxHeight;
    }
    set "max-height"(v) {
        this.el.maxHeight = TypeUtils_1.ensureFloat(v);
    }
    get "skip-in-layout"() {
        return this.el.skipInLayout;
    }
    set "skip-in-layout"(v) {
        this.el.skipInLayout = TypeUtils_1.ensureBoolean(v);
    }
    get nodeEvents() {
        if (!this._nodeEvents) {
            this._nodeEvents = {};
        }
        return this._nodeEvents;
    }
    // Setters for NodeEvents
    set onSetup(v) {
        this.el.onSetup = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onAttach(v) {
        this.el.onAttach = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onDetach(v) {
        this.el.onDetach = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onEnabled(v) {
        this.el.onEnabled = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onDisabled(v) {
        this.el.onDisabled = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onActive(v) {
        this.el.onActive = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onInactive(v) {
        this.el.onInactive = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onTextureError(v) {
        this.el.onTextureError = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onTextureLoaded(v) {
        this.el.onTextureLoaded = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onTextureUnloaded(v) {
        this.el.onTextureUnloaded = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onResize(v) {
        this.el.onResize = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onUpdate(v) {
        this.el.onUpdate = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onAfterCalcs(v) {
        this.el.onAfterCalcs = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    set onAfterUpdate(v) {
        this.el.onAfterUpdate = v ? (e) => v(tree2dEvents_1.augmentTree2dElementEvent(e)) : undefined;
    }
    // MouseEvent
    set onAuxclick(e) {
        this.nodeEvents.onAuxclick = e;
    }
    set onClick(e) {
        this.nodeEvents.onClick = e;
    }
    set onContextmenu(e) {
        this.nodeEvents.onContextmenu = e;
    }
    set onDblclick(e) {
        this.nodeEvents.onDblclick = e;
    }
    set onMousedown(e) {
        this.nodeEvents.onMousedown = e;
    }
    set onMouseenter(e) {
        this.nodeEvents.onMouseenter = e;
    }
    set onMouseleave(e) {
        this.nodeEvents.onMouseleave = e;
    }
    set onMousemove(e) {
        this.nodeEvents.onMousemove = e;
    }
    set onMouseout(e) {
        this.nodeEvents.onMouseout = e;
    }
    set onMouseover(e) {
        this.nodeEvents.onMouseover = e;
    }
    set onMouseup(e) {
        this.nodeEvents.onMouseup = e;
    }
    // TouchEvent
    set onTouchcancel(e) {
        this.nodeEvents.onTouchcancel = e;
    }
    set onTouchend(e) {
        this.nodeEvents.onTouchend = e;
    }
    set onTouchmove(e) {
        this.nodeEvents.onTouchmove = e;
    }
    set onTouchstart(e) {
        this.nodeEvents.onTouchstart = e;
    }
    // FocusEvent
    set onFocusin(e) {
        this.nodeEvents.onFocusin = e;
    }
    set onFocusout(e) {
        this.nodeEvents.onFocusout = e;
    }
    set onFocus(e) {
        this.nodeEvents.onFocus = e;
    }
    set onBlur(e) {
        this.nodeEvents.onBlur = e;
    }
    // KeyboardEvent
    set onKeypress(e) {
        this.nodeEvents.onKeypress = e;
    }
    set onKeydown(e) {
        this.nodeEvents.onKeydown = e;
    }
    set onKeyup(e) {
        this.nodeEvents.onKeyup = e;
    }
    getLayoutX() {
        return this.el.layoutX;
    }
    getLayoutY() {
        return this.el.layoutY;
    }
    getLayoutW() {
        return this.el.layoutW;
    }
    getLayoutH() {
        return this.el.layoutH;
    }
}
exports.Node = Node;
/**
 * Do not proxify Nodes when using template refs.
 * See https://github.com/vuejs/vue-next/pull/1060
 */
Node.prototype["__v_skip"] = true;
function ensureRelativeFunction(v) {
    if (TypeUtils_1.isString(v)) {
        // Convert to function.
        return convertRelativeFunction(v);
    }
    else {
        return v;
    }
}
// We hold a cache because string-based vue properties will otherwise result in a new relative function on every vnode
//  update, with performance implications.
const cachedRelFunctions = new Map();
function convertRelativeFunction(body) {
    let fn = cachedRelFunctions.get(body);
    if (!fn) {
        fn = new Function("w", "h", `return ${body}`);
        cachedRelFunctions.set(body, fn);
    }
    return fn;
}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var compileVugel_1 = __webpack_require__(62);
exports.compileVugel = compileVugel_1.compileVugel;
var wrapper_1 = __webpack_require__(145);
exports.Vugel = wrapper_1.Vugel;
var compile_1 = __webpack_require__(36);
exports.compile = compile_1.compile;
exports.parse = compile_1.parse;
__export(__webpack_require__(21));


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransitionGroup", function() { return TransitionGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createApp", function() { return createApp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSSRApp", function() { return createSSRApp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return hydrate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vModelCheckbox", function() { return vModelCheckbox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vModelDynamic", function() { return vModelDynamic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vModelRadio", function() { return vModelRadio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vModelSelect", function() { return vModelSelect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vModelText", function() { return vModelText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vShow", function() { return vShow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withKeys", function() { return withKeys; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withModifiers", function() { return withModifiers; });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customRef", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["customRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isProxy", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["isProxy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReactive", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["isReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadonly", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["isReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isRef", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["isRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "markRaw", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["markRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "reactive", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["reactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readonly", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["readonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ref", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["ref"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReactive", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["shallowReactive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowReadonly", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["shallowReadonly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowRef", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["shallowRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRaw", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["toRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRef", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["toRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRefs", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["toRefs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "triggerRef", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["triggerRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unref", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["unref"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseTransition", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["BaseTransition"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Comment", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Comment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KeepAlive", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["KeepAlive"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Static", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Static"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Suspense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Teleport", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Teleport"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Text", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callWithAsyncErrorHandling", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["callWithAsyncErrorHandling"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "callWithErrorHandling", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["callWithErrorHandling"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "camelize", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["camelize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["cloneVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computed", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["computed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createBlock", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createCommentVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createCommentVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHydrationRenderer", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createHydrationRenderer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRenderer", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createRenderer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSlots", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createSlots"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStaticVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createStaticVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTextVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createTextVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineAsyncComponent", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["defineAsyncComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineComponent", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["defineComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCurrentInstance", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentInstance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "h", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "handleError", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["handleError"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inject", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["inject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isVNode", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["isVNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeProps", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["mergeProps"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nextTick", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["nextTick"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onActivated", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onActivated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeMount", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onBeforeMount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeUnmount", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onBeforeUnmount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onBeforeUpdate", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onBeforeUpdate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onDeactivated", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onDeactivated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onErrorCaptured", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onErrorCaptured"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onMounted", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onMounted"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onRenderTracked", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onRenderTracked"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onRenderTriggered", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onRenderTriggered"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onUnmounted", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onUnmounted"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "onUpdated", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onUpdated"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "openBlock", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["openBlock"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popScopeId", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["popScopeId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "provide", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["provide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pushScopeId", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["pushScopeId"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "queuePostFlushCb", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["queuePostFlushCb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerRuntimeCompiler", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["registerRuntimeCompiler"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderList", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["renderList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "renderSlot", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["renderSlot"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveComponent", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveDirective", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveDirective"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveDynamicComponent", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveDynamicComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveTransitionHooks", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveTransitionHooks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setBlockTracking", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["setBlockTracking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setTransitionHooks", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["setTransitionHooks"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssrContextKey", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["ssrContextKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ssrUtils", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["ssrUtils"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDisplayString", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["toDisplayString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toHandlers", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["toHandlers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transformVNodeArgs", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["transformVNodeArgs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCSSModule", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["useCSSModule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSSRContext", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["useSSRContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useTransitionState", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["useTransitionState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "warn", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["warn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "watch", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["watch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "watchEffect", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["watchEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withCtx", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["withCtx"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withDirectives", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["withDirectives"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withScopeId", function() { return _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["withScopeId"]; });

/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);




const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
let tempContainer;
let tempSVGContainer;
const nodeOps = {
    insert: (child, parent, anchor) => {
        if (anchor) {
            parent.insertBefore(child, anchor);
        }
        else {
            parent.appendChild(child);
        }
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is) => isSVG
        ? doc.createElementNS(svgNS, tag)
        : doc.createElement(tag, is ? { is } : undefined),
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        return el.cloneNode(true);
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG) {
        const temp = isSVG
            ? tempSVGContainer ||
                (tempSVGContainer = doc.createElementNS(svgNS, 'svg'))
            : tempContainer || (tempContainer = doc.createElement('div'));
        temp.innerHTML = content;
        const first = temp.firstChild;
        let node = first;
        let last = node;
        while (node) {
            last = node;
            nodeOps.insert(node, parent, anchor);
            node = temp.firstChild;
        }
        return [first, last];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    if (value == null) {
        value = '';
    }
    if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        // directly setting className should be faster than setAttribute in theory
        // if this is an element during a transition, take the temporary transition
        // classes into account.
        const transitionClasses = el._vtc;
        if (transitionClasses) {
            value = (value
                ? [value, ...transitionClasses]
                : [...transitionClasses]).join(' ');
        }
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    if (!next) {
        el.removeAttribute('style');
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(next)) {
        style.cssText = next;
    }
    else {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(prev)) {
            for (const key in prev) {
                if (!next[key]) {
                    setStyle(style, key, '');
                }
            }
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if (name.startsWith('--')) {
        // custom property definition
        style.setProperty(name, val);
    }
    else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
            // !important
            style.setProperty(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hyphenate"])(prefixed), val.replace(importantRE, ''), 'important');
        }
        else {
            style[prefixed] = val;
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["camelize"])(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["capitalize"])(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isSpecialBooleanAttr"])(key);
        if (value == null || (isBoolean && value === false)) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}

// __UNSAFE__
// functions. The user is reponsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' && el.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        el.value = value == null ? '' : value;
        return;
    }
    if (value === '' && typeof el[key] === 'boolean') {
        // e.g. <select multiple> compiles to { multiple: '' }
        el[key] = true;
    }
    else if (value == null && typeof el[key] === 'string') {
        // e.g. <div :id="null">
        el[key] = '';
    }
    else {
        // some properties perform value validation and throw
        try {
            el[key] = value;
        }
        catch (e) {
            if ((false)) {}
        }
    }
}

// Async edge case fix requires storing an event listener's attach timestamp.
let _getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res ( relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
if (typeof document !== 'undefined' &&
    _getNow() > document.createEvent('Event').timeStamp) {
    // if the low-res timestamp which is bigger than the event timestamp
    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listeners as well.
    _getNow = () => performance.now();
}
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const name = rawName.slice(2).toLowerCase();
    const prevOptions = prevValue && 'options' in prevValue && prevValue.options;
    const nextOptions = nextValue && 'options' in nextValue && nextValue.options;
    const invoker = prevValue && prevValue.invoker;
    const value = nextValue && 'handler' in nextValue ? nextValue.handler : nextValue;
    if (prevOptions || nextOptions) {
        const prev = prevOptions || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        const next = nextOptions || _vue_shared__WEBPACK_IMPORTED_MODULE_1__["EMPTY_OBJ"];
        if (prev.capture !== next.capture ||
            prev.passive !== next.passive ||
            prev.once !== next.once) {
            if (invoker) {
                removeEventListener(el, name, invoker, prev);
            }
            if (nextValue && value) {
                const invoker = createInvoker(value, instance);
                nextValue.invoker = invoker;
                addEventListener(el, name, invoker, next);
            }
            return;
        }
    }
    if (nextValue && value) {
        if (invoker) {
            prevValue.invoker = null;
            invoker.value = value;
            nextValue.invoker = invoker;
            invoker.lastUpdated = getNow();
        }
        else {
            addEventListener(el, name, createInvoker(value, instance), nextOptions || void 0);
        }
    }
    else if (invoker) {
        removeEventListener(el, name, invoker, prevOptions || void 0);
    }
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        if (e.timeStamp >= invoker.lastUpdated - 1) {
            Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["callWithAsyncErrorHandling"])(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    initialValue.invoker = invoker;
    invoker.lastUpdated = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    switch (key) {
        // special
        case 'class':
            patchClass(el, nextValue, isSVG);
            break;
        case 'style':
            patchStyle(el, prevValue, nextValue);
            break;
        default:
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isOn"])(key)) {
                // ignore v-model listeners
                if (!key.startsWith('onUpdate:')) {
                    patchEvent(el, key, prevValue, nextValue, parentComponent);
                }
            }
            else if (isSVG
                ? // most keys must be set as attribute on svg elements to work
                    // ...except innerHTML
                    key === 'innerHTML' ||
                        // or native onclick with function values
                        (key in el && nativeOnRE.test(key) && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(nextValue))
                : // for normal html elements, set as a property if it exists
                    key in el &&
                        // except native onclick with string values
                        !(nativeOnRE.test(key) && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(nextValue))) {
                patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
            }
            else {
                // special case for <input v-model type="checkbox"> with
                // :true-value & :false-value
                // store value as dom properties since non-string values will be
                // stringified.
                if (key === 'true-value') {
                    el._trueValue = nextValue;
                }
                else if (key === 'false-value') {
                    el._falseValue = nextValue;
                }
                patchAttr(el, key, nextValue, isSVG);
            }
            break;
    }
};

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["h"])(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["BaseTransition"], resolveTransitionProps(props), slots);
const TransitionPropsValidators = (Transition.props = {
    ..._vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["BaseTransition"].props,
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
});
function resolveTransitionProps({ name = 'v', type, css = true, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to`, ...baseProps }) {
    if (!css) {
        return baseProps;
    }
    const originEnterClass = [enterFromClass, enterActiveClass, enterToClass];
    const instance = Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentInstance"])();
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { appear, onBeforeEnter, onEnter, onLeave } = baseProps;
    // is appearing
    if (appear && !instance.isMounted) {
        enterFromClass = appearFromClass;
        enterActiveClass = appearActiveClass;
        enterToClass = appearToClass;
    }
    const finishEnter = (el, done) => {
        removeTransitionClass(el, enterToClass);
        removeTransitionClass(el, enterActiveClass);
        done && done();
        // reset enter class
        if (appear) {
            [enterFromClass, enterActiveClass, enterToClass] = originEnterClass;
        }
    };
    const finishLeave = (el, done) => {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    // only needed for user hooks called in nextFrame
    // sync errors are already handled by BaseTransition
    function callHookWithErrorHandling(hook, args) {
        Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["callWithAsyncErrorHandling"])(hook, instance, 9 /* TRANSITION_HOOK */, args);
    }
    return {
        ...baseProps,
        onBeforeEnter(el) {
            onBeforeEnter && onBeforeEnter(el);
            addTransitionClass(el, enterActiveClass);
            addTransitionClass(el, enterFromClass);
        },
        onEnter(el, done) {
            nextFrame(() => {
                const resolve = () => finishEnter(el, done);
                onEnter && callHookWithErrorHandling(onEnter, [el, resolve]);
                removeTransitionClass(el, enterFromClass);
                addTransitionClass(el, enterToClass);
                if (!(onEnter && onEnter.length > 1)) {
                    if (enterDuration) {
                        setTimeout(resolve, enterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, resolve);
                    }
                }
            });
        },
        onLeave(el, done) {
            addTransitionClass(el, leaveActiveClass);
            addTransitionClass(el, leaveFromClass);
            nextFrame(() => {
                const resolve = () => finishLeave(el, done);
                onLeave && callHookWithErrorHandling(onLeave, [el, resolve]);
                removeTransitionClass(el, leaveFromClass);
                addTransitionClass(el, leaveToClass);
                if (!(onLeave && onLeave.length > 1)) {
                    if (leaveDuration) {
                        setTimeout(resolve, leaveDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, resolve);
                    }
                }
            });
        },
        onEnterCancelled: finishEnter,
        onLeaveCancelled: finishLeave
    };
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isObject"])(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["toNumber"])(val);
    if ((false))
        {}
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["warn"])(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["warn"])(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
function whenTransitionEnds(el, expectedType, cb) {
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return cb();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        cb();
    };
    const onEnd = (e) => {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function toRaw(observed) {
    return (observed && toRaw(observed.__v_raw)) || observed;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    props: {
        ...TransitionPropsValidators,
        tag: String,
        moveClass: String
    },
    setup(props, { slots }) {
        const instance = Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["getCurrentInstance"])();
        const state = Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["useTransitionState"])();
        let prevChildren;
        let children;
        let hasMove = null;
        Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["onUpdated"])(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            // Check if move transition is needed. This check is cached per-instance.
            hasMove =
                hasMove === null
                    ? (hasMove = hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass))
                    : hasMove;
            if (!hasMove) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            const tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Fragment"];
            prevChildren = children;
            const slotChildren = slots.default ? slots.default() : [];
            children = getTransitionRawChildren(slotChildren);
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["setTransitionHooks"])(child, Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveTransitionHooks"])(child, cssTransitionProps, state, instance));
                }
                else if ((false)) {}
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["setTransitionHooks"])(child, Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["resolveTransitionHooks"])(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createVNode"])(tag, null, slotChildren);
        };
    }
};
function getTransitionRawChildren(children) {
    let ret = [];
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // handle fragment children case, e.g. v-for
        if (child.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Fragment"]) {
            ret = ret.concat(getTransitionRawChildren(child.children));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (child.type !== _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["Comment"]) {
            ret.push(child);
        }
    }
    return ret;
}
// remove mode props as TransitionGroup doesn't support it
delete TransitionGroupImpl.props.mode;
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
// this is put in a dedicated function to avoid the line from being treeshaken
function forceReflow() {
    return document.body.offsetHeight;
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1
        ? root
        : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'];
    return Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(fn) ? value => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["invokeArrayFns"])(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        trigger(target, 'input');
    }
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used. These are used by compilers
// only and userland code should avoid relying on them.
/**
 * @internal
 */
const vModelText = {
    beforeMount(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el.value = value;
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || el.type === 'number';
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            else if (castToNumber) {
                domValue = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["toNumber"])(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    beforeUpdate(el, { value, oldValue, modifiers: { trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value === oldValue) {
            return;
        }
        if (document.activeElement === el) {
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["toNumber"])(el.value) === value) {
                return;
            }
        }
        el.value = value;
    }
};
/**
 * @internal
 */
const vModelCheckbox = {
    beforeMount(el, binding, vnode) {
        setChecked(el, binding, vnode);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(modelValue)) {
                const index = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseIndexOf"])(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
        el.checked = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseIndexOf"])(value, vnode.props.value) > -1;
    }
    else if (value !== oldValue) {
        el.checked = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseEqual"])(value, getCheckboxValue(el, true));
    }
}
/**
 * @internal
 */
const vModelRadio = {
    beforeMount(el, { value }, vnode) {
        el.checked = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseEqual"])(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseEqual"])(value, vnode.props.value);
        }
    }
};
/**
 * @internal
 */
const vModelSelect = {
    // use mounted & updated because <select> relies on its children <option>s.
    mounted(el, { value }, vnode) {
        setSelected(el, value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map(getValue);
            el._assign(el.multiple ? selectedVal : selectedVal[0]);
        });
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
        ( false) &&
            false;
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            option.selected = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseIndexOf"])(value, optionValue) > -1;
        }
        else {
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["looseEqual"])(getValue(option), value)) {
                el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
/**
 * @internal
 */
const vModelDynamic = {
    beforeMount(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'beforeMount');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
        case 'SELECT':
            modelToUse = vModelSelect;
            break;
        case 'TEXTAREA':
            modelToUse = vModelText;
            break;
        default:
            switch (el.type) {
                case 'checkbox':
                    modelToUse = vModelCheckbox;
                    break;
                case 'radio':
                    modelToUse = vModelRadio;
                    break;
                default:
                    modelToUse = vModelText;
            }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @internal
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @internal
 */
const withKeys = (fn, modifiers) => {
    return (event) => {
        if (!('key' in event))
            return;
        const eventKey = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["hyphenate"])(event.key);
        if (
        // None of the provided key modifiers match the current event key
        !modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return;
        }
        return fn(event);
    };
};

/**
 * @internal
 */
const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el) {
        setDisplay(el, true);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}

const rendererOptions = {
    patchProp,
    ...nodeOps
};
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return renderer || (renderer = Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createRenderer"])(rendererOptions));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : Object(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__["createHydrationRenderer"])(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((false)) {}
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isFunction"])(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container);
        container.removeAttribute('v-cloak');
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((false)) {}
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isHTMLTag"])(tag) || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isSVGTag"])(tag),
        writable: false
    });
}
function normalizeContainer(container) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_1__["isString"])(container)) {
        const res = document.querySelector(container);
        if (false) {}
        return res;
    }
    return container;
}




/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = __webpack_require__(3);
const nodeOps_1 = __webpack_require__(66);
const patchProp_1 = __webpack_require__(143);
function createRendererForStage(stage) {
    const { render } = runtime_core_1.createRenderer(Object.assign({ patchProp: patchProp_1.patchProp }, nodeOps_1.nodeOps(stage)));
    return render;
}
exports.createRendererForStage = createRendererForStage;
__export(__webpack_require__(144));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(14);
class C2dShader extends Shader_1.Shader {
    beforeDraw(operation, target) {
        // Noop
    }
    draw(operation, target) {
        // Noop
    }
    afterDraw(operation, target) {
        // Noop
    }
}
exports.C2dShader = C2dShader;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLShaderProgram_1 = __webpack_require__(70);
const Shader_1 = __webpack_require__(14);
class WebGLShader extends Shader_1.Shader {
    constructor(context) {
        super(context);
        this.vertexShaderSource = undefined;
        this.fragmentShaderSource = undefined;
        this._initialized = false;
        const stage = context.stage;
        this.gl = stage.gl;
        let program = stage.renderer.getShaderProgram(this.getConstructor());
        if (!program) {
            program = new WebGLShaderProgram_1.WebGLShaderProgram(this.gl, this.constructor.prototype.vertexShaderSource, this.constructor.prototype.fragmentShaderSource);
            // Let the vbo context perform garbage collection.
            stage.renderer.setShaderProgram(this.getConstructor(), program);
        }
        this._program = program;
    }
    getConstructor() {
        return this.constructor;
    }
    get glProgram() {
        return this._program.glProgram;
    }
    _init() {
        if (!this._initialized) {
            this.initialize();
            this._initialized = true;
        }
    }
    initialize() {
        this._program.compile();
    }
    get initialized() {
        return this._initialized;
    }
    _uniform(name) {
        return this._program.getUniformLocation(name);
    }
    _attrib(name) {
        return this._program.getAttribLocation(name);
    }
    _setUniform(name, value, glFunction) {
        this._program.setUniformValue(name, value, glFunction);
    }
    useProgram() {
        this._init();
        this.gl.useProgram(this.glProgram);
        this.beforeUsage();
        this.enableAttribs();
    }
    stopProgram() {
        this.afterUsage();
        this.disableAttribs();
    }
    hasSameProgram(other) {
        // For performance reasons, we first check for identical references.
        return other && (other === this || other._program === this._program);
    }
    beforeUsage() {
        // Override to set settings other than the default settings (blend mode etc).
    }
    afterUsage() {
        // All settings changed in beforeUsage should be reset here.
    }
    enableAttribs() {
        // Noop
    }
    disableAttribs() {
        // Noop
    }
    getExtraAttribBytesPerVertex() {
        return 0;
    }
    getVertexAttribPointerOffset(operation) {
        return operation.extraAttribsDataByteOffset - (operation.index + 1) * 4 * this.getExtraAttribBytesPerVertex();
    }
    setExtraAttribsInBuffer(operation) {
        // Set extra attrib data in in operation.quads.data/floats/uints, starting from
        // operation.extraAttribsBufferByteOffset.
    }
    setupUniforms(operation) {
        // Set all shader-specific uniforms.
        // Notice that all uniforms should be set, even if they have not been changed within this shader instance.
        // The uniforms are shared by all shaders that have the same type (and shader program).
    }
    _getProjection(operation) {
        return operation.getProjection();
    }
    getFlipY(operation) {
        return this._getProjection(operation)[1] < 0;
    }
    beforeDraw(operation) {
        // Noop
    }
    draw(operation) {
        // Noop
    }
    afterDraw(operation) {
        // Noop
    }
    cleanup() {
        this._initialized = false;
        // Program takes little resources, so it is only destroyed when the full stage is destroyed.
    }
}
exports.WebGLShader = WebGLShader;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextureSource {
    constructor(manager, loader) {
        this.manager = manager;
        this.loader = loader;
        this.id = TextureSource.id++;
        // All enabled textures (textures that are used by visible elements).
        this.textures = new Set();
        // The number of active textures (textures that have at least one active element).
        this._activeTextureCount = 0;
        // Reuse identifier.
        this.lookupId = undefined;
        // Loading since timestamp in millis. If set, it is currently loading or loaded. If 0, this is currently not loading.
        this.loadingSince = 0;
        this.w = 0;
        this.h = 0;
        this._nativeTexture = undefined;
        // If true, then this.texture source is never freed from memory during garbage collection.
        this.permanent = false;
        // Texture-specific rendering info.
        this.renderInfo = undefined;
        // Render-to-texture reuse.
        this._isResultTexture = !this.loader;
        // Contains the load error, if the texture source could previously not be loaded.
        this._loadError = undefined;
    }
    get stage() {
        return this.manager.getStage();
    }
    get loadError() {
        return this._loadError;
    }
    getRenderInfo() {
        return this.renderInfo;
    }
    addTexture(v) {
        if (!this.textures.has(v)) {
            this.textures.add(v);
        }
    }
    removeTexture(v) {
        this.textures.delete(v);
    }
    incActiveTextureCount() {
        this._activeTextureCount++;
        if (this._activeTextureCount === 1) {
            this.becomesUsed();
        }
    }
    decActiveTextureCount() {
        this._activeTextureCount--;
        if (this._activeTextureCount === 0) {
            this.becomesUnused();
        }
    }
    get isResultTexture() {
        return this._isResultTexture;
    }
    set isResultTexture(v) {
        this._isResultTexture = v;
    }
    forEachEnabledElement(cb) {
        this.textures.forEach((texture) => {
            texture.getElements().forEach((element) => cb(element));
        });
    }
    hasEnabledElements() {
        return this.textures.size > 0;
    }
    forEachActiveElement(cb) {
        this.textures.forEach((texture) => {
            texture.getElements().forEach((element) => {
                if (element.active) {
                    cb(element);
                }
            });
        });
    }
    getRenderWidth() {
        return this.w;
    }
    getRenderHeight() {
        return this.h;
    }
    allowCleanup() {
        return !this.permanent && !this.isUsed();
    }
    becomesUsed() {
        // Even while the texture is being loaded, make sure it is on the lookup map so that others can reuse it.
        this.load();
    }
    becomesUnused() {
        this.cancel();
    }
    cancel() {
        if (this.isLoading()) {
            if (this._cancelCb) {
                this._cancelCb(this);
                // Clear callback to avoid memory leaks.
                this._cancelCb = undefined;
            }
            this.loadingSince = 0;
        }
    }
    isLoaded() {
        return !!this._nativeTexture;
    }
    isLoading() {
        return this.loadingSince > 0;
    }
    isError() {
        return !!this._loadError;
    }
    reload() {
        this.free();
        if (this.isUsed()) {
            this.load();
        }
    }
    load() {
        // From the moment of loading (when a texture source becomes used by active elements)
        if (this.isResultTexture) {
            // Element result texture source, for which the loading is managed by the core.
            return;
        }
        if (this.loader && !this._nativeTexture && !this.isLoading()) {
            this.loadingSince = new Date().getTime();
            const cancelCb = this.loader((err, options) => {
                // Ignore loads that come in after a cancel.
                if (this.isLoading()) {
                    // Clear callback to avoid memory leaks.
                    this._cancelCb = undefined;
                    if (this.manager.getStage().isDestroyed()) {
                        // Ignore async load when stage is destroyed.
                        return;
                    }
                    if (err) {
                        // Emit txError.
                        this.onError(err);
                    }
                    else if (options && options.source) {
                        this.processLoadedSource(options);
                    }
                }
            }, this);
            this._cancelCb = cancelCb ? cancelCb : undefined;
        }
    }
    processLoadedSource(options) {
        this.loadingSince = 0;
        this.setSource(options);
    }
    setSource(options) {
        const source = options.source;
        this.w = source.width || (options && options.width) || 0;
        this.h = source.height || (options && options.height) || 0;
        if (options && options.renderInfo) {
            // Assign to id in cache so that it can be reused.
            this.renderInfo = options.renderInfo;
        }
        this.permanent = !!options.permanent;
        if (this._isNativeTexture(source)) {
            // Texture managed by caller.
            this._nativeTexture = source;
            this.w = this.w || source.w;
            this.h = this.h || source.h;
            // NativeTexture objects are by default;
            this.permanent = options.permanent === undefined ? false : options.permanent;
        }
        else {
            this.manager.uploadTextureSource(this, options);
        }
        this._loadError = undefined;
        this.onLoad();
    }
    isUsed() {
        return this._activeTextureCount > 0;
    }
    onLoad() {
        if (this.isUsed()) {
            this.textures.forEach((texture) => {
                texture.onLoad();
            });
        }
    }
    forceRenderUpdate() {
        // Userland should call this method after changing the nativeTexture manually outside of the framework
        //  (using tex[Sub]Image2d for example).
        if (this._nativeTexture) {
            // Change 'update' flag. This is currently not used by the framework but is handy in userland.
            this._nativeTexture.updateFrame = this.stage.frameCounter;
        }
        this.forEachActiveElement((element) => {
            element.forceRenderUpdate();
        });
    }
    forceUpdateRenderCoords() {
        this.forEachActiveElement((element) => {
            element.updateTextureCoords();
        });
    }
    get nativeTexture() {
        return this._nativeTexture;
    }
    clearNativeTexture() {
        this._nativeTexture = undefined;
    }
    /**
     * Used for result textures.
     */
    replaceNativeTexture(newNativeTexture, w, h) {
        const prevNativeTexture = this._nativeTexture;
        // Loaded by core.
        this._nativeTexture = newNativeTexture;
        this.w = w;
        this.h = h;
        if (!prevNativeTexture && newNativeTexture) {
            this.forEachActiveElement((element) => element.onTextureSourceLoaded());
        }
        if (!newNativeTexture) {
            this.forEachActiveElement((element) => element.setDisplayedTexture(undefined));
        }
        // Dimensions may be changed.
        this.forEachEnabledElement((element) => element._updateTextureDimensions());
    }
    onError(e) {
        this._loadError = e;
        this.loadingSince = 0;
        console.error("texture load error", e, this.lookupId);
        this.forEachActiveElement((element) => element.onTextureSourceLoadError(e));
    }
    free() {
        if (this.isLoaded()) {
            this.manager.freeTextureSource(this);
        }
    }
    _isNativeTexture(source) {
        // @todo: improve.
        return source instanceof WebGLTexture;
    }
    setNotLoaded() {
        this.loadingSince = 0;
    }
}
exports.TextureSource = TextureSource;
TextureSource.id = 0;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ElementListeners {
    constructor() {
        this.onSetup = undefined;
        this.onAttach = undefined;
        this.onDetach = undefined;
        this.onActive = undefined;
        this.onInactive = undefined;
        this.onEnabled = undefined;
        this.onDisabled = undefined;
        this.onResize = undefined;
        this.onTextureError = undefined;
        this.onTextureLoaded = undefined;
        this.onTextureUnloaded = undefined;
    }
}
exports.ElementListeners = ElementListeners;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Patcher_1 = __webpack_require__(12);
class Handler {
    constructor(sourceType, name) {
        this.sourceType = sourceType;
        this.name = name;
    }
    matches(obj, prop) {
        return this.name === prop && obj instanceof this.sourceType;
    }
    handle(obj, settings) {
        const value = obj[this.name];
        if (!settings) {
            obj[this.name] = undefined;
        }
        else {
            Patcher_1.Patcher.patchObject(value, settings);
        }
    }
}
exports.Handler = Handler;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CoreRenderState {
    constructor(context) {
        this.context = context;
        this.quadOperations = [];
        this.defaultShader = this.context.stage.renderer.getDefaultShader(this.context);
        this.renderer = this.context.stage.renderer;
        this.quadList = this.renderer.createCoreQuadList();
        this.renderTextureInfo = undefined;
        this.shaderOwner = undefined;
        this.specifiedShader = undefined;
        this.usedShader = undefined;
        this.checkForChanges = false;
        this.texturizer = undefined;
        this.pendingQuadOperation = undefined;
        // A list of texturizers that should not to be cached - and pending to be released.
        this.temporaryTexturizers = [];
        this.isCachingTexturizer = false;
        this.useTexturizerCache = false;
    }
    reset() {
        this.renderTextureInfo = undefined;
        this.scissor = undefined;
        this.usedShader = undefined;
        this.shaderOwner = undefined;
        this.specifiedShader = undefined;
        this.checkForChanges = false;
        this.quadOperations = [];
        this.texturizer = undefined;
        this.pendingQuadOperation = undefined;
        this.quadList.reset();
        this.temporaryTexturizers = [];
        this.isCachingTexturizer = false;
        this.useTexturizerCache = false;
    }
    get length() {
        return this.quadList.length;
    }
    setShader(shader, owner) {
        if (this.shaderOwner !== owner || this.specifiedShader !== shader) {
            // Same shader owner: active shader is also the same.
            // Prevent any shader usage to save performance.
            this.specifiedShader = shader;
            if (shader.useDefault()) {
                // Use the default shader when possible to prevent unnecessary program changes.
                shader = this.defaultShader;
            }
            if (this.usedShader !== shader || this.shaderOwner !== owner) {
                this.usedShader = shader;
                this.shaderOwner = owner;
                this.checkForChanges = true;
            }
        }
    }
    setScissor(area) {
        if (this.scissor !== area) {
            this.scissor = area;
            this.checkForChanges = true;
        }
    }
    getScissor() {
        return this.scissor;
    }
    setRenderTextureInfo(renderTextureInfo) {
        if (this.renderTextureInfo !== renderTextureInfo) {
            this.renderTextureInfo = renderTextureInfo;
            this.scissor = undefined;
            this.checkForChanges = true;
        }
    }
    // Sets the texturizer to be drawn during subsequent addQuads.
    setTexturizer(texturizer, cache) {
        this.texturizer = texturizer;
        this.useTexturizerCache = cache;
    }
    addElementCore(elementCore) {
        if (!this.pendingQuadOperation) {
            this._createQuadOperation();
        }
        else if (this.checkForChanges && this._hasChanges()) {
            this._finishQuadOperation();
            this.checkForChanges = false;
        }
        let nativeTexture;
        if (this.texturizer) {
            nativeTexture = this.texturizer.getResultTexture();
            if (!this.useTexturizerCache) {
                // We can release the temporary texture immediately after finalizing this quad operation.
                this.temporaryTexturizers.push(this.texturizer);
            }
        }
        if (!nativeTexture) {
            nativeTexture = elementCore.displayedTextureSource.nativeTexture;
        }
        if (this.renderTextureInfo) {
            if (this.usedShader === this.defaultShader && this.renderTextureInfo.empty) {
                // The texture might be reusable under some conditions. We will check the conditions later.
                this.renderTextureInfo.reusableTexture = nativeTexture;
                this.renderTextureInfo.reusableRenderStateOffset = this.length;
            }
            else {
                // It is not possible to reuse another texture when there is more than one quad.
                this.renderTextureInfo.reusableTexture = undefined;
            }
            this.renderTextureInfo.empty = false;
        }
        this.pendingQuadOperation.length++;
        this.addQuad(nativeTexture, elementCore);
    }
    finishedRenderTexture() {
        if (this.renderTextureInfo && this.renderTextureInfo.reusableTexture) {
            // There was only one texture drawn in this render texture.
            // Check if we can reuse it so that we can optimize out an unnecessary render texture operation.
            // (it should exactly span this render texture).
            if (!this._isRenderTextureReusable()) {
                this.renderTextureInfo.reusableTexture = undefined;
            }
        }
    }
    _isRenderTextureReusable() {
        const renderTextureInfo = this.renderTextureInfo;
        const offset = renderTextureInfo.reusableRenderStateOffset;
        const texture = this.quadList.getTexture(offset);
        return (texture.w === renderTextureInfo.w &&
            texture.h === renderTextureInfo.h &&
            this.isRenderTextureReusable(renderTextureInfo));
    }
    _hasChanges() {
        const q = this.pendingQuadOperation;
        if (this.usedShader !== q.shader)
            return true;
        if (this.shaderOwner !== q.shaderOwner)
            return true;
        if (this.renderTextureInfo !== q.renderTextureInfo)
            return true;
        if (!CoreRenderState.scissorsEqual(this.scissor, q.scissor))
            return true;
        return false;
    }
    static scissorsEqual(a, b) {
        return !(a !== b || !a || !b || a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] || a[3] !== b[3]);
    }
    _finishQuadOperation(create = true) {
        if (this.pendingQuadOperation) {
            if (this.pendingQuadOperation.length || (this.usedShader && this.usedShader.addEmpty())) {
                if (!this.pendingQuadOperation.scissor ||
                    (this.pendingQuadOperation.scissor[2] > 0 && this.pendingQuadOperation.scissor[3] > 0)) {
                    // Ignore empty clipping regions.
                    this.quadOperations.push(this.pendingQuadOperation);
                }
            }
            if (this.temporaryTexturizers.length) {
                for (let i = 0, n = this.temporaryTexturizers.length; i < n; i++) {
                    // We can now reuse these render-to-textures in subsequent stages.
                    // Huge performance benefit when filtering (fast blur).
                    this.temporaryTexturizers[i].releaseRenderTexture();
                }
                this.temporaryTexturizers = [];
            }
            this.pendingQuadOperation = undefined;
        }
        if (create) {
            this._createQuadOperation();
        }
    }
    _createQuadOperation() {
        this.pendingQuadOperation = this.renderer.createCoreQuadOperation(this.context, this.usedShader, this.shaderOwner, this.renderTextureInfo, this.scissor, this.length);
        this.checkForChanges = false;
    }
    finish() {
        if (this.pendingQuadOperation) {
            // Add remaining.
            this._finishQuadOperation(false);
        }
        this.finishRenderState();
    }
}
exports.CoreRenderState = CoreRenderState;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = __webpack_require__(2);
class Base {
    constructor(element) {
        this.element = undefined;
        this.children = new Set();
        this.parent = undefined;
        this.firstChild = null;
        this.lastChild = null;
        this.prevSibling = null;
        this.nextSibling = null;
        this.mustSync = false;
        this.element = element;
    }
    _appendChild(child) {
        child.unlinkSiblings();
        child.parent = this;
        this.children.add(child);
        if (!this.firstChild) {
            this.firstChild = child;
        }
        child.prevSibling = this.lastChild;
        child.nextSibling = null;
        if (this.lastChild) {
            this.lastChild.nextSibling = child;
        }
        this.lastChild = child;
        this.registerSync();
    }
    unlinkSiblings() {
        var _a, _b;
        if (((_a = this.parent) === null || _a === void 0 ? void 0 : _a.firstChild) === this) {
            this.parent.firstChild = this.nextSibling;
        }
        if (((_b = this.parent) === null || _b === void 0 ? void 0 : _b.lastChild) === this) {
            this.parent.lastChild = this.prevSibling;
        }
        if (this.prevSibling) {
            this.prevSibling.nextSibling = this.nextSibling;
        }
        if (this.nextSibling) {
            this.nextSibling.prevSibling = this.prevSibling;
        }
        this.prevSibling = null;
        this.nextSibling = null;
    }
    _removeChild(child) {
        child.unlinkSiblings();
        child.parent = undefined;
        this.children.delete(child);
        this.registerSync();
    }
    _insertBefore(child, anchor) {
        child.unlinkSiblings();
        child.parent = this;
        if (anchor.prevSibling) {
            child.prevSibling = anchor.prevSibling;
            anchor.prevSibling.nextSibling = child;
        }
        anchor.prevSibling = child;
        child.nextSibling = anchor;
        if (this.firstChild === anchor) {
            this.firstChild = child;
        }
        this.children.add(child);
        this.registerSync();
    }
    registerSync() {
        if (!this.mustSync) {
            this.mustSync = true;
            registerUpdatedBase(this);
        }
    }
    syncWithTree2d() {
        // Ignore.
        this.mustSync = false;
    }
    setElementText(text) {
        // Default: ignore text.
    }
}
exports.Base = Base;
let pendingSyncBase = undefined;
const registerUpdatedBase = (base) => {
    if (pendingSyncBase && pendingSyncBase !== base) {
        pendingSyncBase.syncWithTree2d();
    }
    if (!pendingSyncBase) {
        vue_1.queuePostFlushCb(() => {
            flushChanges();
        });
    }
    pendingSyncBase = base;
};
const flushChanges = () => {
    if (pendingSyncBase) {
        pendingSyncBase.syncWithTree2d();
    }
    pendingSyncBase = undefined;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const mouseEvents_1 = __webpack_require__(30);
const touchEvents_1 = __webpack_require__(32);
const focusEvents_1 = __webpack_require__(33);
const keyboardEvents_1 = __webpack_require__(34);
exports.setupEvents = (targetElement, stage) => {
    mouseEvents_1.setupMouseEvents(targetElement, stage);
    touchEvents_1.setupTouchEvents(targetElement, stage);
    const focusManager = focusEvents_1.setupFocusEvents(targetElement, stage);
    keyboardEvents_1.setupKeyboardEvents(targetElement, stage);
    return { focusManager };
};
__export(__webpack_require__(129));
__export(__webpack_require__(30));
__export(__webpack_require__(32));
__export(__webpack_require__(33));
__export(__webpack_require__(34));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(31);
const translateEvent = (stage, e) => {
    var _a, _b;
    const { currentElement, canvasOffsetX, canvasOffsetY } = utils_1.getCurrentContext(e, stage);
    const currentNode = currentElement === null || currentElement === void 0 ? void 0 : currentElement.element.data;
    return {
        cancelBubble: false,
        // Event
        type: e.type,
        currentTarget: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        target: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        // MouseEvent
        canvasOffsetX: canvasOffsetX,
        canvasOffsetY: canvasOffsetY,
        elementOffsetX: (_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetX) !== null && _a !== void 0 ? _a : 0,
        elementOffsetY: (_b = currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetY) !== null && _b !== void 0 ? _b : 0,
        currentElement: currentElement,
        originalEvent: e,
    };
};
// https://www.w3.org/TR/uievents/#events-mouse-types
const dispatchMouseEvent = (stage, eventState) => {
    return (e) => {
        const translatedEvent = translateEvent(stage, e);
        exports.dispatchVugelMouseEvent(translatedEvent, eventState);
        // Prevent selecting nearby text when double-clicking on the canvas.
        e.preventDefault();
    };
};
exports.dispatchVugelMouseEvent = (translatedEvent, eventState) => {
    var _a;
    const prevNode = eventState.activeNode;
    const currentNode = (_a = translatedEvent.currentElement) === null || _a === void 0 ? void 0 : _a.element.data;
    switch (translatedEvent.type) {
        case "auxclick":
        case "click":
        case "contextmenu":
        case "dblclick":
        case "mousedown":
        case "mouseup": {
            currentNode === null || currentNode === void 0 ? void 0 : currentNode.dispatchBubbledEvent(translatedEvent);
            break;
        }
        case "mouseenter": {
            eventState.activeNode = undefined;
            if (currentNode) {
                eventState.activeNode = currentNode;
                currentNode.dispatchBubbledEvent(translatedEvent, true);
            }
            break;
        }
        case "mouseover": {
            eventState.activeNode = undefined;
            if (currentNode) {
                eventState.activeNode = currentNode;
                currentNode === null || currentNode === void 0 ? void 0 : currentNode.dispatchBubbledEvent(translatedEvent);
            }
            break;
        }
        case "mouseleave": {
            prevNode === null || prevNode === void 0 ? void 0 : prevNode.dispatchBubbledEvent(translatedEvent, true);
            break;
        }
        case "mouseout": {
            prevNode === null || prevNode === void 0 ? void 0 : prevNode.dispatchBubbledEvent(Object.assign(Object.assign({}, translatedEvent), { target: prevNode }));
            break;
        }
        case "mousemove": {
            if (currentNode !== undefined && prevNode != currentNode) {
                const commonAncestor = utils_1.getCommonAncestor(prevNode, currentNode);
                prevNode === null || prevNode === void 0 ? void 0 : prevNode.dispatchBubbledEvent(Object.assign(Object.assign({}, translatedEvent), { type: "mouseout", target: prevNode }));
                prevNode === null || prevNode === void 0 ? void 0 : prevNode.dispatchBubbledEvent(Object.assign(Object.assign({}, translatedEvent), { type: "mouseleave", target: prevNode }), commonAncestor);
                currentNode.dispatchBubbledEvent(Object.assign(Object.assign({}, translatedEvent), { type: "mouseover" }));
                currentNode.dispatchBubbledEvent(Object.assign(Object.assign({}, translatedEvent), { type: "mouseenter" }), commonAncestor);
            }
            // Mousemove
            currentNode === null || currentNode === void 0 ? void 0 : currentNode.dispatchBubbledEvent(translatedEvent);
            eventState.activeNode = currentNode;
        }
    }
};
exports.mouseEventTranslator = {
    auxclick: "onAuxclick",
    click: "onClick",
    contextmenu: "onContextmenu",
    dblclick: "onDblclick",
    mousedown: "onMousedown",
    mouseenter: "onMouseenter",
    mouseleave: "onMouseleave",
    mousemove: "onMousemove",
    mouseout: "onMouseout",
    mouseover: "onMouseover",
    mouseup: "onMouseup",
};
exports.setupMouseEvents = (targetElement, stage) => {
    const eventState = {};
    for (const key in exports.mouseEventTranslator) {
        targetElement.addEventListener(key, dispatchMouseEvent(stage, eventState));
    }
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getCanvasOffset(e, stage) {
    const rect = stage.getCanvas().getBoundingClientRect();
    return { x: e.pageX - (rect.left + window.scrollX), y: e.pageY - (rect.top + window.scrollY) };
}
exports.getCanvasOffset = getCanvasOffset;
function getCurrentContext(e, stage) {
    const { x: canvasX, y: canvasY } = getCanvasOffset(e, stage);
    const elementsAtCanvasCoordinates = stage.getElementsAtCoordinates(canvasX, canvasY);
    return {
        currentElement: elementsAtCanvasCoordinates.find((v) => { var _a; return (_a = v.element.data) === null || _a === void 0 ? void 0 : _a.capturePointerEvents(); }),
        canvasOffsetX: canvasX,
        canvasOffsetY: canvasY,
    };
}
exports.getCurrentContext = getCurrentContext;
function getAncestors(node) {
    const path = [];
    let n = node;
    do {
        path.push(n);
        n = n.parent;
    } while (n !== undefined);
    return path.reverse();
}
exports.getAncestors = getAncestors;
function getCommonAncestor(node1, node2) {
    if (!node1 || !node2) {
        return undefined;
    }
    const pathNode1 = getAncestors(node1);
    const pathNode2 = getAncestors(node2);
    const m = Math.min(pathNode1.length, pathNode2.length);
    let index;
    for (index = 0; index < m; index++) {
        if (pathNode1[index] !== pathNode2[index]) {
            break;
        }
    }
    return index > 0 ? pathNode1[index - 1] : undefined;
}
exports.getCommonAncestor = getCommonAncestor;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = __webpack_require__(29);
const utils_1 = __webpack_require__(31);
const translateEvent = (stage, e) => {
    var _a, _b;
    let currentTouch;
    const eventType = e.type;
    if (eventType === "touchend" || eventType === "touchcancel") {
        currentTouch = e.changedTouches[0];
    }
    else {
        currentTouch = e.touches[0];
    }
    const { currentElement, canvasOffsetX, canvasOffsetY } = utils_1.getCurrentContext(currentTouch, stage);
    const currentNode = currentElement === null || currentElement === void 0 ? void 0 : currentElement.element.data;
    return {
        cancelBubble: false,
        // Event
        type: e.type,
        currentTarget: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        target: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        // MouseEvent
        canvasOffsetX: canvasOffsetX,
        canvasOffsetY: canvasOffsetY,
        elementOffsetX: (_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetX) !== null && _a !== void 0 ? _a : 0,
        elementOffsetY: (_b = currentElement === null || currentElement === void 0 ? void 0 : currentElement.offsetY) !== null && _b !== void 0 ? _b : 0,
        originalEvent: e,
        currentElement: currentElement,
    };
};
// https://www.w3.org/TR/touch-events/#list-of-touchevent-types
const dispatchTouchEvent = (stage, eventState) => {
    return (e) => {
        const translatedEvent = translateEvent(stage, e);
        let correspondingMouseEvent;
        switch (e.type) {
            case "touchstart":
                correspondingMouseEvent = "mousedown";
                break;
            case "touchend":
            case "touchcancel":
                correspondingMouseEvent = "mouseup";
                break;
            case "touchmove":
                correspondingMouseEvent = "mousemove";
                break;
        }
        const translatedMouseEvent = Object.assign(Object.assign({}, translatedEvent), { type: correspondingMouseEvent, currentElement: translatedEvent.currentElement });
        index_1.dispatchVugelMouseEvent(translatedMouseEvent, eventState);
    };
};
exports.touchEventTranslator = {
    touchcancel: "onTouchcancel",
    touchend: "onTouchend",
    touchmove: "onTouchmove",
    touchstart: "onTouchstart",
};
exports.setupTouchEvents = (targetElement, stage) => {
    const eventState = {};
    for (const key in exports.touchEventTranslator) {
        targetElement.addEventListener(key, dispatchTouchEvent(stage, eventState));
    }
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = __webpack_require__(31);
class FocusEvents {
    constructor(targetElement, stage) {
        this.targetElement = targetElement;
        this.stage = stage;
        this.focusedNode = undefined;
        this.updatingFocusPath = false;
        this.ensureCanvasFocusable();
        this.targetElement.addEventListener("click", (e) => this.onCanvasClick(e));
        this.targetElement.addEventListener("blur", (e) => this.onCanvasBlur(e));
    }
    getFocusedNode() {
        return this.focusedNode;
    }
    ensureCanvasFocusable() {
        if (!this.targetElement.hasAttribute("tabindex")) {
            this.targetElement.setAttribute("tabindex", "-1");
        }
    }
    onCanvasClick(e) {
        // Automatically focus on clicked elements.
        const { currentElement } = utils_1.getCurrentContext(e, this.stage);
        const node = currentElement === null || currentElement === void 0 ? void 0 : currentElement.element.data;
        this.setFocus(node);
    }
    onCanvasBlur(e) {
        this.setFocus(undefined);
    }
    setFocus(focused) {
        if (this.updatingFocusPath) {
            console.warn("It's not allowed to focus from within a focus-related event. Use setInterval to schedule a focus change.");
        }
        else if (this.focusedNode !== focused) {
            this.updateFocusPath(focused);
        }
    }
    updateFocusPath(newFocusedNode) {
        this.updatingFocusPath = true;
        const prevFocusedNode = this.focusedNode;
        const commonAncestor = utils_1.getCommonAncestor(this.focusedNode, newFocusedNode);
        this.focusedNode = newFocusedNode;
        // Use event order as specified in https://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
        if (prevFocusedNode) {
            prevFocusedNode.dispatchBubbledEvent(this.createFocusEvent("focusout", prevFocusedNode, newFocusedNode), commonAncestor);
        }
        if (newFocusedNode) {
            newFocusedNode.dispatchBubbledEvent(this.createFocusEvent("focusin", newFocusedNode, prevFocusedNode), commonAncestor);
        }
        if (prevFocusedNode) {
            prevFocusedNode.dispatchEvent(this.createFocusEvent("blur", prevFocusedNode, newFocusedNode));
        }
        if (newFocusedNode) {
            newFocusedNode.dispatchEvent(this.createFocusEvent("focus", newFocusedNode, prevFocusedNode));
        }
        this.updatingFocusPath = false;
    }
    createFocusEvent(type, target, relatedTarget) {
        return {
            cancelBubble: false,
            // Event
            type,
            relatedTarget: relatedTarget !== null && relatedTarget !== void 0 ? relatedTarget : null,
            target: target !== null && target !== void 0 ? target : null,
            currentTarget: null,
            originalEvent: undefined,
        };
    }
}
exports.FocusEvents = FocusEvents;
exports.focusEventTranslator = {
    focusin: "onFocusin",
    focusout: "onFocusout",
    focus: "onFocus",
    blur: "onBlur",
};
exports.setupFocusEvents = (targetElement, stage) => {
    return new FocusEvents(targetElement, stage);
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const translateEvent = (stage, e) => {
    let currentNode = stage.eventHelpers.focusManager.getFocusedNode();
    if (!currentNode) {
        currentNode = stage.root.data;
    }
    return {
        cancelBubble: false,
        // Event
        type: e.type,
        currentTarget: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        target: currentNode !== null && currentNode !== void 0 ? currentNode : null,
        originalEvent: e,
    };
};
// https://www.w3.org/TR/uievents/#events-keyboardevents
const dispatchKeyboardEvent = (stage) => {
    return (e) => {
        const translatedEvent = translateEvent(stage, e);
        if (translatedEvent) {
            exports.dispatchVugelKeyboardEvent(translatedEvent);
        }
    };
};
exports.dispatchVugelKeyboardEvent = (translatedEvent) => {
    var _a;
    (_a = translatedEvent.target) === null || _a === void 0 ? void 0 : _a.dispatchBubbledEvent(translatedEvent);
};
exports.keyboardEventTranslator = {
    keypress: "onKeypress",
    keydown: "onKeydown",
    keyup: "onKeyup",
};
exports.setupKeyboardEvents = (targetElement, stage) => {
    for (const key in exports.keyboardEventTranslator) {
        targetElement.addEventListener(key, dispatchKeyboardEvent(stage));
    }
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
const mixin_1 = __webpack_require__(60);
const direct_1 = __webpack_require__(61);
/**
 * Allows direct child mutations.
 * Disables vue vdom patching.
 */
class DirectContainer extends Container_1.Container {
    create(nodeType) {
        const directType = direct_1.getDirectType(nodeType);
        return new directType(this.stage);
    }
}
exports.DirectContainer = DirectContainer;
mixin_1.mixin(DirectContainer, direct_1.DirectContainerMixin);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const compiler_core_1 = __webpack_require__(63);
const parserOptionsMinimal_1 = __webpack_require__(64);
const parserOptions = parserOptionsMinimal_1.parserOptionsMinimal;
function compile(template, options = {}) {
    return compiler_core_1.baseCompile(template, Object.assign(Object.assign(Object.assign({}, parserOptions), options), { nodeTransforms: [...(options.nodeTransforms || [])], directiveTransforms: Object.assign({}, (options.directiveTransforms || {})) }));
}
exports.compile = compile;
function parse(template, options = {}) {
    return compiler_core_1.baseParse(template, Object.assign(Object.assign({}, parserOptions), options));
}
exports.parse = parse;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dDefaultShader_1 = __webpack_require__(15);
const WebGLGrayscaleShader_1 = __webpack_require__(38);
class C2dGrayscaleShader extends C2dDefaultShader_1.C2dDefaultShader {
    constructor(context) {
        super(context);
        this._amount = 1;
    }
    static getWebGL() {
        return WebGLGrayscaleShader_1.WebGLGrayscaleShader;
    }
    set amount(v) {
        this._amount = v;
        this.redraw();
    }
    get amount() {
        return this._amount;
    }
    useDefault() {
        return this._amount === 0;
    }
    _beforeDrawEl(obj) {
        obj.target.context.filter = "grayscale(" + this._amount + ")";
    }
    _afterDrawEl(obj) {
        obj.target.context.filter = "none";
    }
}
exports.C2dGrayscaleShader = C2dGrayscaleShader;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
const C2dGrayscaleShader_1 = __webpack_require__(37);
class WebGLGrayscaleShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._amount = 1;
    }
    static getC2d() {
        return C2dGrayscaleShader_1.C2dGrayscaleShader;
    }
    set amount(v) {
        this._amount = v;
        this.redraw();
    }
    get amount() {
        return this._amount;
    }
    useDefault() {
        return this._amount === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }
}
exports.WebGLGrayscaleShader = WebGLGrayscaleShader;
WebGLGrayscaleShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class NoiseTexture extends Texture_1.Texture {
    _getLookupId() {
        return "__noise";
    }
    _getSourceLoader() {
        const gl = this.stage.gl;
        return (cb) => {
            const noise = new Uint8Array(128 * 128 * 4);
            for (let i = 0; i < 128 * 128 * 4; i += 4) {
                const v = Math.floor(Math.random() * 256);
                noise[i] = v;
                noise[i + 1] = v;
                noise[i + 2] = v;
                noise[i + 3] = 255;
            }
            const texParams = {};
            if (gl) {
                texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }
            cb(undefined, { source: noise, width: 128, height: 128, texParams });
        };
    }
}
exports.NoiseTexture = NoiseTexture;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(84));
__export(__webpack_require__(85));
__export(__webpack_require__(86));
__export(__webpack_require__(39));
__export(__webpack_require__(87));
__export(__webpack_require__(88));
__export(__webpack_require__(89));
__export(__webpack_require__(90));
__export(__webpack_require__(41));


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(91));
__export(__webpack_require__(42));


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextTextureRenderer {
    constructor(stage, canvas, text, settings, pixelRatio) {
        this.stage = stage;
        this.canvas = canvas;
        this.text = text;
        this.settings = settings;
        this.pixelRatio = pixelRatio;
        this._context = this.canvas.getContext("2d");
    }
    setFontProperties() {
        this._context.font = this._getFontSetting();
    }
    _getFontSetting() {
        const fontWeight = this.settings.fontWeight || 400;
        const fontStyle = this.settings.fontStyle || "normal";
        const fontSize = (this.settings.fontSize || 40) * this.pixelRatio;
        const fontFaces = this._getFontFaces();
        return `${fontStyle} ${fontWeight} ${fontSize}px ${fontFaces.join(",")}`;
    }
    _getFontFaces() {
        let fontFace = this.settings.fontFace;
        if (!fontFace) {
            fontFace = this.stage.defaultFontFace;
        }
        if (fontFace) {
            return fontFace.map((fontFaceName) => {
                if (fontFaceName === "serif" || fontFaceName === "sans-serif") {
                    return fontFaceName;
                }
                else {
                    return `"${fontFaceName}"`;
                }
            });
        }
        else {
            return [];
        }
    }
    _load() {
        const documentFonts = getDocumentFonts();
        if (documentFonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!documentFonts.check(fontSetting, this.text)) {
                    // Use a promise that waits for loading.
                    return documentFonts
                        .load(fontSetting, this.text)
                        .catch((err) => {
                        // Just load the fallback font.
                        console.warn("Font load error", err, fontSetting);
                    })
                        .then(() => {
                        if (!documentFonts.check(fontSetting, this.text)) {
                            console.warn("Font not found", fontSetting);
                        }
                    });
                }
            }
            catch (e) {
                console.warn("Can't check font loading for " + fontSetting);
            }
        }
    }
    draw() {
        // We do not use a promise if possible to be able to load the texture during the current drawFrame cycle.
        const loadPromise = this._load();
        if (!loadPromise) {
            this._draw();
        }
        else {
            return loadPromise.then(() => {
                this._draw();
            });
        }
    }
    _draw() {
        const renderInfo = {};
        const pixelRatio = this.pixelRatio;
        let { fontSize = 40, cutSx = 0, cutEx = 0, cutSy = 0, cutEy = 0 } = this.settings;
        const text = this.text;
        fontSize = fontSize * pixelRatio;
        cutSx = cutSx * pixelRatio;
        cutEx = cutEx * pixelRatio;
        cutSy = cutSy * pixelRatio;
        cutEy = cutEy * pixelRatio;
        // Set font properties.
        this.setFontProperties();
        const sizeInfo = this._context.measureText(text);
        renderInfo.sizeInfo = sizeInfo;
        let width = Math.ceil(sizeInfo.width);
        let height = Math.ceil(fontSize);
        renderInfo.w = width;
        renderInfo.h = height;
        renderInfo.pixelRatio = pixelRatio;
        // To prevent canvas errors.
        if (!width)
            width = 1;
        if (!height)
            height = 1;
        if (cutSx || cutEx) {
            width = Math.min(width, cutEx - cutSx);
        }
        if (cutSy || cutEy) {
            height = Math.min(height, cutEy - cutSy);
        }
        // Add extra margin to prevent issue with clipped text when scaling.
        this.canvas.width = width;
        this.canvas.height = height;
        // Canvas context has been reset.
        this.setFontProperties();
        if (cutSx || cutSy) {
            this._context.translate(-cutSx, -cutSy);
        }
        this._context.textBaseline = "top";
        this._context.fillStyle = "white";
        this._context.fillText(text, 0, 0);
        if (cutSx || cutSy) {
            this._context.translate(cutSx, cutSy);
        }
        this.renderInfo = renderInfo;
    }
}
exports.TextTextureRenderer = TextTextureRenderer;
function getDocumentFonts() {
    return document.fonts;
}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlexLayouter_1 = __webpack_require__(97);
class FlexContainer {
    constructor(node) {
        this.node = node;
        this.horizontal = true;
        this.reverse = false;
        this.layout = new FlexLayouter_1.FlexLayouter(this);
        this._wrap = false;
        this._alignItems = "stretch";
        this._justifyContent = "flex-start";
        this._alignContent = "flex-start";
        this._paddingLeft = 0;
        this._paddingTop = 0;
        this._paddingRight = 0;
        this._paddingBottom = 0;
        this._enabled = false;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(v) {
        if (v !== this._enabled) {
            this._enabled = v;
            this.node.setFlexEnabled(v);
        }
    }
    get direction() {
        if (this.horizontal) {
            return this.reverse ? "row-reverse" : "row";
        }
        else {
            return this.reverse ? "column-reverse" : "column";
        }
    }
    set direction(f) {
        if (this.direction === f)
            return;
        this.horizontal = f === "row" || f === "row-reverse";
        this.reverse = f === "row-reverse" || f === "column-reverse";
        this.changedContents();
    }
    set wrap(v) {
        this._wrap = v;
        this.changedContents();
    }
    get wrap() {
        return this._wrap;
    }
    get alignItems() {
        return this._alignItems;
    }
    set alignItems(v) {
        if (this._alignItems === v)
            return;
        this._alignItems = v;
        this.changedContents();
    }
    get alignContent() {
        return this._alignContent;
    }
    set alignContent(v) {
        if (this._alignContent === v)
            return;
        this._alignContent = v;
        this.changedContents();
    }
    get justifyContent() {
        return this._justifyContent;
    }
    set justifyContent(v) {
        if (this._justifyContent === v)
            return;
        this._justifyContent = v;
        this.changedContents();
    }
    set padding(v) {
        this.paddingLeft = v;
        this.paddingTop = v;
        this.paddingRight = v;
        this.paddingBottom = v;
    }
    get padding() {
        return this.paddingLeft;
    }
    set paddingLeft(v) {
        this._paddingLeft = v;
        this.changedDimensions();
    }
    get paddingLeft() {
        return this._paddingLeft;
    }
    set paddingTop(v) {
        this._paddingTop = v;
        this.changedDimensions();
    }
    get paddingTop() {
        return this._paddingTop;
    }
    set paddingRight(v) {
        this._paddingRight = v;
        this.changedDimensions();
    }
    get paddingRight() {
        return this._paddingRight;
    }
    set paddingBottom(v) {
        this._paddingBottom = v;
        this.changedDimensions();
    }
    get paddingBottom() {
        return this._paddingBottom;
    }
    changedDimensions() {
        this.node.forceLayout();
    }
    changedContents() {
        this.node.changedContents();
    }
}
exports.FlexContainer = FlexContainer;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getSpacing(mode, numberOfItems, remainingSpace) {
    const itemGaps = numberOfItems - 1;
    let spacePerGap;
    let spacingBefore;
    let spacingBetween;
    switch (mode) {
        case "flex-start":
            spacingBefore = 0;
            spacingBetween = 0;
            break;
        case "flex-end":
            spacingBefore = remainingSpace;
            spacingBetween = 0;
            break;
        case "center":
            spacingBefore = remainingSpace / 2;
            spacingBetween = 0;
            break;
        case "space-between":
            spacingBefore = 0;
            spacingBetween = Math.max(0, remainingSpace) / itemGaps;
            break;
        case "space-around":
            if (remainingSpace < 0) {
                return getSpacing("center", numberOfItems, remainingSpace);
            }
            else {
                spacePerGap = remainingSpace / (itemGaps + 1);
                spacingBefore = 0.5 * spacePerGap;
                spacingBetween = spacePerGap;
            }
            break;
        case "space-evenly":
            if (remainingSpace < 0) {
                return getSpacing("center", numberOfItems, remainingSpace);
            }
            else {
                spacePerGap = remainingSpace / (itemGaps + 2);
                spacingBefore = spacePerGap;
                spacingBetween = spacePerGap;
            }
            break;
        case "stretch":
            spacingBefore = 0;
            spacingBetween = 0;
            break;
        default:
            throw new Error("Unknown mode: " + mode);
    }
    return { spacingBefore, spacingBetween };
}
exports.getSpacing = getSpacing;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class FlexItem {
    constructor(node) {
        this.node = node;
        this._grow = 0;
        this._shrink = FlexItem.SHRINK_AUTO;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = 0;
        this._maxHeight = 0;
        this._marginLeft = 0;
        this._marginTop = 0;
        this._marginRight = 0;
        this._marginBottom = 0;
        this._enabled = true;
    }
    getContainer() {
        return this.container;
    }
    setContainer(c) {
        this.container = c;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(v) {
        if (v !== this._enabled) {
            const prevFlexParent = this.node.flexParent;
            this._enabled = v;
            this.node.updateEnabledFlag();
            if (prevFlexParent) {
                prevFlexParent.changedChildren();
            }
            const newFlexParent = this.node.flexParent;
            if (newFlexParent) {
                newFlexParent.changedChildren();
            }
        }
    }
    get grow() {
        return this._grow;
    }
    set grow(v) {
        if (this._grow === v)
            return;
        this._grow = v;
        this._changed();
    }
    set shrink(v) {
        if (this._shrink === v)
            return;
        this._shrink = v;
        this._changed();
    }
    get shrink() {
        if (this._shrink === FlexItem.SHRINK_AUTO) {
            return this.getDefaultShrink();
        }
        return this._shrink;
    }
    getDefaultShrink() {
        if (this.node.isFlexEnabled()) {
            return 1;
        }
        else {
            // All non-flex containers are absolutely positioned items with fixed dimensions, and by default not shrinkable.
            return 0;
        }
    }
    get alignSelf() {
        return this._alignSelf;
    }
    set alignSelf(v) {
        if (this._alignSelf === v)
            return;
        if (v === undefined) {
            this._alignSelf = undefined;
        }
        else {
            this._alignSelf = v;
        }
        this._changed();
    }
    get minWidth() {
        return this._minWidth;
    }
    set minWidth(v) {
        this._minWidth = Math.max(0, v);
        this.node.forceLayout(true, false);
    }
    get minHeight() {
        return this._minHeight;
    }
    set minHeight(v) {
        this._minHeight = Math.max(0, v);
        this.node.forceLayout(false, true);
    }
    get maxWidth() {
        return this._maxWidth;
    }
    set maxWidth(v) {
        this._maxWidth = Math.max(0, v);
        this.node.forceLayout(true, false);
    }
    get maxHeight() {
        return this._maxHeight;
    }
    set maxHeight(v) {
        this._maxHeight = Math.max(0, v);
        this.node.forceLayout(false, true);
    }
    /**
     * @note margins behave slightly different than in HTML with regard to shrinking.
     * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
     */
    set margin(v) {
        this.marginLeft = v;
        this.marginTop = v;
        this.marginRight = v;
        this.marginBottom = v;
    }
    get margin() {
        return this.marginLeft;
    }
    set marginLeft(v) {
        this._marginLeft = v;
        this._changed();
    }
    get marginLeft() {
        return this._marginLeft;
    }
    set marginTop(v) {
        this._marginTop = v;
        this._changed();
    }
    get marginTop() {
        return this._marginTop;
    }
    set marginRight(v) {
        this._marginRight = v;
        this._changed();
    }
    get marginRight() {
        return this._marginRight;
    }
    set marginBottom(v) {
        this._marginBottom = v;
        this._changed();
    }
    get marginBottom() {
        return this._marginBottom;
    }
    _changed() {
        if (this.container)
            this.container.changedContents();
    }
    resetLayoutSize() {
        this.resetHorizontalAxisLayoutSize();
        this.resetVerticalAxisLayoutSize();
    }
    resetCrossAxisLayoutSize() {
        if (this.horizontal) {
            this.resetVerticalAxisLayoutSize();
        }
        else {
            this.resetHorizontalAxisLayoutSize();
        }
    }
    resetHorizontalAxisLayoutSize() {
        let w = this.node.getRelAxisSize(true);
        if (this._minWidth) {
            w = Math.max(this._minWidth, w);
        }
        if (this._maxWidth) {
            w = Math.min(this._maxWidth, w);
        }
        this.node.setAxisLayoutSize(true, w);
    }
    resetVerticalAxisLayoutSize() {
        let h = this.node.getRelAxisSize(false);
        if (this._minHeight) {
            h = Math.max(this._minHeight, h);
        }
        if (this._maxHeight) {
            h = Math.min(this._maxHeight, h);
        }
        this.node.setAxisLayoutSize(false, h);
    }
    getCrossAxisMinSizeSetting() {
        return this.getMinSizeSetting(!this.horizontal);
    }
    getCrossAxisMaxSizeSetting() {
        return this.getMaxSizeSetting(!this.horizontal);
    }
    getMainAxisMaxSizeSetting() {
        return this.getMaxSizeSetting(this.horizontal);
    }
    getMinSizeSetting(horizontal) {
        if (horizontal) {
            return this._minWidth;
        }
        else {
            return this._minHeight;
        }
    }
    getMaxSizeSetting(horizontal) {
        if (horizontal) {
            return this._maxWidth;
        }
        else {
            return this._maxHeight;
        }
    }
    get horizontal() {
        return this.container.horizontal;
    }
    getMainAxisMinSize() {
        return this.node.getAxisMinSize(this.horizontal);
    }
    getCrossAxisMinSize() {
        return this.node.getAxisMinSize(!this.horizontal);
    }
    getMainAxisLayoutSize() {
        return this.node.getAxisLayoutSize(this.horizontal);
    }
    getMainAxisLayoutPos() {
        return this.node.getAxisLayoutPos(this.horizontal);
    }
    setMainAxisLayoutPos(pos) {
        return this.node.setAxisLayoutPos(this.horizontal, pos);
    }
    setCrossAxisLayoutPos(pos) {
        return this.node.setAxisLayoutPos(!this.horizontal, pos);
    }
    getCrossAxisLayoutSize() {
        return this.node.getAxisLayoutSize(!this.horizontal);
    }
    resizeCrossAxis(size) {
        return this.node.resizeAxis(!this.horizontal, size);
    }
    resizeMainAxis(size) {
        return this.node.resizeAxis(this.horizontal, size);
    }
    getMainAxisPadding() {
        return this.node.getTotalPadding(this.horizontal);
    }
    getCrossAxisPadding() {
        return this.node.getTotalPadding(!this.horizontal);
    }
    getMainAxisMargin() {
        return this.node.getTotalMargin(this.horizontal);
    }
    getCrossAxisMargin() {
        return this.node.getTotalMargin(!this.horizontal);
    }
    getMainAxisMinSizeWithPaddingAndMargin() {
        return this.getMainAxisMinSize() + this.getMainAxisPadding() + this.getMainAxisMargin();
    }
    getCrossAxisMinSizeWithPaddingAndMargin() {
        return this.getCrossAxisMinSize() + this.getCrossAxisPadding() + this.getCrossAxisMargin();
    }
    getMainAxisLayoutSizeWithPaddingAndMargin() {
        return this.getMainAxisLayoutSize() + this.getMainAxisPadding() + this.getMainAxisMargin();
    }
    getCrossAxisLayoutSizeWithPaddingAndMargin() {
        return this.getCrossAxisLayoutSize() + this.getCrossAxisPadding() + this.getCrossAxisMargin();
    }
    hasFixedCrossAxisSize() {
        return !this.node.isZeroAxisSize(!this.horizontal);
    }
    hasRelCrossAxisSize() {
        return !!(this.horizontal ? this.node.sourceFuncH : this.node.sourceFuncW);
    }
}
exports.FlexItem = FlexItem;
FlexItem.SHRINK_AUTO = -1;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlexContainer_1 = __webpack_require__(43);
const FlexItem_1 = __webpack_require__(45);
/**
 * This is the connection between the render tree with the layout tree of this flex container/item.
 */
class FlexNode {
    constructor(subject) {
        this.subject = subject;
        /**
         * Possible values (only in case of container):
         * bit 0: has changed or contains items with changes
         * bit 1: width changed
         * bit 2: height changed
         */
        this._recalc = 0;
        this._enabled = false;
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        // When a flex node is skipped, it does not take part in the flex layout.
        // Both ancestors and descendants are considered to be at this node's level instead.
        this._skip = false;
    }
    get flexLayout() {
        return this.isFlexEnabled() ? this.flex.layout : undefined;
    }
    layoutFlexTree() {
        if (this.isFlexEnabled()) {
            this.flexLayout.layoutTree();
        }
    }
    get flex() {
        this._ensureFlex();
        return this._flex;
    }
    _ensureFlex() {
        if (!this._flex) {
            this._flex = new FlexContainer_1.FlexContainer(this);
        }
    }
    setFlexEnabled(v) {
        // When skipped, defer enabling until no longer skipped.
        if (!this._skip) {
            if (v) {
                this.enableFlex();
            }
            else {
                this.disableFlex();
            }
        }
    }
    enableFlex() {
        this.forceLayout();
        this.enableChildrenAsFlexItems();
        this.updateEnabledFlag();
    }
    disableFlex() {
        this.forceLayout();
        this.disableChildrenAsFlexItems();
        this.updateEnabledFlag();
    }
    get skip() {
        return this._skip;
    }
    set skip(value) {
        if (this._skip !== value) {
            if (value) {
                this.setSkipped();
            }
            else {
                this.unsetSkipped();
            }
        }
    }
    setSkipped() {
        const flexParent = this.flexParent;
        const isFlexEnabled = this.isFlexEnabled();
        this._skip = true;
        if (isFlexEnabled) {
            // We disable flex to simplify some cache-related stuff.
            this.disableFlex();
        }
        if (flexParent) {
            this.disableFlexItem();
            this.enableChildrenAsFlexItems();
            flexParent.changedChildren();
        }
    }
    unsetSkipped() {
        var _a;
        this._skip = false;
        const parentIsFlex = (_a = this.getParent()) === null || _a === void 0 ? void 0 : _a.isFlexEnabled();
        if (parentIsFlex) {
            this.disableChildrenAsFlexItems();
            this.enableFlexItem();
            this.getParent().changedChildren();
        }
        if (this._flex && this._flex.enabled) {
            this.enableFlex();
        }
    }
    isFlexEnabled() {
        return !this._skip && (this._flex ? this._flex.enabled : false);
    }
    isFlexItemEnabled() {
        return !this._skip && this.flexParent !== undefined;
    }
    isEnabled() {
        return this.isFlexEnabled() || this.isFlexItemEnabled();
    }
    get flexItem() {
        this.ensureFlexItem();
        return this._flexItem;
    }
    ensureFlexItem() {
        if (!this._flexItem) {
            this._flexItem = new FlexItem_1.FlexItem(this);
        }
    }
    getChildren() {
        const results = [];
        const children = this.subject.getChildren();
        if (children) {
            const n = children.length;
            for (let i = 0; i < n; i++) {
                const child = children[i];
                FlexNode.gatherChildren(child, results);
            }
        }
        return results;
    }
    static gatherChildren(child, results) {
        if (child.hasLayout() && child.getLayout().skip) {
            const children = child.getChildren();
            if (children) {
                const n = children.length;
                for (let i = 0; i < n; i++) {
                    const child = children[i];
                    this.gatherChildren(child, results);
                }
            }
        }
        else {
            results.push(child.getLayout());
        }
    }
    enableChildrenAsFlexItems() {
        const children = this.getChildren();
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.enableFlexItem();
            }
        }
    }
    disableChildrenAsFlexItems() {
        const children = this.getChildren();
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.disableFlexItem();
            }
        }
    }
    enableFlexItem() {
        this.ensureFlexItem();
        const flexParent = this.getParent();
        this._flexItem.setContainer(flexParent._flex);
        flexParent.changedContents();
        this.updateEnabledFlag();
    }
    disableFlexItem() {
        if (this._flexItem) {
            this._flexItem.setContainer(undefined);
        }
        // We keep the flexItem object because it may contain custom settings.
        this.updateEnabledFlag();
    }
    updateEnabledFlag() {
        const enabled = this.isEnabled();
        if (this._enabled !== enabled) {
            if (!enabled) {
                this.disable();
            }
            this._enabled = enabled;
        }
    }
    disable() {
        this.restoreSubjectToNonFlex();
    }
    restoreSubjectToNonFlex() {
        const subject = this.subject;
        subject.setLayoutCoords(subject.getSourceX(), subject.getSourceY());
        subject.setLayoutDimensions(subject.getSourceW(), subject.getSourceH());
    }
    getParent() {
        const activeParent = FlexNode.getActiveLayoutSubject(this.subject.getParent());
        return activeParent ? activeParent.getLayout() : undefined;
    }
    setParent(from, to) {
        const fromNode = FlexNode.getActiveLayoutNode(from);
        if (fromNode === null || fromNode === void 0 ? void 0 : fromNode.isFlexEnabled()) {
            fromNode.changedChildren();
        }
        const toNode = FlexNode.getActiveLayoutNode(to);
        if (toNode === null || toNode === void 0 ? void 0 : toNode.isFlexEnabled()) {
            if (this._skip) {
                this.enableChildrenAsFlexItems();
            }
            else {
                this.enableFlexItem();
            }
            toNode.changedChildren();
        }
        else {
            if (fromNode === null || fromNode === void 0 ? void 0 : fromNode.isFlexEnabled()) {
                if (this._skip) {
                    this.disableChildrenAsFlexItems();
                }
                else {
                    this.disableFlexItem();
                }
                fromNode.changedChildren();
            }
        }
    }
    get flexParent() {
        if (!this.flexItem.enabled) {
            return undefined;
        }
        const parent = this.getParent();
        if (parent && parent.isFlexEnabled()) {
            return parent;
        }
        return undefined;
    }
    updateVisible() {
        const parent = this.flexParent;
        if (parent) {
            parent.changedChildren();
        }
    }
    get items() {
        if (!this._items) {
            this._items = this.getFlexItems();
        }
        return this._items;
    }
    getFlexItems() {
        const items = [];
        const children = this.getChildren();
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const item = children[i];
                if (item.subject.isDisplayed()) {
                    if (item.isFlexItemEnabled()) {
                        items.push(item);
                    }
                }
            }
        }
        return items;
    }
    changedChildren() {
        this.clearFlexItemsCache();
        this.changedContents();
    }
    clearFlexItemsCache() {
        this._items = undefined;
    }
    setLayout(x, y, w, h) {
        const subject = this.subject;
        let sourceX = subject.getSourceX();
        let sourceY = subject.getSourceY();
        if (this.sourceFuncX) {
            sourceX = this.sourceFuncX(this.getParentAxisSizeWithPadding(true), this.getParentAxisSizeWithPadding(false));
        }
        if (this.sourceFuncY) {
            sourceY = this.sourceFuncY(this.getParentAxisSizeWithPadding(true), this.getParentAxisSizeWithPadding(false));
        }
        if (this.isFlexItemEnabled()) {
            subject.setLayoutCoords(x + sourceX, y + sourceY);
        }
        else {
            // Reuse the x,y 'settings'.
            subject.setLayoutCoords(sourceX, sourceY);
        }
        subject.setLayoutDimensions(w, h);
    }
    forceLayout(changeWidth = true, changeHeight = true) {
        this.updateRecalc(changeWidth, changeHeight);
    }
    changedContents() {
        this.updateRecalc();
    }
    isChanged() {
        return this._recalc > 0;
    }
    updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
        if (this.isFlexEnabled()) {
            const layout = this._flex.layout;
            // When something internal changes, it can have effect on the external dimensions.
            changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
            changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
        }
        const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
        const newRecalcFlags = this.getNewRecalcFlags(recalc);
        this._recalc |= recalc;
        if (newRecalcFlags > 1) {
            if (this.flexParent) {
                this.flexParent.updateRecalcBottomUp(recalc);
            }
            else {
                this.subject.triggerLayout();
            }
        }
        else {
            this.subject.triggerLayout();
        }
    }
    getNewRecalcFlags(flags) {
        return (7 - this._recalc) & flags;
    }
    updateRecalcBottomUp(childRecalc) {
        const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
        const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
        this._recalc |= newRecalc;
        if (newRecalcFlags > 1) {
            const flexParent = this.flexParent;
            if (flexParent) {
                flexParent.updateRecalcBottomUp(newRecalc);
            }
            else {
                this.subject.triggerLayout();
            }
        }
        else {
            this.subject.triggerLayout();
        }
    }
    _getRecalcFromChangedChildRecalc(childRecalc) {
        const layout = this._flex.layout;
        const mainAxisRecalcFlag = layout.horizontal ? 1 : 2;
        const crossAxisRecalcFlag = layout.horizontal ? 2 : 1;
        const crossAxisDimensionsChangedInChild = childRecalc & crossAxisRecalcFlag;
        if (!crossAxisDimensionsChangedInChild) {
            const mainAxisDimensionsChangedInChild = childRecalc & mainAxisRecalcFlag;
            if (mainAxisDimensionsChangedInChild) {
                const mainAxisIsWrapping = layout.isWrapping();
                if (mainAxisIsWrapping) {
                    const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                    if (crossAxisIsFitToContents) {
                        // Special case: due to wrapping, the cross axis size may be changed.
                        childRecalc += crossAxisRecalcFlag;
                    }
                }
            }
        }
        let isWidthDynamic = layout.isAxisFitToContents(true);
        let isHeightDynamic = layout.isAxisFitToContents(false);
        if (layout.hasShrunk()) {
            // If during previous layout this container was 'shrunk', any changes may change the 'min axis size' of the
            // contents, leading to a different axis size on this container even when it was not 'fit to contents'.
            if (layout.horizontal) {
                isWidthDynamic = true;
            }
            else {
                isHeightDynamic = true;
            }
        }
        const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);
        return childRecalc & localRecalc;
    }
    get recalc() {
        return this._recalc;
    }
    clearRecalcFlag() {
        this._recalc = 0;
    }
    enableLocalRecalcFlag() {
        this._recalc = 1;
    }
    updatedSourceW() {
        this.forceLayout(true, false);
    }
    updatedSourceH() {
        this.forceLayout(false, true);
    }
    get sourceFuncX() {
        return this.subject.getSourceFuncX();
    }
    get sourceFuncY() {
        return this.subject.getSourceFuncY();
    }
    get sourceFuncW() {
        return this.subject.getSourceFuncW();
    }
    get sourceFuncH() {
        return this.subject.getSourceFuncH();
    }
    getAxisLayoutSize(horizontal) {
        return horizontal ? this.w : this.h;
    }
    setAxisLayoutSize(horizontal, size) {
        if (horizontal) {
            this.w = size;
        }
        else {
            this.h = size;
        }
    }
    getAxisLayoutPos(horizontal) {
        return horizontal ? this.x : this.y;
    }
    setAxisLayoutPos(horizontal, pos) {
        if (horizontal) {
            this.x = pos;
        }
        else {
            this.y = pos;
        }
    }
    getParentAxisSizeWithPadding(horizontal) {
        const flexParent = this.getParent();
        if (!flexParent) {
            return 0;
        }
        else {
            if (flexParent.isFlexEnabled()) {
                // Use pending layout size.
                return flexParent.getAxisLayoutSize(horizontal) + flexParent.getTotalPadding(horizontal);
            }
            else {
                // Use layouted size.
                const parentSubject = flexParent.subject;
                return horizontal ? parentSubject.getLayoutW() : parentSubject.getLayoutH();
            }
        }
    }
    getHorizontalPaddingOffset() {
        return this.getPaddingOffset(true);
    }
    getVerticalPaddingOffset() {
        return this.getPaddingOffset(false);
    }
    getPaddingOffset(horizontal) {
        if (this.isFlexEnabled()) {
            const flex = this.flex;
            if (horizontal) {
                return flex.paddingLeft;
            }
            else {
                return flex.paddingTop;
            }
        }
        else {
            return 0;
        }
    }
    getHorizontalPadding() {
        return this.getTotalPadding(true);
    }
    getVerticalPadding() {
        return this.getTotalPadding(false);
    }
    getTotalPadding(horizontal) {
        if (this.isFlexEnabled()) {
            const flex = this.flex;
            if (horizontal) {
                return flex.paddingRight + flex.paddingLeft;
            }
            else {
                return flex.paddingTop + flex.paddingBottom;
            }
        }
        else {
            return 0;
        }
    }
    getRelAxisSize(horizontal) {
        if (horizontal) {
            if (this.sourceFuncW) {
                if (this.allowRelAxisSizeFunction(true)) {
                    return this.sourceFuncW(this.getParentAxisSizeWithPadding(true), this.getParentAxisSizeWithPadding(false));
                }
                else {
                    return 0;
                }
            }
            else {
                return this.subject.getSourceW();
            }
        }
        else {
            if (this.sourceFuncH) {
                if (this.allowRelAxisSizeFunction(false)) {
                    return this.sourceFuncH(this.getParentAxisSizeWithPadding(true), this.getParentAxisSizeWithPadding(false));
                }
                else {
                    return 0;
                }
            }
            else {
                return this.subject.getSourceH();
            }
        }
    }
    getMarginOffset(horizontal) {
        const flexItem = this.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginLeft;
            }
            else {
                return flexItem.marginTop;
            }
        }
        else {
            return 0;
        }
    }
    getHorizontalMarginOffset() {
        return this.getMarginOffset(true);
    }
    getVerticalMarginOffset() {
        return this.getMarginOffset(false);
    }
    getTotalMargin(horizontal) {
        const flexItem = this.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginRight + flexItem.marginLeft;
            }
            else {
                return flexItem.marginTop + flexItem.marginBottom;
            }
        }
        else {
            return 0;
        }
    }
    allowRelAxisSizeFunction(horizontal) {
        const flexParent = this.flexParent;
        if (flexParent && flexParent.flex.layout.isAxisFitToContents(horizontal)) {
            // We don't allow relative width on fit-to-contents because it leads to conflicts.
            return false;
        }
        return true;
    }
    isZeroAxisSize(horizontal) {
        if (horizontal) {
            return !this.subject.getSourceW() && !this.sourceFuncW;
        }
        else {
            return !this.subject.getSourceH() && !this.sourceFuncH;
        }
    }
    getAxisMinSize(horizontal) {
        let minSize = this.getPlainAxisMinSize(horizontal);
        let flexItemMinSize = 0;
        if (this.isFlexItemEnabled()) {
            flexItemMinSize = this.flexItem.getMinSizeSetting(horizontal);
        }
        const hasLimitedMinSize = flexItemMinSize > 0;
        if (hasLimitedMinSize) {
            minSize = Math.max(minSize, flexItemMinSize);
        }
        return minSize;
    }
    getPlainAxisMinSize(horizontal) {
        if (this.isFlexEnabled()) {
            return this.flex.layout.getAxisMinLineSize(horizontal);
        }
        else {
            const isShrinkable = this.flexItem.shrink !== 0;
            if (isShrinkable) {
                return 0;
            }
            else {
                return this.getRelAxisSize(horizontal);
            }
        }
    }
    resizeAxis(horizontal, size) {
        if (this.isFlexEnabled()) {
            const flex = this.flex;
            const isMainAxis = flex.horizontal === horizontal;
            if (isMainAxis) {
                flex.layout.resizeMainAxis(size);
            }
            else {
                flex.layout.resizeCrossAxis(size);
            }
        }
        else {
            this.setAxisLayoutSize(horizontal, size);
        }
    }
    isLayoutRoot() {
        return this.isFlexEnabled() && !this.isFlexItemEnabled();
    }
    static getActiveLayoutNode(subject) {
        var _a;
        return (_a = this.getActiveLayoutSubject(subject)) === null || _a === void 0 ? void 0 : _a.getLayout();
    }
    static getActiveLayoutSubject(subject) {
        let current = subject;
        while (current && current.hasLayout() && current.getLayout().skip) {
            current = current.getParent();
        }
        return current;
    }
}
exports.FlexNode = FlexNode;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Manages the list of children for an element.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ObjectList_1 = __webpack_require__(48);
const getCore = (i) => i.core;
class ElementChildList extends ObjectList_1.ObjectList {
    constructor(element) {
        super();
        this.element = element;
    }
    getIndex(item) {
        if (item.parent !== this.element) {
            // Performance optimization for new items.
            return -1;
        }
        else {
            return super.getIndex(item);
        }
    }
    itemInList(item) {
        // Performance improvement.
        return item.parent === this.element;
    }
    onAdd(item, index) {
        this.connectParent(item);
        this.element.core.addChildAt(index, item.core);
    }
    onRemove(item, index) {
        item._setParent(undefined);
        this.element.core.removeChildAt(index);
    }
    onSync(removed, added, order) {
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i]._setParent(undefined);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            this.connectParent(added[i]);
        }
        this.element.core.syncChildren(removed.map(getCore), added.map(getCore), order.map(getCore));
    }
    onSet(item, index, prevItem) {
        prevItem._setParent(undefined);
        this.connectParent(item);
        this.element.core.setChildAt(index, item.core);
    }
    onMove(item, fromIndex, toIndex) {
        this.element.core.moveChild(fromIndex, toIndex);
    }
    connectParent(item) {
        const prevParent = item.parent;
        if (prevParent && prevParent !== this.element) {
            // Cleanup in previous child list.
            const prevChildList = prevParent.childList;
            const index = prevChildList.getIndex(item);
            prevChildList.removeSilently(index);
            // Also clean up element core.
            prevParent.core.removeChildAt(index);
        }
        item._setParent(this.element);
    }
}
exports.ElementChildList = ElementChildList;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = __webpack_require__(7);
/**
 * Manages a list of objects.
 * Objects may be patched. Then, they can be referenced using the 'ref' (string) property.
 */
class ObjectList {
    constructor() {
        this._items = [];
        this._refs = {};
    }
    getItems() {
        return this._items;
    }
    get first() {
        return this._items[0];
    }
    get last() {
        return this._items.length ? this._items[this._items.length - 1] : undefined;
    }
    add(item) {
        if (!this.itemInList(item)) {
            if (item.ref) {
                this._refs[item.ref] = item;
            }
            this._items.push(item);
            this.onAdd(item, this._items.length - 1);
        }
    }
    itemInList(item) {
        return this.getIndex(item) !== -1;
    }
    addAt(item, index) {
        if (index >= 0 && index <= this._items.length) {
            let currentIndex = -1;
            currentIndex = this.getIndex(item);
            if (currentIndex === index) {
                return;
            }
            if (currentIndex !== -1) {
                this.setAt(item, index);
            }
            else {
                if (item.ref) {
                    this._refs[item.ref] = item;
                }
                this._items.splice(index, 0, item);
                this.onAdd(item, index);
            }
        }
        else {
            throw new Error("addAt: The index " + index + " is out of bounds " + this._items.length);
        }
    }
    replaceByRef(item) {
        if (item.ref) {
            const existingItem = this.getByRef(item.ref);
            if (!existingItem) {
                throw new Error("replaceByRef: no item found with reference: " + item.ref);
            }
            this.replace(item, existingItem);
        }
        else {
            throw new Error("replaceByRef: no ref specified in item");
        }
        this.addAt(item, this._items.length);
    }
    replace(item, prevItem) {
        const index = this.getIndex(prevItem);
        if (index === -1) {
            throw new Error("replace: The previous item does not exist");
        }
        this.setAt(item, index);
    }
    setAt(item, index) {
        if (index >= 0 && index <= this._items.length) {
            const currentIndex = this.getIndex(item);
            if (currentIndex !== -1) {
                if (currentIndex !== index) {
                    const fromIndex = currentIndex;
                    if (fromIndex !== index) {
                        this._items.splice(fromIndex, 1);
                        this._items.splice(index, 0, item);
                        this.onMove(item, fromIndex, index);
                    }
                }
            }
            else {
                if (index < this._items.length) {
                    const ref = this._items[index].ref;
                    if (ref) {
                        this._refs[ref] = undefined;
                    }
                }
                const prevItem = this._items[index];
                // Doesn't exist yet: overwrite current.
                this._items[index] = item;
                if (item.ref) {
                    this._refs[item.ref] = item;
                }
                this.onSet(item, index, prevItem);
            }
        }
        else {
            throw new Error("setAt: The index " + index + " is out of bounds " + this._items.length);
        }
    }
    getAt(index) {
        return this._items[index];
    }
    getIndex(item) {
        return this._items.indexOf(item);
    }
    remove(item) {
        const index = this._items.indexOf(item);
        if (index !== -1) {
            this.removeAt(index);
        }
    }
    removeAt(index) {
        const item = this.removeSilently(index);
        this.onRemove(item, index);
        return item;
    }
    removeSilently(index) {
        const item = this._items[index];
        if (item.ref) {
            this._refs[item.ref] = undefined;
        }
        this._items.splice(index, 1);
        return item;
    }
    clear() {
        const n = this._items.length;
        if (n) {
            const prev = this._items;
            this._items = [];
            this._refs = {};
            this.onSync(prev, [], []);
        }
    }
    get length() {
        return this._items.length;
    }
    getRefs() {
        return this._refs;
    }
    getByRef(ref) {
        return this._refs[ref];
    }
    clearRef(ref) {
        delete this._refs[ref];
    }
    setRef(ref, child) {
        this._refs[ref] = child;
    }
    setItems(newItems) {
        const prevItems = this._items;
        this._items = newItems;
        const removedSet = new Set(prevItems);
        const added = [];
        for (let i = 0, n = newItems.length; i < n; i++) {
            const alreadyExists = removedSet.delete(newItems[i]);
            if (!alreadyExists) {
                added.push(newItems[i]);
            }
        }
        const removed = Utils_1.Utils.setToArray(removedSet);
        if (removed.length || added.length) {
            // Recalculate refs.
            this._refs = {};
            for (let i = 0, n = this._items.length; i < n; i++) {
                const ref = this._items[i].ref;
                if (ref) {
                    this._refs[ref] = this._items[i];
                }
            }
        }
        this.onSync(removed, added, newItems);
        return [removed, added];
    }
    sort(f) {
        const items = this._items.slice();
        items.sort(f);
        this.onSync([], [], items);
    }
    onAdd(item, index) {
        // Noop
    }
    onRemove(item, index) {
        // Noop
    }
    onSync(removed, added, order) {
        // Noop
    }
    onSet(item, index, prevItem) {
        // Noop
    }
    onMove(item, fromIndex, toIndex) {
        // Noop
    }
}
exports.ObjectList = ObjectList;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(12));


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Handler_1 = __webpack_require__(26);
const Patcher_1 = __webpack_require__(12);
const Utils_1 = __webpack_require__(7);
class SingleReferenceHandler extends Handler_1.Handler {
    constructor(sourceType, name, type, getCArgs) {
        super(sourceType, name);
        this.type = type;
        if (!getCArgs) {
            getCArgs = (obj) => {
                return [];
            };
        }
        this.getCArgs = getCArgs;
    }
    handle(obj, settings) {
        const value = obj[this.name];
        if (!settings) {
            obj[this.name] = undefined;
        }
        else if (Utils_1.Utils.isObjectLiteral(settings)) {
            if (settings.type && (!value || value.type !== settings.type)) {
                const cargs = this.getCArgs(obj);
                obj[this.name] = Patcher_1.Patcher.createObject(settings, this.type, ...cargs);
            }
            else {
                if (value) {
                    Patcher_1.Patcher.patchObject(value, settings);
                }
                else {
                    obj[this.name] = undefined;
                }
            }
        }
        else {
            obj[this.name] = settings;
        }
    }
}
exports.SingleReferenceHandler = SingleReferenceHandler;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CoreQuadList {
    constructor() {
        this.quadTextures = [];
        this.quadElementCores = [];
    }
    get length() {
        return this.quadTextures.length;
    }
    reset() {
        this.quadTextures = [];
        this.quadElementCores = [];
    }
    getElement(index) {
        return this.quadElementCores[index].element;
    }
    getElementCore(index) {
        return this.quadElementCores[index];
    }
    getTexture(index) {
        return this.quadTextures[index];
    }
    getTextureWidth(index) {
        const nativeTexture = this.quadTextures[index];
        if (nativeTexture.w) {
            // Render texture;
            return nativeTexture.w;
        }
        else {
            return this.quadElementCores[index].displayedTextureSource.w;
        }
    }
    getTextureHeight(index) {
        const nativeTexture = this.quadTextures[index];
        if (nativeTexture.h) {
            // Render texture;
            return nativeTexture.h;
        }
        else {
            return this.quadElementCores[index].displayedTextureSource.h;
        }
    }
    add(texture, elementCore) {
        this.quadTextures.push(texture);
        this.quadElementCores.push(elementCore);
    }
}
exports.CoreQuadList = CoreQuadList;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CoreQuadOperation {
    constructor(context, shader, shaderOwner, renderTextureInfo, scissor, index) {
        this.context = context;
        this.shader = shader;
        this.shaderOwner = shaderOwner;
        this.renderTextureInfo = renderTextureInfo;
        this.scissor = scissor;
        this.index = index;
        this.length = 0;
    }
    get quadList() {
        return this.context.renderState.quadList;
    }
    getTexture(index) {
        return this.quadList.getTexture(this.index + index);
    }
    getElementCore(index) {
        return this.quadList.getElementCore(this.index + index);
    }
    getElement(index) {
        return this.quadList.getElement(this.index + index);
    }
    getElementWidth(index) {
        return this.getElement(index).renderWidth;
    }
    getElementHeight(index) {
        return this.getElement(index).renderHeight;
    }
    getTextureWidth(index) {
        return this.quadList.getTextureWidth(this.index + index);
    }
    getTextureHeight(index) {
        return this.quadList.getTextureHeight(this.index + index);
    }
    getRenderWidth() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.w;
        }
        else {
            return this.context.stage.w;
        }
    }
    getRenderHeight() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.h;
        }
        else {
            return this.context.stage.h;
        }
    }
}
exports.CoreQuadOperation = CoreQuadOperation;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CoreRenderExecutor {
    constructor(context) {
        this.context = context;
        this.renderState = context.renderState;
    }
    destroy() {
        // Noop
    }
    _reset() {
        this._bindRenderTexture(undefined);
        this._setScissor(undefined);
        this._clearRenderTexture();
    }
    execute() {
        this._reset();
        const quadOps = this.renderState.quadOperations;
        let i = 0;
        const n = quadOps.length;
        while (i < n) {
            this._processQuadOperation(quadOps[i]);
            i++;
        }
    }
    _processQuadOperation(quadOperation) {
        if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
            // Ignore quad operations when we are 're-using' another texture as the render texture result.
            return;
        }
        this._setupQuadOperation(quadOperation);
        this._execQuadOperation(quadOperation);
    }
    _setupQuadOperation(quadOperation) {
        // Noop
    }
    _execQuadOperation(op) {
        // Set render texture.
        const renderTexture = op.renderTextureInfo ? op.renderTextureInfo.renderTexture : undefined;
        if (this._renderTexture !== renderTexture) {
            this._bindRenderTexture(renderTexture);
        }
        if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
            this._setScissor(undefined);
            this._clearRenderTexture();
            op.renderTextureInfo.cleared = true;
            this._setScissor(op.scissor);
        }
        else {
            this._setScissor(op.scissor);
        }
        this._renderQuadOperation(op);
    }
    _renderQuadOperation(op) {
        // Noop
    }
    _bindRenderTexture(renderTexture) {
        this._renderTexture = renderTexture;
    }
    _clearRenderTexture() {
        // Noop
    }
    _setScissor(area) {
        // Noop
    }
}
exports.CoreRenderExecutor = CoreRenderExecutor;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Renderer {
    constructor(stage) {
        this.stage = stage;
        this._defaultShader = undefined;
    }
    gc(aggressive) {
        // Noop
    }
    getDefaultShader(context = this.stage.context) {
        if (!this._defaultShader) {
            this._defaultShader = this._createDefaultShader(context);
        }
        return this._defaultShader;
    }
    isValidShaderType(shaderType) {
        return shaderType.prototype instanceof this._getShaderBaseType();
    }
    getSupportedShaderType(shaderType) {
        if (!this.isValidShaderType(shaderType)) {
            const convertedShaderType = this._getShaderAlternative(shaderType);
            if (!convertedShaderType) {
                return undefined;
            }
            return convertedShaderType;
        }
        else {
            return shaderType;
        }
    }
    _getShaderAlternative(shaderType) {
        return undefined;
    }
    onResizeCanvasSize() {
        // Not implemented.
    }
}
exports.Renderer = Renderer;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextureSource_1 = __webpack_require__(24);
class TextureManager {
    constructor(stage) {
        this.stage = stage;
        // The currently used amount of texture memory.
        this._usedMemory = 0;
        // All texture sources that are uploaded to the GPU.
        this._uploadedTextureSources = [];
        // The texture source lookup id to texture source hashmap.
        this.textureSourceHashmap = new Map();
    }
    get usedMemory() {
        return this._usedMemory;
    }
    destroy() {
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
        }
        this.textureSourceHashmap.clear();
        this._usedMemory = 0;
    }
    getReusableTextureSource(id) {
        return this.textureSourceHashmap.get(id);
    }
    getTextureSource(loader, lookupId) {
        // Check if texture source is already known.
        let textureSource = lookupId ? this.textureSourceHashmap.get(lookupId) : undefined;
        if (!textureSource) {
            // Create new texture source.
            textureSource = new TextureSource_1.TextureSource(this, loader);
            if (lookupId) {
                textureSource.lookupId = lookupId;
                this.textureSourceHashmap.set(lookupId, textureSource);
            }
        }
        return textureSource;
    }
    uploadTextureSource(textureSource, options) {
        if (textureSource.isLoaded())
            return;
        this._addMemoryUsage(textureSource.w * textureSource.h);
        // Load texture.
        const nativeTexture = this._nativeUploadTextureSource(textureSource, options);
        textureSource._nativeTexture = nativeTexture;
        // We attach w and h to native texture (we need it in CoreRenderState._isRenderTextureReusable).
        nativeTexture.w = textureSource.w;
        nativeTexture.h = textureSource.h;
        nativeTexture.updateFrame = this.stage.frameCounter;
        this._uploadedTextureSources.push(textureSource);
        this.addToLookupMap(textureSource);
    }
    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    addToLookupMap(textureSource) {
        const lookupId = textureSource.lookupId;
        if (lookupId) {
            if (!this.textureSourceHashmap.has(lookupId)) {
                this.textureSourceHashmap.set(lookupId, textureSource);
            }
        }
    }
    gc() {
        this.freeUnusedTextureSources();
        this._cleanupLookupMap();
    }
    freeUnusedTextureSources() {
        const remainingTextureSources = [];
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            const ts = this._uploadedTextureSources[i];
            if (ts.allowCleanup()) {
                this._freeManagedTextureSource(ts);
            }
            else {
                remainingTextureSources.push(ts);
            }
        }
        this._uploadedTextureSources = remainingTextureSources;
        this._cleanupLookupMap();
    }
    _freeManagedTextureSource(textureSource) {
        if (textureSource.isLoaded()) {
            this._nativeFreeTextureSource(textureSource);
            this._addMemoryUsage(-textureSource.w * textureSource.h);
        }
        // Should be reloaded.
        textureSource.setNotLoaded();
    }
    _cleanupLookupMap() {
        // We keep those that still have value (are being loaded or already loaded, or are likely to be reused).
        this.textureSourceHashmap.forEach((textureSource, lookupId) => {
            if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                this.textureSourceHashmap.delete(lookupId);
            }
        });
    }
    freeTextureSource(textureSource) {
        const index = this._uploadedTextureSources.indexOf(textureSource);
        const managed = index !== -1;
        if (textureSource.isLoaded()) {
            if (managed) {
                this._addMemoryUsage(-textureSource.w * textureSource.h);
                this._uploadedTextureSources.splice(index, 1);
            }
            this._nativeFreeTextureSource(textureSource);
        }
        // Should be reloaded.
        textureSource.setNotLoaded();
    }
    _nativeUploadTextureSource(textureSource, options) {
        return this.stage.renderer.uploadTextureSource(textureSource, options);
    }
    _nativeFreeTextureSource(textureSource) {
        this.stage.renderer.freeTextureSource(textureSource);
        textureSource.clearNativeTexture();
    }
    getStage() {
        return this.stage;
    }
}
exports.TextureManager = TextureManager;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CoreContext {
    constructor(stage) {
        this.stage = stage;
        this.root = undefined;
        this.updateTreeOrder = 0;
        this.renderState = this.stage.renderer.createCoreRenderState(this);
        this.renderExecutor = this.stage.renderer.createCoreRenderExecutor(this);
        this._usedMemory = 0;
        this._renderTexturePool = [];
        this._renderTextureId = 1;
        this._zSorts = [];
    }
    get usedMemory() {
        return this._usedMemory;
    }
    destroy() {
        this._renderTexturePool.forEach((texture) => this._freeRenderTexture(texture));
        this._usedMemory = 0;
    }
    getRootParent() {
        return this.root.getParent();
    }
    hasRenderUpdates() {
        return this.getRootParent().hasRenderUpdates();
    }
    clearRenderUpdatesFlag() {
        this.getRootParent().clearHasRenderUpdates();
    }
    setRenderUpdatesFlag() {
        this.getRootParent().setHasRenderUpdates(1);
    }
    render() {
        this._render();
    }
    updateAndRender() {
        this.clearRenderUpdatesFlag();
        this.update();
        this.render();
    }
    update() {
        this._update();
        // Due to the boundsVisibility flag feature (and onAfterUpdate hook), it is possible that other elements were
        // changed during the update loop (for example due to the txLoaded event). We process these changes immediately
        // (but not recursively to prevent infinite loops).
        if (this.root.hasUpdates()) {
            this._update();
        }
        this._performForcedZSorts();
    }
    /**
     * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
     */
    _performForcedZSorts() {
        const n = this._zSorts.length;
        if (n) {
            // Forced z-sorts (ElementCore may force a z-sort in order to free memory/prevent memory leaks).
            for (let i = 0; i < n; i++) {
                if (this._zSorts[i].zSort) {
                    this._zSorts[i].sortZIndexedChildren();
                }
            }
            this._zSorts = [];
        }
    }
    _update() {
        this.updateTreeOrder = 0;
        this.root.update();
    }
    _render() {
        // Obtain a sequence of the quad operations.
        this._fillRenderState();
        // Now run them with the render executor.
        this._performRender();
    }
    _fillRenderState() {
        this.renderState.reset();
        this.root.render();
        this.renderState.finish();
    }
    _performRender() {
        this.renderExecutor.execute();
    }
    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    allocateRenderTexture(w, h) {
        const prec = this.stage.getPixelRatio();
        const pw = Math.max(1, Math.round(w * prec));
        const ph = Math.max(1, Math.round(h * prec));
        // Search last item first, so that last released render texture is preferred (may cause memory cache benefits).
        const n = this._renderTexturePool.length;
        for (let i = n - 1; i >= 0; i--) {
            const texture = this._renderTexturePool[i];
            // We don't want to reuse the same render textures within the same frame because that will create gpu stalls.
            if (texture.w === pw && texture.h === ph && texture.updateFrame !== this.stage.frameCounter) {
                texture.f = this.stage.frameCounter;
                this._renderTexturePool.splice(i, 1);
                return texture;
            }
        }
        const renderTexture = this._createRenderTexture(w, h, pw, ph);
        renderTexture.pixelRatio = prec;
        return renderTexture;
    }
    releaseRenderTexture(texture) {
        this._renderTexturePool.push(texture);
    }
    freeUnusedRenderTextures(maxAge = 60) {
        // Clean up all textures that are no longer used.
        // This cache is short-lived because it is really just meant to supply running shaders that are
        // updated during a number of frames.
        const limit = this.stage.frameCounter - maxAge;
        this._renderTexturePool = this._renderTexturePool.filter((texture) => {
            if (texture.f <= limit) {
                this._freeRenderTexture(texture);
                return false;
            }
            return true;
        });
    }
    _createRenderTexture(w, h, pw, ph) {
        this._addMemoryUsage(pw * ph);
        const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
        texture._id = this._renderTextureId++;
        texture.f = this.stage.frameCounter;
        texture.ow = w;
        texture.oh = h;
        texture.w = pw;
        texture.h = ph;
        return texture;
    }
    _freeRenderTexture(renderTexture) {
        this.stage.renderer.freeRenderTexture(renderTexture);
        this._addMemoryUsage(-renderTexture.w * renderTexture.h);
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
        this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
    }
    forceZSort(elementCore) {
        this._zSorts.push(elementCore);
    }
}
exports.CoreContext = CoreContext;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeUtils_1 = __webpack_require__(11);
class TextTextureSettings {
    constructor(onChange) {
        this.onChange = onChange;
        this.textSettings = {};
    }
    get "font-size"() {
        return this.textSettings.fontSize || 40;
    }
    set "font-size"(v) {
        this.textSettings.fontSize = TypeUtils_1.ensureFloat(v);
        this.onChange();
    }
    get "font-style"() {
        return this.textSettings.fontStyle || "normal";
    }
    set "font-style"(v) {
        this.textSettings.fontStyle = v;
        this.onChange();
    }
    get "font-weight"() {
        return this.textSettings.fontWeight || 400;
    }
    set "font-weight"(v) {
        this.textSettings.fontWeight = TypeUtils_1.ensureFloat(v);
        this.onChange();
    }
    get "font-face"() {
        return this.textSettings.fontFace || [];
    }
    set "font-face"(v) {
        if (!Array.isArray(v)) {
            v = [v];
        }
        this.textSettings.fontFace = v;
        this.onChange();
    }
}
exports.TextTextureSettings = TextTextureSettings;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Delegator {
    static delegate(base, delegate, property) {
        const descriptors = Object.getOwnPropertyDescriptors(delegate.prototype);
        const names = Object.keys(descriptors);
        for (let i = 0, n = names.length; i < n; i++) {
            const name = names[i];
            if (name !== "constructor") {
                this.delegateProperty(name, descriptors[name], base.prototype, property);
            }
        }
    }
    static delegateProperty(name, descriptor, obj, objProperty) {
        const proxyDescriptor = Object.assign({}, descriptor);
        if (proxyDescriptor.get) {
            proxyDescriptor.get = function () {
                return this[objProperty][name];
            };
        }
        if (proxyDescriptor.set) {
            proxyDescriptor.set = function (v) {
                this[objProperty][name] = v;
            };
        }
        if (proxyDescriptor.value && proxyDescriptor.value instanceof Function) {
            proxyDescriptor.value = function (...args) {
                return this[objProperty][name](...args);
            };
        }
        Object.defineProperty(obj, name, proxyDescriptor);
    }
}
exports.Delegator = Delegator;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = __webpack_require__(18);
const TypeUtils_1 = __webpack_require__(11);
const tree2d_1 = __webpack_require__(4);
const textures_1 = __webpack_require__(9);
const Delegator_1 = __webpack_require__(58);
class Paragraph extends Node_1.Node {
    constructor(stage) {
        super(stage);
        this.settings = new textures_1.TextTextureSettings(() => this.update());
        this._text = "";
        this._lineHeight = 0;
        this._fontColor = 0xffffffff;
        this.el.flex = true;
        this.el.flexWrap = true;
    }
    get "line-height"() {
        return this._lineHeight;
    }
    set "line-height"(v) {
        this._lineHeight = TypeUtils_1.ensureFloat(v);
        this.update();
    }
    get "font-color"() {
        return this._fontColor;
    }
    set "font-color"(v) {
        this._fontColor = TypeUtils_1.ensureColor(v);
        this.update();
    }
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
        this.update();
    }
    setElementText(text) {
        this._text = text.trim();
        this.update();
    }
    update() {
        const s = this.settings.textSettings;
        const fontSize = s.fontSize || 24;
        const lineHeight = Math.round(this._lineHeight || fontSize * 1.3);
        const letterSpacing = Math.round(fontSize * 0.2);
        const margin = Math.round(lineHeight - fontSize);
        const fontColor = this._fontColor || 0xffffffff;
        const text = this._text.replace(/(\r?\n)/, ` ${Paragraph.newlinePattern} `);
        const words = text.split(/\s+/);
        if (words.length > 1 || words[0] != "") {
            const els = words.map((word) => {
                const el = new tree2d_1.Element(this.stage);
                if (word === Paragraph.newlinePattern) {
                    // Force line break.
                    el.funcW = (w) => w;
                    el.h = 0;
                }
                else {
                    const texture = new tree2d_1.TextTexture(this.stage);
                    texture.text = word;
                    texture.setSettings(s);
                    el.texture = texture;
                    el.marginRight = letterSpacing;
                    el.marginTop = Math.round(margin * 0.8);
                    el.marginBottom = Math.round(margin * 0.2);
                    el.color = fontColor;
                }
                return el;
            });
            this.el.childList.setItems(els);
        }
    }
}
exports.Paragraph = Paragraph;
Paragraph.newlinePattern = "@+~^";
Delegator_1.Delegator.delegate(Paragraph, textures_1.TextTextureSettings, "settings");


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function mixin(target, source) {
    Object.getOwnPropertyNames(source.prototype).forEach((name) => {
        Object.defineProperty(target.prototype, name, Object.getOwnPropertyDescriptor(source.prototype, name));
    });
}
exports.mixin = mixin;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const mixin_1 = __webpack_require__(60);
const DirectContainer_1 = __webpack_require__(35);
const Container_1 = __webpack_require__(6);
class DirectContainerMixin extends Container_1.Container {
    _appendChild(child) {
        // Ignore virtual dom operations.
    }
    _removeChild(child) {
        // Ignore virtual dom operations.
    }
    _insertBefore(child, anchor) {
        // Ignore virtual dom operations.
    }
    add(item) {
        item.parent = this;
        this.containerElement.childList.add(item.el);
    }
    itemInList(item) {
        return this.containerElement.childList.itemInList(item.el);
    }
    addAt(item, index) {
        item.parent = this;
        return this.containerElement.childList.addAt(item.el, index);
    }
    replace(item, prevItem) {
        return this.containerElement.childList.replace(item.el, prevItem.el);
    }
    setAt(item, index) {
        item.parent = this;
        this.containerElement.childList.setAt(item.el, index);
    }
    getAt(index) {
        const el = this.containerElement.childList.getAt(index);
        return el ? el.data : undefined;
    }
    getIndex(item) {
        return this.containerElement.childList.getIndex(item.el);
    }
    getByRef(ref) {
        var _a;
        return (_a = this.containerElement.childList.getByRef(ref)) === null || _a === void 0 ? void 0 : _a.data;
    }
    remove(item) {
        item.parent = undefined;
        this.containerElement.childList.remove(item.el);
    }
    removeAt(index) {
        const item = this.containerElement.childList.removeAt(index);
        item.data.parent = undefined;
    }
    clear() {
        this.containerElement.childList.getItems().forEach((item) => (item.data.parent = undefined));
        this.containerElement.childList.clear();
    }
    getChildren() {
        return this.containerElement.childList.getItems().map((element) => element.data);
    }
    getDirectChildren() {
        return this.getChildren();
    }
    setItems(items) {
        const [removed, added] = this.containerElement.childList.setItems(items.map((item) => item.el));
        items.forEach((item) => (item.parent = this));
        return [removed.map((e) => e.data), added.map((e) => e.data)];
    }
}
exports.DirectContainerMixin = DirectContainerMixin;
function getDirectType(nodeType) {
    if (nodeType.prototype instanceof Container_1.Container) {
        if (!nodeType.__direct) {
            // Create subclass.
            const directType = class extends nodeType {
            };
            mixin_1.mixin(directType, DirectContainer_1.DirectContainer);
            nodeType.__direct = directType;
        }
        return nodeType.__direct;
    }
    else if (nodeType === Container_1.Container) {
        return DirectContainer_1.DirectContainer;
    }
    else {
        return nodeType;
    }
}
exports.getDirectType = getDirectType;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const runtime_core_1 = __webpack_require__(3);
const compile_1 = __webpack_require__(36);
const runtimeVugel = __webpack_require__(21);
const compileCache = Object.create(null);
function compileVugel(template, options) {
    if (!(typeof template === "string")) {
        if (template.nodeType) {
            template = template.innerHTML;
        }
        else {
            runtime_core_1.warn(`invalid template option: `, template);
            return () => {
                // Noop
            };
        }
    }
    const key = template;
    const cached = compileCache[key];
    if (cached) {
        return cached;
    }
    if (template[0] === "#") {
        const el = document.querySelector(template);
        if (!el) {
            runtime_core_1.warn(`Template element not found or is empty: ${template}`);
        }
        template = el ? el.innerHTML : ``;
    }
    const { code } = compile_1.compile(template, Object.assign({ hoistStatic: true, onError(err) {
            const message = `Template compilation error: ${err.message}`;
            const codeFrame = err.loc;
            runtime_core_1.warn(codeFrame ? `${message}\n${codeFrame}` : message);
        } }, options));
    const render = new Function("Vue", code)(runtimeVugel);
    return (compileCache[key] = render);
}
exports.compileVugel = compileVugel;


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BASE_TRANSITION", function() { return BASE_TRANSITION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CAMELIZE", function() { return CAMELIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_BLOCK", function() { return CREATE_BLOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_COMMENT", function() { return CREATE_COMMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_SLOTS", function() { return CREATE_SLOTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_STATIC", function() { return CREATE_STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_TEXT", function() { return CREATE_TEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATE_VNODE", function() { return CREATE_VNODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT", function() { return FRAGMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KEEP_ALIVE", function() { return KEEP_ALIVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MERGE_PROPS", function() { return MERGE_PROPS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPEN_BLOCK", function() { return OPEN_BLOCK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POP_SCOPE_ID", function() { return POP_SCOPE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PUSH_SCOPE_ID", function() { return PUSH_SCOPE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RENDER_LIST", function() { return RENDER_LIST; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RENDER_SLOT", function() { return RENDER_SLOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVE_COMPONENT", function() { return RESOLVE_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVE_DIRECTIVE", function() { return RESOLVE_DIRECTIVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVE_DYNAMIC_COMPONENT", function() { return RESOLVE_DYNAMIC_COMPONENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SET_BLOCK_TRACKING", function() { return SET_BLOCK_TRACKING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUSPENSE", function() { return SUSPENSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TELEPORT", function() { return TELEPORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TO_DISPLAY_STRING", function() { return TO_DISPLAY_STRING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TO_HANDLERS", function() { return TO_HANDLERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WITH_CTX", function() { return WITH_CTX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WITH_DIRECTIVES", function() { return WITH_DIRECTIVES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WITH_SCOPE_ID", function() { return WITH_SCOPE_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "advancePositionWithClone", function() { return advancePositionWithClone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "advancePositionWithMutation", function() { return advancePositionWithMutation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "baseCompile", function() { return baseCompile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "baseParse", function() { return baseParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildProps", function() { return buildProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildSlots", function() { return buildSlots; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createArrayExpression", function() { return createArrayExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAssignmentExpression", function() { return createAssignmentExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBlockStatement", function() { return createBlockStatement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCacheExpression", function() { return createCacheExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCallExpression", function() { return createCallExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCompilerError", function() { return createCompilerError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCompoundExpression", function() { return createCompoundExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConditionalExpression", function() { return createConditionalExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForLoopParams", function() { return createForLoopParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFunctionExpression", function() { return createFunctionExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIfStatement", function() { return createIfStatement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createInterpolation", function() { return createInterpolation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createObjectExpression", function() { return createObjectExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createObjectProperty", function() { return createObjectProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReturnStatement", function() { return createReturnStatement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRoot", function() { return createRoot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSequenceExpression", function() { return createSequenceExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSimpleExpression", function() { return createSimpleExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStructuralDirectiveTransform", function() { return createStructuralDirectiveTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTemplateLiteral", function() { return createTemplateLiteral; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformContext", function() { return createTransformContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createVNodeCall", function() { return createVNodeCall; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDir", function() { return findDir; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findProp", function() { return findProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generate", function() { return generate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBaseTransformPreset", function() { return getBaseTransformPreset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInnerRange", function() { return getInnerRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasDynamicKeyVBind", function() { return hasDynamicKeyVBind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasScopeRef", function() { return hasScopeRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "helperNameMap", function() { return helperNameMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "injectProp", function() { return injectProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBindKey", function() { return isBindKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuiltInType", function() { return isBuiltInType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCoreComponent", function() { return isCoreComponent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMemberExpression", function() { return isMemberExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSimpleIdentifier", function() { return isSimpleIdentifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSlotOutlet", function() { return isSlotOutlet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTemplateNode", function() { return isTemplateNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isText", function() { return isText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVSlot", function() { return isVSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locStub", function() { return locStub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noopDirectiveTransform", function() { return noopDirectiveTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseJS", function() { return parseJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processExpression", function() { return processExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processFor", function() { return processFor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processIf", function() { return processIf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processSlotOutlet", function() { return processSlotOutlet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerRuntimeHelpers", function() { return registerRuntimeHelpers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveComponentType", function() { return resolveComponentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toValidAssetId", function() { return toValidAssetId; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackSlotScopes", function() { return trackSlotScopes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trackVForSlotScopes", function() { return trackVForSlotScopes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformBind", function() { return transformBind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformElement", function() { return transformElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExpression", function() { return transformExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformModel", function() { return transformModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformOn", function() { return transformOn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "traverseNode", function() { return traverseNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "walkJS", function() { return walkJS; });
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generateCodeFrame", function() { return _vue_shared__WEBPACK_IMPORTED_MODULE_0__["generateCodeFrame"]; });




function defaultOnError(error) {
    throw error;
}
function createCompilerError(code, loc, messages, additionalMessage) {
    const msg =  false
        ? undefined
        : code;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
}
const errorMessages = {
    // parse errors
    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
    [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
    // Vue-specific parse errors
    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
        'Note that dynamic directive argument cannot contain spaces.',
    // transform errors
    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
    [28 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
    [29 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
    [30 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
    [31 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
    [32 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
    [33 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
    [34 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
        `When there are multiple named slots, all slots should use <template> ` +
        `syntax to avoid scope ambiguity.`,
    [35 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
    [36 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
        `default slot. These children will be ignored.`,
    [37 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
    [38 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
    [39 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
    [40 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
    [41 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
    [42 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
    // generic errors
    [43 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
    [44 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
    [45 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
    [46 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`
};

const FRAGMENT = Symbol(( false) ? undefined : ``);
const TELEPORT = Symbol(( false) ? undefined : ``);
const SUSPENSE = Symbol(( false) ? undefined : ``);
const KEEP_ALIVE = Symbol(( false) ? undefined : ``);
const BASE_TRANSITION = Symbol(( false) ? undefined : ``);
const OPEN_BLOCK = Symbol(( false) ? undefined : ``);
const CREATE_BLOCK = Symbol(( false) ? undefined : ``);
const CREATE_VNODE = Symbol(( false) ? undefined : ``);
const CREATE_COMMENT = Symbol(( false) ? undefined : ``);
const CREATE_TEXT = Symbol(( false) ? undefined : ``);
const CREATE_STATIC = Symbol(( false) ? undefined : ``);
const RESOLVE_COMPONENT = Symbol(( false) ? undefined : ``);
const RESOLVE_DYNAMIC_COMPONENT = Symbol(( false) ? undefined : ``);
const RESOLVE_DIRECTIVE = Symbol(( false) ? undefined : ``);
const WITH_DIRECTIVES = Symbol(( false) ? undefined : ``);
const RENDER_LIST = Symbol(( false) ? undefined : ``);
const RENDER_SLOT = Symbol(( false) ? undefined : ``);
const CREATE_SLOTS = Symbol(( false) ? undefined : ``);
const TO_DISPLAY_STRING = Symbol(( false) ? undefined : ``);
const MERGE_PROPS = Symbol(( false) ? undefined : ``);
const TO_HANDLERS = Symbol(( false) ? undefined : ``);
const CAMELIZE = Symbol(( false) ? undefined : ``);
const SET_BLOCK_TRACKING = Symbol(( false) ? undefined : ``);
const PUSH_SCOPE_ID = Symbol(( false) ? undefined : ``);
const POP_SCOPE_ID = Symbol(( false) ? undefined : ``);
const WITH_SCOPE_ID = Symbol(( false) ? undefined : ``);
const WITH_CTX = Symbol(( false) ? undefined : ``);
// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
const helperNameMap = {
    [FRAGMENT]: `Fragment`,
    [TELEPORT]: `Teleport`,
    [SUSPENSE]: `Suspense`,
    [KEEP_ALIVE]: `KeepAlive`,
    [BASE_TRANSITION]: `BaseTransition`,
    [OPEN_BLOCK]: `openBlock`,
    [CREATE_BLOCK]: `createBlock`,
    [CREATE_VNODE]: `createVNode`,
    [CREATE_COMMENT]: `createCommentVNode`,
    [CREATE_TEXT]: `createTextVNode`,
    [CREATE_STATIC]: `createStaticVNode`,
    [RESOLVE_COMPONENT]: `resolveComponent`,
    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
    [RESOLVE_DIRECTIVE]: `resolveDirective`,
    [WITH_DIRECTIVES]: `withDirectives`,
    [RENDER_LIST]: `renderList`,
    [RENDER_SLOT]: `renderSlot`,
    [CREATE_SLOTS]: `createSlots`,
    [TO_DISPLAY_STRING]: `toDisplayString`,
    [MERGE_PROPS]: `mergeProps`,
    [TO_HANDLERS]: `toHandlers`,
    [CAMELIZE]: `camelize`,
    [SET_BLOCK_TRACKING]: `setBlockTracking`,
    [PUSH_SCOPE_ID]: `pushScopeId`,
    [POP_SCOPE_ID]: `popScopeId`,
    [WITH_SCOPE_ID]: `withScopeId`,
    [WITH_CTX]: `withCtx`
};
function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach(s => {
        helperNameMap[s] = helpers[s];
    });
}

// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
const locStub = {
    source: '',
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 }
};
function createRoot(children, loc = locStub) {
    return {
        type: 0 /* ROOT */,
        children,
        helpers: [],
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: 0,
        temps: 0,
        codegenNode: undefined,
        loc
    };
}
function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, isForBlock = false, loc = locStub) {
    if (context) {
        if (isBlock) {
            context.helper(OPEN_BLOCK);
            context.helper(CREATE_BLOCK);
        }
        else {
            context.helper(CREATE_VNODE);
        }
        if (directives) {
            context.helper(WITH_DIRECTIVES);
        }
    }
    return {
        type: 13 /* VNODE_CALL */,
        tag,
        props,
        children,
        patchFlag,
        dynamicProps,
        directives,
        isBlock,
        isForBlock,
        loc
    };
}
function createArrayExpression(elements, loc = locStub) {
    return {
        type: 17 /* JS_ARRAY_EXPRESSION */,
        loc,
        elements
    };
}
function createObjectExpression(properties, loc = locStub) {
    return {
        type: 15 /* JS_OBJECT_EXPRESSION */,
        loc,
        properties
    };
}
function createObjectProperty(key, value) {
    return {
        type: 16 /* JS_PROPERTY */,
        loc: locStub,
        key: Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(key) ? createSimpleExpression(key, true) : key,
        value
    };
}
function createSimpleExpression(content, isStatic, loc = locStub, isConstant = false) {
    return {
        type: 4 /* SIMPLE_EXPRESSION */,
        loc,
        isConstant,
        content,
        isStatic
    };
}
function createInterpolation(content, loc) {
    return {
        type: 5 /* INTERPOLATION */,
        loc,
        content: Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(content)
            ? createSimpleExpression(content, false, loc)
            : content
    };
}
function createCompoundExpression(children, loc = locStub) {
    return {
        type: 8 /* COMPOUND_EXPRESSION */,
        loc,
        children
    };
}
function createCallExpression(callee, args = [], loc = locStub) {
    return {
        type: 14 /* JS_CALL_EXPRESSION */,
        loc,
        callee,
        arguments: args
    };
}
function createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {
    return {
        type: 18 /* JS_FUNCTION_EXPRESSION */,
        params,
        returns,
        newline,
        isSlot,
        loc
    };
}
function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
        type: 19 /* JS_CONDITIONAL_EXPRESSION */,
        test,
        consequent,
        alternate,
        newline,
        loc: locStub
    };
}
function createCacheExpression(index, value, isVNode = false) {
    return {
        type: 20 /* JS_CACHE_EXPRESSION */,
        index,
        value,
        isVNode,
        loc: locStub
    };
}
function createBlockStatement(body) {
    return {
        type: 21 /* JS_BLOCK_STATEMENT */,
        body,
        loc: locStub
    };
}
function createTemplateLiteral(elements) {
    return {
        type: 22 /* JS_TEMPLATE_LITERAL */,
        elements,
        loc: locStub
    };
}
function createIfStatement(test, consequent, alternate) {
    return {
        type: 23 /* JS_IF_STATEMENT */,
        test,
        consequent,
        alternate,
        loc: locStub
    };
}
function createAssignmentExpression(left, right) {
    return {
        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,
        left,
        right,
        loc: locStub
    };
}
function createSequenceExpression(expressions) {
    return {
        type: 25 /* JS_SEQUENCE_EXPRESSION */,
        expressions,
        loc: locStub
    };
}
function createReturnStatement(returns) {
    return {
        type: 26 /* JS_RETURN_STATEMENT */,
        returns,
        loc: locStub
    };
}

const isBuiltInType = (tag, expected) => tag === expected || tag === Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["hyphenate"])(expected);
function isCoreComponent(tag) {
    if (isBuiltInType(tag, 'Teleport')) {
        return TELEPORT;
    }
    else if (isBuiltInType(tag, 'Suspense')) {
        return SUSPENSE;
    }
    else if (isBuiltInType(tag, 'KeepAlive')) {
        return KEEP_ALIVE;
    }
    else if (isBuiltInType(tag, 'BaseTransition')) {
        return BASE_TRANSITION;
    }
}
const parseJS = (code, options) => {
    {
        assert(!true, `Expression AST analysis can only be performed in non-browser builds.`);
        return null;
    }
};
const walkJS = (ast, walker) => {
    {
        assert(!true, `Expression AST analysis can only be performed in non-browser builds.`);
        return null;
    }
};
const nonIdentifierRE = /^\d|[^\$\w]/;
const isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
const memberExpRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\[[^\]]+\])*$/;
const isMemberExpression = (path) => memberExpRE.test(path);
function getInnerRange(loc, offset, length) {
    const source = loc.source.substr(offset, length);
    const newLoc = {
        source,
        start: advancePositionWithClone(loc.start, loc.source, offset),
        end: loc.end
    };
    if (length != null) {
        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
    }
    return newLoc;
}
function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation({ ...pos }, source, numberOfCharacters);
}
// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
        if (source.charCodeAt(i) === 10 /* newline char code */) {
            linesCount++;
            lastNewLinePos = i;
        }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column =
        lastNewLinePos === -1
            ? pos.column + numberOfCharacters
            : numberOfCharacters - lastNewLinePos;
    return pos;
}
function assert(condition, msg) {
    /* istanbul ignore if */
    if (!condition) {
        throw new Error(msg || `unexpected compiler condition`);
    }
}
function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 7 /* DIRECTIVE */ &&
            (allowEmpty || p.exp) &&
            (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(name) ? p.name === name : name.test(p.name))) {
            return p;
        }
    }
}
function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
        const p = node.props[i];
        if (p.type === 6 /* ATTRIBUTE */) {
            if (dynamicOnly)
                continue;
            if (p.name === name && (p.value || allowEmpty)) {
                return p;
            }
        }
        else if (p.name === 'bind' && p.exp && isBindKey(p.arg, name)) {
            return p;
        }
    }
}
function isBindKey(arg, name) {
    return !!(arg &&
        arg.type === 4 /* SIMPLE_EXPRESSION */ &&
        arg.isStatic &&
        arg.content === name);
}
function hasDynamicKeyVBind(node) {
    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
        p.name === 'bind' &&
        (!p.arg || // v-bind="obj"
            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
            !p.arg.isStatic) // v-bind:[foo]
    );
}
function isText(node) {
    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
}
function isVSlot(p) {
    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
}
function isTemplateNode(node) {
    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
}
function isSlotOutlet(node) {
    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
}
function injectProp(node, prop, context) {
    let propsWithInjection;
    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
    if (props == null || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(props)) {
        propsWithInjection = createObjectExpression([prop]);
    }
    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
        // merged props... add ours
        // only inject key to object literal if it's the first argument so that
        // if doesn't override user provided keys
        const first = props.arguments[0];
        if (!Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {
            first.properties.unshift(prop);
        }
        else {
            props.arguments.unshift(createObjectExpression([prop]));
        }
        propsWithInjection = props;
    }
    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {
        let alreadyExists = false;
        // check existing key to avoid overriding user provided keys
        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {
            const propKeyName = prop.key.content;
            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
                p.key.content === propKeyName);
        }
        if (!alreadyExists) {
            props.properties.unshift(prop);
        }
        propsWithInjection = props;
    }
    else {
        // single v-bind with expression, return a merged replacement
        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props
        ]);
    }
    if (node.type === 13 /* VNODE_CALL */) {
        node.props = propsWithInjection;
    }
    else {
        node.arguments[2] = propsWithInjection;
    }
}
function toValidAssetId(name, type) {
    return `_${type}_${name.replace(/[^\w]/g, '_')}`;
}
// Check if a node contains expressions that reference current context scope ids
function hasScopeRef(node, ids) {
    if (!node || Object.keys(ids).length === 0) {
        return false;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
            for (let i = 0; i < node.props.length; i++) {
                const p = node.props[i];
                if (p.type === 7 /* DIRECTIVE */ &&
                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {
                    return true;
                }
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 11 /* FOR */:
            if (hasScopeRef(node.source, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 9 /* IF */:
            return node.branches.some(b => hasScopeRef(b, ids));
        case 10 /* IF_BRANCH */:
            if (hasScopeRef(node.condition, ids)) {
                return true;
            }
            return node.children.some(c => hasScopeRef(c, ids));
        case 4 /* SIMPLE_EXPRESSION */:
            return (!node.isStatic &&
                isSimpleIdentifier(node.content) &&
                !!ids[node.content]);
        case 8 /* COMPOUND_EXPRESSION */:
            return node.children.some(c => Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(c) && hasScopeRef(c, ids));
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return hasScopeRef(node.content, ids);
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return false;
        default:
            if ((false)) {}
            return false;
    }
}

// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
const defaultParserOptions = {
    delimiters: [`{{`, `}}`],
    getNamespace: () => 0 /* HTML */,
    getTextMode: () => 0 /* DATA */,
    isVoidTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__["NO"],
    isPreTag: _vue_shared__WEBPACK_IMPORTED_MODULE_0__["NO"],
    isCustomElement: _vue_shared__WEBPACK_IMPORTED_MODULE_0__["NO"],
    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
    onError: defaultOnError
};
function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
}
function createParserContext(content, options) {
    return {
        options: {
            ...defaultParserOptions,
            ...options
        },
        column: 1,
        line: 1,
        offset: 0,
        originalSource: content,
        source: content,
        inPre: false,
        inVPre: false
    };
}
function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0 /* HTML */;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
        const s = context.source;
        let node = undefined;
        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                // '{{'
                node = parseInterpolation(context, mode);
            }
            else if (mode === 0 /* DATA */ && s[0] === '<') {
                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                if (s.length === 1) {
                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                }
                else if (s[1] === '!') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                    if (startsWith(s, '<!--')) {
                        node = parseComment(context);
                    }
                    else if (startsWith(s, '<!DOCTYPE')) {
                        // Ignore DOCTYPE by a limitation.
                        node = parseBogusComment(context);
                    }
                    else if (startsWith(s, '<![CDATA[')) {
                        if (ns !== 0 /* HTML */) {
                            node = parseCDATA(context, ancestors);
                        }
                        else {
                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                            node = parseBogusComment(context);
                        }
                    }
                    else {
                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                        node = parseBogusComment(context);
                    }
                }
                else if (s[1] === '/') {
                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                    if (s.length === 2) {
                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                    }
                    else if (s[2] === '>') {
                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                        advanceBy(context, 3);
                        continue;
                    }
                    else if (/[a-z]/i.test(s[2])) {
                        emitError(context, 23 /* X_INVALID_END_TAG */);
                        parseTag(context, 1 /* End */, parent);
                        continue;
                    }
                    else {
                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                        node = parseBogusComment(context);
                    }
                }
                else if (/[a-z]/i.test(s[1])) {
                    node = parseElement(context, ancestors);
                }
                else if (s[1] === '?') {
                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                    node = parseBogusComment(context);
                }
                else {
                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                }
            }
        }
        if (!node) {
            node = parseText(context, mode);
        }
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(node)) {
            for (let i = 0; i < node.length; i++) {
                pushNode(nodes, node[i]);
            }
        }
        else {
            pushNode(nodes, node);
        }
    }
    // Whitespace management for more efficient output
    // (same as v2 whitespace: 'condense')
    let removedWhitespace = false;
    if (mode !== 2 /* RAWTEXT */) {
        if (!context.inPre) {
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.type === 2 /* TEXT */) {
                    if (!/[^\t\r\n\f ]/.test(node.content)) {
                        const prev = nodes[i - 1];
                        const next = nodes[i + 1];
                        // If:
                        // - the whitespace is the first or last node, or:
                        // - the whitespace is adjacent to a comment, or:
                        // - the whitespace is between two elements AND contains newline
                        // Then the whitespace is ignored.
                        if (!prev ||
                            !next ||
                            prev.type === 3 /* COMMENT */ ||
                            next.type === 3 /* COMMENT */ ||
                            (prev.type === 1 /* ELEMENT */ &&
                                next.type === 1 /* ELEMENT */ &&
                                /[\r\n]/.test(node.content))) {
                            removedWhitespace = true;
                            nodes[i] = null;
                        }
                        else {
                            // Otherwise, condensed consecutive whitespace inside the text down to
                            // a single space
                            node.content = ' ';
                        }
                    }
                    else {
                        node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                    }
                }
            }
        }
        else if (parent && context.options.isPreTag(parent.tag)) {
            // remove leading newline per html spec
            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
            const first = nodes[0];
            if (first && first.type === 2 /* TEXT */) {
                first.content = first.content.replace(/^\r?\n/, '');
            }
        }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
}
function pushNode(nodes, node) {
    // ignore comments in production
    /* istanbul ignore next */
    if ( true && node.type === 3 /* COMMENT */) {
        return;
    }
    if (node.type === 2 /* TEXT */) {
        const prev = last(nodes);
        // Merge if both this and the previous node are text and those are
        // consecutive. This happens for cases like "a < b".
        if (prev &&
            prev.type === 2 /* TEXT */ &&
            prev.loc.end.offset === node.loc.start.offset) {
            prev.content += node.content;
            prev.loc.end = node.loc.end;
            prev.loc.source += node.loc.source;
            return;
        }
    }
    nodes.push(node);
}
function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
    if (context.source.length === 0) {
        emitError(context, 6 /* EOF_IN_CDATA */);
    }
    else {
        advanceBy(context, 3);
    }
    return nodes;
}
function parseComment(context) {
    const start = getCursor(context);
    let content;
    // Regular comment.
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
        content = context.source.slice(4);
        advanceBy(context, context.source.length);
        emitError(context, 7 /* EOF_IN_COMMENT */);
    }
    else {
        if (match.index <= 3) {
            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
        }
        if (match[1]) {
            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
        }
        content = context.source.slice(4, match.index);
        // Advancing with reporting nested comments.
        const s = context.source.slice(0, match.index);
        let prevIndex = 1, nestedIndex = 0;
        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
            advanceBy(context, nestedIndex - prevIndex + 1);
            if (nestedIndex + 4 < s.length) {
                emitError(context, 16 /* NESTED_COMMENT */);
            }
            prevIndex = nestedIndex + 1;
        }
        advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === '?' ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf('>');
    if (closeIndex === -1) {
        content = context.source.slice(contentStart);
        advanceBy(context, context.source.length);
    }
    else {
        content = context.source.slice(contentStart, closeIndex);
        advanceBy(context, closeIndex + 1);
    }
    return {
        type: 3 /* COMMENT */,
        content,
        loc: getSelection(context, start)
    };
}
function parseElement(context, ancestors) {
    // Start tag.
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0 /* Start */, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
        return element;
    }
    // Children.
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    element.children = children;
    // End tag.
    if (startsWithEndTagOpen(context.source, element.tag)) {
        parseTag(context, 1 /* End */, parent);
    }
    else {
        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
            const first = children[0];
            if (first && startsWith(first.loc.source, '<!--')) {
                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
            }
        }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
        context.inPre = false;
    }
    if (isVPreBoundary) {
        context.inVPre = false;
    }
    return element;
}
const isSpecialTemplateDirective = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["makeMap"])(`if,else,else-if,for,slot`);
/**
 * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).
 */
function parseTag(context, type, parent) {
    // Tag open.
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    // save current state in case we need to re-parse attributes with v-pre
    const cursor = getCursor(context);
    const currentSource = context.source;
    // Attributes.
    let props = parseAttributes(context, type);
    // check <pre> tag
    if (context.options.isPreTag(tag)) {
        context.inPre = true;
    }
    // check v-pre
    if (!context.inVPre &&
        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
        context.inVPre = true;
        // reset context
        Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["extend"])(context, cursor);
        context.source = currentSource;
        // re-parse attrs and filter out v-pre itself
        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
    }
    // Tag close.
    let isSelfClosing = false;
    if (context.source.length === 0) {
        emitError(context, 9 /* EOF_IN_TAG */);
    }
    else {
        isSelfClosing = startsWith(context.source, '/>');
        if (type === 1 /* End */ && isSelfClosing) {
            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
        }
        advanceBy(context, isSelfClosing ? 2 : 1);
    }
    let tagType = 0 /* ELEMENT */;
    const options = context.options;
    if (!context.inVPre && !options.isCustomElement(tag)) {
        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'is');
        if (options.isNativeTag && !hasVIs) {
            if (!options.isNativeTag(tag))
                tagType = 1 /* COMPONENT */;
        }
        else if (hasVIs ||
            isCoreComponent(tag) ||
            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
            /^[A-Z]/.test(tag) ||
            tag === 'component') {
            tagType = 1 /* COMPONENT */;
        }
        if (tag === 'slot') {
            tagType = 2 /* SLOT */;
        }
        else if (tag === 'template' &&
            props.some(p => {
                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));
            })) {
            tagType = 3 /* TEMPLATE */;
        }
    }
    return {
        type: 1 /* ELEMENT */,
        ns,
        tag,
        tagType,
        props,
        isSelfClosing,
        children: [],
        loc: getSelection(context, start),
        codegenNode: undefined // to be created during transform phase
    };
}
function parseAttributes(context, type) {
    const props = [];
    const attributeNames = new Set();
    while (context.source.length > 0 &&
        !startsWith(context.source, '>') &&
        !startsWith(context.source, '/>')) {
        if (startsWith(context.source, '/')) {
            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
            advanceBy(context, 1);
            advanceSpaces(context);
            continue;
        }
        if (type === 1 /* End */) {
            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
        }
        const attr = parseAttribute(context, attributeNames);
        if (type === 0 /* Start */) {
            props.push(attr);
        }
        if (/^[^\t\r\n\f />]/.test(context.source)) {
            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
        }
        advanceSpaces(context);
    }
    return props;
}
function parseAttribute(context, nameSet) {
    // Name.
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
    }
    nameSet.add(name);
    if (name[0] === '=') {
        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
    }
    {
        const pattern = /["'<]/g;
        let m;
        while ((m = pattern.exec(name))) {
            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
        }
    }
    advanceBy(context, name.length);
    // Value
    let value = undefined;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
        advanceSpaces(context);
        advanceBy(context, 1);
        advanceSpaces(context);
        value = parseAttributeValue(context);
        if (!value) {
            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
        }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)([^\.]+))?(.+)?$/i.exec(name);
        let arg;
        if (match[2]) {
            const startOffset = name.indexOf(match[2]);
            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length));
            let content = match[2];
            let isStatic = true;
            if (content.startsWith('[')) {
                isStatic = false;
                if (!content.endsWith(']')) {
                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                }
                content = content.substr(1, content.length - 2);
            }
            arg = {
                type: 4 /* SIMPLE_EXPRESSION */,
                content,
                isStatic,
                isConstant: isStatic,
                loc
            };
        }
        if (value && value.isQuoted) {
            const valueLoc = value.loc;
            valueLoc.start.offset++;
            valueLoc.start.column++;
            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
            valueLoc.source = valueLoc.source.slice(1, -1);
        }
        return {
            type: 7 /* DIRECTIVE */,
            name: match[1] ||
                (startsWith(name, ':')
                    ? 'bind'
                    : startsWith(name, '@')
                        ? 'on'
                        : 'slot'),
            exp: value && {
                type: 4 /* SIMPLE_EXPRESSION */,
                content: value.content,
                isStatic: false,
                // Treat as non-constant by default. This can be potentially set to
                // true by `transformExpression` to make it eligible for hoisting.
                isConstant: false,
                loc: value.loc
            },
            arg,
            modifiers: match[3] ? match[3].substr(1).split('.') : [],
            loc
        };
    }
    return {
        type: 6 /* ATTRIBUTE */,
        name,
        value: value && {
            type: 2 /* TEXT */,
            content: value.content,
            loc: value.loc
        },
        loc
    };
}
function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
        // Quoted value.
        advanceBy(context, 1);
        const endIndex = context.source.indexOf(quote);
        if (endIndex === -1) {
            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
        }
        else {
            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
            advanceBy(context, 1);
        }
    }
    else {
        // Unquoted
        const match = /^[^\t\r\n\f >]+/.exec(context.source);
        if (!match) {
            return undefined;
        }
        const unexpectedChars = /["'<=`]/g;
        let m;
        while ((m = unexpectedChars.exec(match[0]))) {
            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
        }
        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
}
function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
        return undefined;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
        advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
        type: 5 /* INTERPOLATION */,
        content: {
            type: 4 /* SIMPLE_EXPRESSION */,
            isStatic: false,
            // Set `isConstant` to false by default and will decide in transformExpression
            isConstant: false,
            content,
            loc: getSelection(context, innerStart, innerEnd)
        },
        loc: getSelection(context, start)
    };
}
function parseText(context, mode) {
    const endTokens = ['<', context.options.delimiters[0]];
    if (mode === 3 /* CDATA */) {
        endTokens.push(']]>');
    }
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
        const index = context.source.indexOf(endTokens[i], 1);
        if (index !== -1 && endIndex > index) {
            endIndex = index;
        }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
        type: 2 /* TEXT */,
        content,
        loc: getSelection(context, start)
    };
}
/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */
function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 /* RAWTEXT */ ||
        mode === 3 /* CDATA */ ||
        rawText.indexOf('&') === -1) {
        return rawText;
    }
    else {
        // DATA or RCDATA containing "&"". Entity decoding required.
        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
    }
}
function getCursor(context) {
    const { column, line, offset } = context;
    return { column, line, offset };
}
function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
        start,
        end,
        source: context.originalSource.slice(start.offset, end.offset)
    };
}
function last(xs) {
    return xs[xs.length - 1];
}
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
}
function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
        advanceBy(context, match[0].length);
    }
}
function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
}
function emitError(context, code, offset, loc = getCursor(context)) {
    if (offset) {
        loc.offset += offset;
        loc.column += offset;
    }
    context.options.onError(createCompilerError(code, {
        start: loc,
        end: loc,
        source: ''
    }));
}
function isEnd(context, mode, ancestors) {
    const s = context.source;
    switch (mode) {
        case 0 /* DATA */:
            if (startsWith(s, '</')) {
                //TODO: probably bad performance
                for (let i = ancestors.length - 1; i >= 0; --i) {
                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                        return true;
                    }
                }
            }
            break;
        case 1 /* RCDATA */:
        case 2 /* RAWTEXT */: {
            const parent = last(ancestors);
            if (parent && startsWithEndTagOpen(s, parent.tag)) {
                return true;
            }
            break;
        }
        case 3 /* CDATA */:
            if (startsWith(s, ']]>')) {
                return true;
            }
            break;
    }
    return !s;
}
function startsWithEndTagOpen(source, tag) {
    return (startsWith(source, '</') &&
        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
        /[\t\n\f />]/.test(source[2 + tag.length] || '>'));
}

function hoistStatic(root, context) {
    walk(root.children, context, new Map(), 
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    isSingleElementRoot(root, root.children[0]));
}
function isSingleElementRoot(root, child) {
    const { children } = root;
    return (children.length === 1 &&
        child.type === 1 /* ELEMENT */ &&
        !isSlotOutlet(child));
}
function walk(children, context, resultCache, doNotHoistNode = false) {
    let hasHoistedNode = false;
    // Some transforms, e.g. trasnformAssetUrls from @vue/compiler-sfc, replaces
    // static bindings with expressions. These expressions are guaranteed to be
    // constant so they are still eligible for hoisting, but they are only
    // available at runtime and therefore cannot be evaluated ahead of time.
    // This is only a concern for pre-stringification (via transformHoist by
    // @vue/compiler-dom), but doing it here allows us to perform only one full
    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
    // stringficiation threshold is met.
    let hasRuntimeConstant = false;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        // only plain elements & text calls are eligible for hoisting.
        if (child.type === 1 /* ELEMENT */ &&
            child.tagType === 0 /* ELEMENT */) {
            let staticType;
            if (!doNotHoistNode &&
                (staticType = getStaticType(child, resultCache)) > 0) {
                if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {
                    hasRuntimeConstant = true;
                }
                child.codegenNode.patchFlag =
                    -1 /* HOISTED */ + (( false) ? undefined : ``);
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
                continue;
            }
            else {
                // node may contain dynamic children, but its props may be eligible for
                // hoisting.
                const codegenNode = child.codegenNode;
                if (codegenNode.type === 13 /* VNODE_CALL */) {
                    const flag = getPatchFlag(codegenNode);
                    if ((!flag ||
                        flag === 512 /* NEED_PATCH */ ||
                        flag === 1 /* TEXT */) &&
                        !hasDynamicKeyOrRef(child) &&
                        !hasCachedProps()) {
                        const props = getNodeProps(child);
                        if (props) {
                            codegenNode.props = context.hoist(props);
                        }
                    }
                }
            }
        }
        else if (child.type === 12 /* TEXT_CALL */) {
            const staticType = getStaticType(child.content, resultCache);
            if (staticType > 0) {
                if (staticType === 2 /* HAS_RUNTIME_CONSTANT */) {
                    hasRuntimeConstant = true;
                }
                child.codegenNode = context.hoist(child.codegenNode);
                hasHoistedNode = true;
            }
        }
        // walk further
        if (child.type === 1 /* ELEMENT */) {
            walk(child.children, context, resultCache);
        }
        else if (child.type === 11 /* FOR */) {
            // Do not hoist v-for single child because it has to be a block
            walk(child.children, context, resultCache, child.children.length === 1);
        }
        else if (child.type === 9 /* IF */) {
            for (let i = 0; i < child.branches.length; i++) {
                const branchChildren = child.branches[i].children;
                // Do not hoist v-if single child because it has to be a block
                walk(branchChildren, context, resultCache, branchChildren.length === 1);
            }
        }
    }
    if (!hasRuntimeConstant && hasHoistedNode && context.transformHoist) {
        context.transformHoist(children, context);
    }
}
function getStaticType(node, resultCache = new Map()) {
    switch (node.type) {
        case 1 /* ELEMENT */:
            if (node.tagType !== 0 /* ELEMENT */) {
                return 0 /* NOT_STATIC */;
            }
            const cached = resultCache.get(node);
            if (cached !== undefined) {
                return cached;
            }
            const codegenNode = node.codegenNode;
            if (codegenNode.type !== 13 /* VNODE_CALL */) {
                return 0 /* NOT_STATIC */;
            }
            const flag = getPatchFlag(codegenNode);
            if (!flag && !hasDynamicKeyOrRef(node) && !hasCachedProps()) {
                // element self is static. check its children.
                let returnType = 1 /* FULL_STATIC */;
                for (let i = 0; i < node.children.length; i++) {
                    const childType = getStaticType(node.children[i], resultCache);
                    if (childType === 0 /* NOT_STATIC */) {
                        resultCache.set(node, 0 /* NOT_STATIC */);
                        return 0 /* NOT_STATIC */;
                    }
                    else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {
                        returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                    }
                }
                // check if any of the props contain runtime constants
                if (returnType !== 2 /* HAS_RUNTIME_CONSTANT */) {
                    for (let i = 0; i < node.props.length; i++) {
                        const p = node.props[i];
                        if (p.type === 7 /* DIRECTIVE */ &&
                            p.name === 'bind' &&
                            p.exp &&
                            (p.exp.type === 8 /* COMPOUND_EXPRESSION */ ||
                                p.exp.isRuntimeConstant)) {
                            returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                        }
                    }
                }
                // only svg/foreignObject could be block here, however if they are
                // stati then they don't need to be blocks since there will be no
                // nested updates.
                if (codegenNode.isBlock) {
                    codegenNode.isBlock = false;
                }
                resultCache.set(node, returnType);
                return returnType;
            }
            else {
                resultCache.set(node, 0 /* NOT_STATIC */);
                return 0 /* NOT_STATIC */;
            }
        case 2 /* TEXT */:
        case 3 /* COMMENT */:
            return 1 /* FULL_STATIC */;
        case 9 /* IF */:
        case 11 /* FOR */:
        case 10 /* IF_BRANCH */:
            return 0 /* NOT_STATIC */;
        case 5 /* INTERPOLATION */:
        case 12 /* TEXT_CALL */:
            return getStaticType(node.content, resultCache);
        case 4 /* SIMPLE_EXPRESSION */:
            return node.isConstant
                ? node.isRuntimeConstant
                    ? 2 /* HAS_RUNTIME_CONSTANT */
                    : 1 /* FULL_STATIC */
                : 0 /* NOT_STATIC */;
        case 8 /* COMPOUND_EXPRESSION */:
            let returnType = 1 /* FULL_STATIC */;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(child) || Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isSymbol"])(child)) {
                    continue;
                }
                const childType = getStaticType(child, resultCache);
                if (childType === 0 /* NOT_STATIC */) {
                    return 0 /* NOT_STATIC */;
                }
                else if (childType === 2 /* HAS_RUNTIME_CONSTANT */) {
                    returnType = 2 /* HAS_RUNTIME_CONSTANT */;
                }
            }
            return returnType;
        default:
            if ((false)) {}
            return 0 /* NOT_STATIC */;
    }
}
function hasDynamicKeyOrRef(node) {
    return !!(findProp(node, 'key', true) || findProp(node, 'ref', true));
}
function hasCachedProps(node) {
    {
        return false;
    }
}
function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13 /* VNODE_CALL */) {
        return codegenNode.props;
    }
}
function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : undefined;
}

function createTransformContext(root, { prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = _vue_shared__WEBPACK_IMPORTED_MODULE_0__["NOOP"], expressionPlugins = [], scopeId = null, ssr = false, onError = defaultOnError }) {
    const context = {
        // options
        prefixIdentifiers,
        hoistStatic,
        cacheHandlers,
        nodeTransforms,
        directiveTransforms,
        transformHoist,
        isBuiltInComponent,
        expressionPlugins,
        scopeId,
        ssr,
        onError,
        // state
        root,
        helpers: new Set(),
        components: new Set(),
        directives: new Set(),
        hoists: [],
        imports: new Set(),
        temps: 0,
        cached: 0,
        identifiers: {},
        scopes: {
            vFor: 0,
            vSlot: 0,
            vPre: 0,
            vOnce: 0
        },
        parent: null,
        currentNode: root,
        childIndex: 0,
        // methods
        helper(name) {
            context.helpers.add(name);
            return name;
        },
        helperString(name) {
            return `_${helperNameMap[context.helper(name)]}`;
        },
        replaceNode(node) {
            /* istanbul ignore if */
            if ((false)) {}
            context.parent.children[context.childIndex] = context.currentNode = node;
        },
        removeNode(node) {
            if (false) {}
            const list = context.parent.children;
            const removalIndex = node
                ? list.indexOf(node)
                : context.currentNode
                    ? context.childIndex
                    : -1;
            /* istanbul ignore if */
            if (false) {}
            if (!node || node === context.currentNode) {
                // current node removed
                context.currentNode = null;
                context.onNodeRemoved();
            }
            else {
                // sibling node removed
                if (context.childIndex > removalIndex) {
                    context.childIndex--;
                    context.onNodeRemoved();
                }
            }
            context.parent.children.splice(removalIndex, 1);
        },
        onNodeRemoved: () => { },
        addIdentifiers(exp) {
        },
        removeIdentifiers(exp) {
        },
        hoist(exp) {
            context.hoists.push(exp);
            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, true);
            identifier.hoisted = exp;
            return identifier;
        },
        cache(exp, isVNode = false) {
            return createCacheExpression(++context.cached, exp, isVNode);
        }
    };
    return context;
}
function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
        hoistStatic(root, context);
    }
    if (!options.ssr) {
        createRootCodegen(root, context);
    }
    // finalize meta information
    root.helpers = [...context.helpers];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = [...context.imports];
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
}
function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    const child = children[0];
    if (children.length === 1) {
        // if the single child is an element, turn it into a block.
        if (isSingleElementRoot(root, child) && child.codegenNode) {
            // single element root is never hoisted so codegenNode will never be
            // SimpleExpressionNode
            const codegenNode = child.codegenNode;
            if (codegenNode.type === 13 /* VNODE_CALL */) {
                codegenNode.isBlock = true;
                helper(OPEN_BLOCK);
                helper(CREATE_BLOCK);
            }
            root.codegenNode = codegenNode;
        }
        else {
            // - single <slot/>, IfNode, ForNode: already blocks.
            // - single text node: always patched.
            // root codegen falls through via genNode()
            root.codegenNode = child;
        }
    }
    else if (children.length > 1) {
        // root has multiple nodes - return a fragment block.
        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, `${64 /* STABLE_FRAGMENT */} /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__["PatchFlagNames"][64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);
    }
}
function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
        i--;
    };
    for (; i < parent.children.length; i++) {
        const child = parent.children[i];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(child))
            continue;
        context.parent = parent;
        context.childIndex = i;
        context.onNodeRemoved = nodeRemoved;
        traverseNode(child, context);
    }
}
function traverseNode(node, context) {
    context.currentNode = node;
    // apply transform plugins
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i = 0; i < nodeTransforms.length; i++) {
        const onExit = nodeTransforms[i](node, context);
        if (onExit) {
            if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(onExit)) {
                exitFns.push(...onExit);
            }
            else {
                exitFns.push(onExit);
            }
        }
        if (!context.currentNode) {
            // node was removed
            return;
        }
        else {
            // node may have been replaced
            node = context.currentNode;
        }
    }
    switch (node.type) {
        case 3 /* COMMENT */:
            if (!context.ssr) {
                // inject import for the Comment symbol, which is needed for creating
                // comment nodes with `createVNode`
                context.helper(CREATE_COMMENT);
            }
            break;
        case 5 /* INTERPOLATION */:
            // no need to traverse, but we need to inject toString helper
            if (!context.ssr) {
                context.helper(TO_DISPLAY_STRING);
            }
            break;
        // for container types, further traverse downwards
        case 9 /* IF */:
            for (let i = 0; i < node.branches.length; i++) {
                traverseNode(node.branches[i], context);
            }
            break;
        case 10 /* IF_BRANCH */:
        case 11 /* FOR */:
        case 1 /* ELEMENT */:
        case 0 /* ROOT */:
            traverseChildren(node, context);
            break;
    }
    // exit transforms
    let i = exitFns.length;
    while (i--) {
        exitFns[i]();
    }
}
function createStructuralDirectiveTransform(name, fn) {
    const matches = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(name)
        ? (n) => n === name
        : (n) => name.test(n);
    return (node, context) => {
        if (node.type === 1 /* ELEMENT */) {
            const { props } = node;
            // structural directive transforms are not concerned with slots
            // as they are handled separately in vSlot.ts
            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {
                return;
            }
            const exitFns = [];
            for (let i = 0; i < props.length; i++) {
                const prop = props[i];
                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {
                    // structural directives are removed to avoid infinite recursion
                    // also we remove them *before* applying so that it can further
                    // traverse itself in case it moves the node around
                    props.splice(i, 1);
                    i--;
                    const onExit = fn(node, prop, context);
                    if (onExit)
                        exitFns.push(onExit);
                }
            }
            return exitFns;
        }
    };
}

const PURE_ANNOTATION = `/*#__PURE__*/`;
function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeBindings = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {
    const context = {
        mode,
        prefixIdentifiers,
        sourceMap,
        filename,
        scopeId,
        optimizeBindings,
        runtimeGlobalName,
        runtimeModuleName,
        ssr,
        source: ast.loc.source,
        code: ``,
        column: 1,
        line: 1,
        offset: 0,
        indentLevel: 0,
        pure: false,
        map: undefined,
        helper(key) {
            return `_${helperNameMap[key]}`;
        },
        push(code, node) {
            context.code += code;
        },
        indent() {
            newline(++context.indentLevel);
        },
        deindent(withoutNewLine = false) {
            if (withoutNewLine) {
                --context.indentLevel;
            }
            else {
                newline(--context.indentLevel);
            }
        },
        newline() {
            newline(context.indentLevel);
        }
    };
    function newline(n) {
        context.push('\n' + `  `.repeat(n));
    }
    return context;
}
function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== 'module';
    // preambles
    {
        genFunctionPreamble(ast, context);
    }
    if (!ssr) {
        push(`function render(_ctx, _cache) {`);
    }
    else {
        push(`function ssrRender(_ctx, _push, _parent) {`);
    }
    indent();
    if (useWithBlock) {
        push(`with (_ctx) {`);
        indent();
        // function mode const declarations should be inside with block
        // also they should be renamed to avoid collision with user properties
        if (hasHelpers) {
            push(`const { ${ast.helpers
                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)
                .join(', ')} } = _Vue`);
            push(`\n`);
            newline();
        }
    }
    // generate asset resolution statements
    if (ast.components.length) {
        genAssets(ast.components, 'component', context);
        if (ast.directives.length || ast.temps > 0) {
            newline();
        }
    }
    if (ast.directives.length) {
        genAssets(ast.directives, 'directive', context);
        if (ast.temps > 0) {
            newline();
        }
    }
    if (ast.temps > 0) {
        push(`let `);
        for (let i = 0; i < ast.temps; i++) {
            push(`${i > 0 ? `, ` : ``}_temp${i}`);
        }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
        push(`\n`);
        newline();
    }
    // generate the VNode tree expression
    if (!ssr) {
        push(`return `);
    }
    if (ast.codegenNode) {
        genNode(ast.codegenNode, context);
    }
    else {
        push(`null`);
    }
    if (useWithBlock) {
        deindent();
        push(`}`);
    }
    deindent();
    push(`}`);
    return {
        ast,
        code: context.code,
        // SourceMapGenerator does have toJSON() method but it's not in the types
        map: context.map ? context.map.toJSON() : undefined
    };
}
function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;
    const VueBinding =  runtimeGlobalName;
    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;
    // Generate const declaration for helpers
    // In prefix mode, we place the const declaration at top so it's done
    // only once; But if we not prefixing, we place the declaration inside the
    // with block so it doesn't incur the `in` check cost for every helper access.
    if (ast.helpers.length > 0) {
        {
            // "with" mode.
            // save Vue in a separate variable to avoid collision
            push(`const _Vue = ${VueBinding}\n`);
            // in "with" mode, helpers are declared inside the with block to avoid
            // has check cost, but hoists are lifted out of the function - we need
            // to provide the helper here.
            if (ast.hoists.length) {
                const staticHelpers = [
                    CREATE_VNODE,
                    CREATE_COMMENT,
                    CREATE_TEXT,
                    CREATE_STATIC
                ]
                    .filter(helper => ast.helpers.includes(helper))
                    .map(aliasHelper)
                    .join(', ');
                push(`const { ${staticHelpers} } = _Vue\n`);
            }
        }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
}
function genAssets(assets, type, { helper, push, newline }) {
    const resolver = helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
        const id = assets[i];
        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)})`);
        if (i < assets.length - 1) {
            newline();
        }
    }
}
function genHoists(hoists, context) {
    if (!hoists.length) {
        return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    hoists.forEach((exp, i) => {
        if (exp) {
            push(`const _hoisted_${i + 1} = `);
            genNode(exp, context);
            newline();
        }
    });
    context.pure = false;
}
function isText$1(n) {
    return (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(n) ||
        n.type === 4 /* SIMPLE_EXPRESSION */ ||
        n.type === 2 /* TEXT */ ||
        n.type === 5 /* INTERPOLATION */ ||
        n.type === 8 /* COMPOUND_EXPRESSION */);
}
function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 ||
        (( ( false)) && false);
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
}
function genNodeList(nodes, context, multilines = false, comma = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(node)) {
            push(node);
        }
        else if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(node)) {
            genNodeListAsArray(node, context);
        }
        else {
            genNode(node, context);
        }
        if (i < nodes.length - 1) {
            if (multilines) {
                comma && push(',');
                newline();
            }
            else {
                comma && push(', ');
            }
        }
    }
}
function genNode(node, context) {
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(node)) {
        context.push(node);
        return;
    }
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isSymbol"])(node)) {
        context.push(context.helper(node));
        return;
    }
    switch (node.type) {
        case 1 /* ELEMENT */:
        case 9 /* IF */:
        case 11 /* FOR */:
            ( false) &&
                false;
            genNode(node.codegenNode, context);
            break;
        case 2 /* TEXT */:
            genText(node, context);
            break;
        case 4 /* SIMPLE_EXPRESSION */:
            genExpression(node, context);
            break;
        case 5 /* INTERPOLATION */:
            genInterpolation(node, context);
            break;
        case 12 /* TEXT_CALL */:
            genNode(node.codegenNode, context);
            break;
        case 8 /* COMPOUND_EXPRESSION */:
            genCompoundExpression(node, context);
            break;
        case 3 /* COMMENT */:
            genComment(node, context);
            break;
        case 13 /* VNODE_CALL */:
            genVNodeCall(node, context);
            break;
        case 14 /* JS_CALL_EXPRESSION */:
            genCallExpression(node, context);
            break;
        case 15 /* JS_OBJECT_EXPRESSION */:
            genObjectExpression(node, context);
            break;
        case 17 /* JS_ARRAY_EXPRESSION */:
            genArrayExpression(node, context);
            break;
        case 18 /* JS_FUNCTION_EXPRESSION */:
            genFunctionExpression(node, context);
            break;
        case 19 /* JS_CONDITIONAL_EXPRESSION */:
            genConditionalExpression(node, context);
            break;
        case 20 /* JS_CACHE_EXPRESSION */:
            genCacheExpression(node, context);
            break;
        // SSR only types
        case 21 /* JS_BLOCK_STATEMENT */:
            break;
        case 22 /* JS_TEMPLATE_LITERAL */:
            break;
        case 23 /* JS_IF_STATEMENT */:
            break;
        case 24 /* JS_ASSIGNMENT_EXPRESSION */:
            break;
        case 25 /* JS_SEQUENCE_EXPRESSION */:
            break;
        case 26 /* JS_RETURN_STATEMENT */:
            break;
        /* istanbul ignore next */
        case 10 /* IF_BRANCH */:
            // noop
            break;
        default:
            if ((false)) {}
    }
}
function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
}
function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
}
function genInterpolation(node, context) {
    const { push, helper, pure } = context;
    if (pure)
        push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
}
function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(child)) {
            context.push(child);
        }
        else {
            genNode(child, context);
        }
    }
}
function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8 /* COMPOUND_EXPRESSION */) {
        push(`[`);
        genCompoundExpression(node, context);
        push(`]`);
    }
    else if (node.isStatic) {
        // only quote keys if necessary
        const text = isSimpleIdentifier(node.content)
            ? node.content
            : JSON.stringify(node.content);
        push(text, node);
    }
    else {
        push(`[${node.content}]`, node);
    }
}
function genComment(node, context) {
    if ((false)) {}
}
function genVNodeCall(node, context) {
    const { push, helper, pure } = context;
    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, isForBlock } = node;
    if (directives) {
        push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
        push(`(${helper(OPEN_BLOCK)}(${isForBlock ? `true` : ``}), `);
    }
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);
    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
        push(`)`);
    }
    if (directives) {
        push(`, `);
        genNode(directives, context);
        push(`)`);
    }
}
function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
        if (args[i] != null)
            break;
    }
    return args.slice(0, i + 1).map(arg => arg || `null`);
}
// JavaScript
function genCallExpression(node, context) {
    const { push, helper, pure } = context;
    const callee = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(node.callee) ? node.callee : helper(node.callee);
    if (pure) {
        push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
}
function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
        push(`{}`, node);
        return;
    }
    const multilines = properties.length > 1 ||
        (( ( false)) &&
            false);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
        const { key, value } = properties[i];
        // key
        genExpressionAsPropertyKey(key, context);
        push(`: `);
        // value
        genNode(value, context);
        if (i < properties.length - 1) {
            // will only reach this if it's multilines
            push(`,`);
            newline();
        }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
}
function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
}
function genFunctionExpression(node, context) {
    const { push, indent, deindent, scopeId, mode } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
        push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(params)) {
        genNodeList(params, context);
    }
    else if (params) {
        genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
        push(`{`);
        indent();
    }
    if (returns) {
        if (newline) {
            push(`return `);
        }
        if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isArray"])(returns)) {
            genNodeListAsArray(returns, context);
        }
        else {
            genNode(returns, context);
        }
    }
    else if (body) {
        genNode(body, context);
    }
    if (newline || body) {
        deindent();
        push(`}`);
    }
    if ( isSlot) {
        push(`)`);
    }
}
function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4 /* SIMPLE_EXPRESSION */) {
        const needsParens = !isSimpleIdentifier(test.content);
        needsParens && push(`(`);
        genExpression(test, context);
        needsParens && push(`)`);
    }
    else {
        push(`(`);
        genNode(test, context);
        push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;
    if (!isNested) {
        context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
        context.indentLevel--;
    }
    needNewline && deindent(true /* without newline */);
}
function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
        indent();
        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
        newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
        push(`,`);
        newline();
        push(`${helper(SET_BLOCK_TRACKING)}(1),`);
        newline();
        push(`_cache[${node.index}]`);
        deindent();
    }
    push(`)`);
}

const isLiteralWhitelisted = /*#__PURE__*/ Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["makeMap"])('true,false,null,this');
const transformExpression = (node, context) => {
    if (node.type === 5 /* INTERPOLATION */) {
        node.content = processExpression(node.content, context);
    }
    else if (node.type === 1 /* ELEMENT */) {
        // handle directives on element
        for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            // do not process for v-on & v-for since they are special handled
            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {
                const exp = dir.exp;
                const arg = dir.arg;
                // do not process exp if this is v-on:arg - we need special handling
                // for wrapping inline statements.
                if (exp &&
                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&
                    !(dir.name === 'on' && arg)) {
                    dir.exp = processExpression(exp, context, 
                    // slot args must be processed as function params
                    dir.name === 'slot');
                }
                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {
                    dir.arg = processExpression(arg, context);
                }
            }
        }
    }
};
// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node, context, 
// some expressions like v-slot props & v-for aliases should be parsed as
// function params
asParams = false, 
// v-on handler values may contain multiple statements
asRawStatements = false) {
    if (!context.prefixIdentifiers || !node.content.trim()) {
        return node;
    }
    // fast path if expression is a simple identifier.
    const rawExp = node.content;
    // bail on parens to prevent any possible function invocations.
    const bailConstant = rawExp.indexOf(`(`) > -1;
    if (isSimpleIdentifier(rawExp)) {
        if (!asParams &&
            !context.identifiers[rawExp] &&
            !Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isGloballyWhitelisted"])(rawExp) &&
            !isLiteralWhitelisted(rawExp)) {
            node.content = `_ctx.${rawExp}`;
        }
        else if (!context.identifiers[rawExp] && !bailConstant) {
            // mark node constant for hoisting unless it's referring a scope variable
            node.isConstant = true;
        }
        return node;
    }
    let ast;
    // exp needs to be parsed differently:
    // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw
    //    exp, but make sure to pad with spaces for consistent ranges
    // 2. Expressions: wrap with parens (for e.g. object expressions)
    // 3. Function arguments (v-for, v-slot): place in a function argument position
    const source = asRawStatements
        ? ` ${rawExp} `
        : `(${rawExp})${asParams ? `=>{}` : ``}`;
    try {
        ast = parseJS(source, {
            plugins: [
                ...context.expressionPlugins,
                // by default we enable proposals slated for ES2020.
                // full list at https://babeljs.io/docs/en/next/babel-parser#plugins
                // this will need to be updated as the spec moves forward.
                'bigInt',
                'optionalChaining',
                'nullishCoalescingOperator'
            ]
        }).program;
    }
    catch (e) {
        context.onError(createCompilerError(41 /* X_INVALID_EXPRESSION */, node.loc, undefined, e.message));
        return node;
    }
    const ids = [];
    const knownIds = Object.create(context.identifiers);
    // walk the AST and look for identifiers that need to be prefixed with `_ctx.`.
    walkJS();
    // We break up the compound expression into an array of strings and sub
    // expressions (for identifiers that have been prefixed). In codegen, if
    // an ExpressionNode has the `.children` property, it will be used instead of
    // `.content`.
    const children = [];
    ids.sort((a, b) => a.start - b.start);
    ids.forEach((id, i) => {
        // range is offset by -1 due to the wrapping parens when parsed
        const start = id.start - 1;
        const end = id.end - 1;
        const last = ids[i - 1];
        const leadingText = rawExp.slice(last ? last.end - 1 : 0, start);
        if (leadingText.length || id.prefix) {
            children.push(leadingText + (id.prefix || ``));
        }
        const source = rawExp.slice(start, end);
        children.push(createSimpleExpression(id.name, false, {
            source,
            start: advancePositionWithClone(node.loc.start, source, start),
            end: advancePositionWithClone(node.loc.start, source, end)
        }, id.isConstant /* isConstant */));
        if (i === ids.length - 1 && end < rawExp.length) {
            children.push(rawExp.slice(end));
        }
    });
    let ret;
    if (children.length) {
        ret = createCompoundExpression(children, node.loc);
    }
    else {
        ret = node;
        ret.isConstant = !bailConstant;
    }
    ret.identifiers = Object.keys(knownIds);
    return ret;
}

const transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
    return processIf(node, dir, context, (ifNode, branch, isRoot) => {
        // Exit callback. Complete the codegenNode when all children have been
        // transformed.
        return () => {
            if (isRoot) {
                ifNode.codegenNode = createCodegenNodeForBranch(branch, 0, context);
            }
            else {
                // attach this branch's codegen node to the v-if root.
                let parentCondition = ifNode.codegenNode;
                while (parentCondition.alternate.type ===
                    19 /* JS_CONDITIONAL_EXPRESSION */) {
                    parentCondition = parentCondition.alternate;
                }
                parentCondition.alternate = createCodegenNodeForBranch(branch, ifNode.branches.length - 1, context);
            }
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processIf(node, dir, context, processCodegen) {
    if (dir.name !== 'else' &&
        (!dir.exp || !dir.exp.content.trim())) {
        const loc = dir.exp ? dir.exp.loc : node.loc;
        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));
        dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (dir.name === 'if') {
        const branch = createIfBranch(node, dir);
        const ifNode = {
            type: 9 /* IF */,
            loc: node.loc,
            branches: [branch]
        };
        context.replaceNode(ifNode);
        if (processCodegen) {
            return processCodegen(ifNode, branch, true);
        }
    }
    else {
        // locate the adjacent v-if
        const siblings = context.parent.children;
        const comments = [];
        let i = siblings.indexOf(node);
        while (i-- >= -1) {
            const sibling = siblings[i];
            if (false /* COMMENT */) {}
            if (sibling && sibling.type === 9 /* IF */) {
                // move the node to the if node's branches
                context.removeNode();
                const branch = createIfBranch(node, dir);
                if (false) {}
                sibling.branches.push(branch);
                const onExit = processCodegen && processCodegen(sibling, branch, false);
                // since the branch was removed, it will not be traversed.
                // make sure to traverse here.
                traverseNode(branch, context);
                // call on exit
                if (onExit)
                    onExit();
                // make sure to reset currentNode after traversal to indicate this
                // node has been removed.
                context.currentNode = null;
            }
            else {
                context.onError(createCompilerError(28 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));
            }
            break;
        }
    }
}
function createIfBranch(node, dir) {
    return {
        type: 10 /* IF_BRANCH */,
        loc: node.loc,
        condition: dir.name === 'else' ? undefined : dir.exp,
        children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node]
    };
}
function createCodegenNodeForBranch(branch, index, context) {
    if (branch.condition) {
        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context), 
        // make sure to pass in asBlock: true so that the comment node call
        // closes the current block.
        createCallExpression(context.helper(CREATE_COMMENT), [
            ( false) ? undefined : '""',
            'true'
        ]));
    }
    else {
        return createChildrenCodegenNode(branch, index, context);
    }
}
function createChildrenCodegenNode(branch, index, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(index + '', false));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;
    if (needFragmentWrapper) {
        if (children.length === 1 && firstChild.type === 11 /* FOR */) {
            // optimize away nested fragments when child is a ForNode
            const vnodeCall = firstChild.codegenNode;
            injectProp(vnodeCall, keyProperty, context);
            return vnodeCall;
        }
        else {
            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, `${64 /* STABLE_FRAGMENT */} /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__["PatchFlagNames"][64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true, false, branch.loc);
        }
    }
    else {
        const vnodeCall = firstChild
            .codegenNode;
        // Change createVNode to createBlock.
        if (vnodeCall.type === 13 /* VNODE_CALL */ &&
            // component vnodes are always tracked and its children are
            // compiled into slots so no need to make it a block
            (firstChild.tagType !== 1 /* COMPONENT */ ||
                // teleport has component type but isn't always tracked
                vnodeCall.tag === TELEPORT)) {
            vnodeCall.isBlock = true;
            helper(OPEN_BLOCK);
            helper(CREATE_BLOCK);
        }
        // inject branch key
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
    }
}

const transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {
    const { helper } = context;
    return processFor(node, dir, context, forNode => {
        // create the loop render function expression now, and add the
        // iterator on exit after all children have been traversed
        const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
        ]);
        const keyProp = findProp(node, `key`);
        const fragmentFlag = keyProp
            ? 128 /* KEYED_FRAGMENT */
            : 256 /* UNKEYED_FRAGMENT */;
        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, `${fragmentFlag} /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__["PatchFlagNames"][fragmentFlag]} */`, undefined, undefined, true /* isBlock */, true /* isForBlock */, node.loc);
        return () => {
            // finish the codegen now that all children have been traversed
            let childBlock;
            const isTemplate = isTemplateNode(node);
            const { children } = forNode;
            const needFragmentWrapper = children.length > 1 || children[0].type !== 1 /* ELEMENT */;
            const slotOutlet = isSlotOutlet(node)
                ? node
                : isTemplate &&
                    node.children.length === 1 &&
                    isSlotOutlet(node.children[0])
                    ? node.children[0] // api-extractor somehow fails to infer this
                    : null;
            const keyProperty = keyProp
                ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */
                    ? createSimpleExpression(keyProp.value.content, true)
                    : keyProp.exp)
                : null;
            if (slotOutlet) {
                // <slot v-for="..."> or <template v-for="..."><slot/></template>
                childBlock = slotOutlet.codegenNode;
                if (isTemplate && keyProperty) {
                    // <template v-for="..." :key="..."><slot/></template>
                    // we need to inject the key to the renderSlot() call.
                    // the props for renderSlot is passed as the 3rd argument.
                    injectProp(childBlock, keyProperty, context);
                }
            }
            else if (needFragmentWrapper) {
                // <template v-for="..."> with text or multi-elements
                // should generate a fragment block for each loop
                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, `${64 /* STABLE_FRAGMENT */} /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__["PatchFlagNames"][64 /* STABLE_FRAGMENT */]} */`, undefined, undefined, true);
            }
            else {
                // Normal element v-for. Directly use the child's codegenNode
                // but mark it as a block.
                childBlock = children[0]
                    .codegenNode;
                childBlock.isBlock = true;
                helper(OPEN_BLOCK);
                helper(CREATE_BLOCK);
            }
            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));
        };
    });
});
// target-agnostic transform used for both Client and SSR
function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
        context.onError(createCompilerError(29 /* X_V_FOR_NO_EXPRESSION */, dir.loc));
        return;
    }
    const parseResult = parseForExpression(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    dir.exp);
    if (!parseResult) {
        context.onError(createCompilerError(30 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));
        return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value, key, index } = parseResult;
    const forNode = {
        type: 11 /* FOR */,
        loc: dir.loc,
        source,
        valueAlias: value,
        keyAlias: key,
        objectIndexAlias: index,
        parseResult,
        children: node.tagType === 3 /* TEMPLATE */ ? node.children : [node]
    };
    context.replaceNode(forNode);
    // bookkeeping
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
        scopes.vFor--;
        if (onExit)
            onExit();
    };
}
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const [, LHS, RHS] = inMatch;
    const result = {
        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
        value: undefined,
        key: undefined,
        index: undefined
    };
    let valueContent = LHS.trim()
        .replace(stripParensRE, '')
        .trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
        valueContent = valueContent.replace(forIteratorRE, '').trim();
        const keyContent = iteratorMatch[1].trim();
        let keyOffset;
        if (keyContent) {
            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
            result.key = createAliasExpression(loc, keyContent, keyOffset);
        }
        if (iteratorMatch[2]) {
            const indexContent = iteratorMatch[2].trim();
            if (indexContent) {
                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key
                    ? keyOffset + keyContent.length
                    : trimmedOffset + valueContent.length));
            }
        }
    }
    if (valueContent) {
        result.value = createAliasExpression(loc, valueContent, trimmedOffset);
    }
    return result;
}
function createAliasExpression(range, content, offset) {
    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));
}
function createForLoopParams({ value, key, index }) {
    const params = [];
    if (value) {
        params.push(value);
    }
    if (key) {
        if (!value) {
            params.push(createSimpleExpression(`_`, false));
        }
        params.push(key);
    }
    if (index) {
        if (!key) {
            if (!value) {
                params.push(createSimpleExpression(`_`, false));
            }
            params.push(createSimpleExpression(`__`, false));
        }
        params.push(index);
    }
    return params;
}

const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
const defaultFallback = createSimpleExpression(`undefined`, false);
// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
const trackSlotScopes = (node, context) => {
    if (node.type === 1 /* ELEMENT */ &&
        (node.tagType === 1 /* COMPONENT */ ||
            node.tagType === 3 /* TEMPLATE */)) {
        // We are only checking non-empty v-slot here
        // since we only care about slots that introduce scope variables.
        const vSlot = findDir(node, 'slot');
        if (vSlot) {
            const slotProps = vSlot.exp;
            context.scopes.vSlot++;
            return () => {
                context.scopes.vSlot--;
            };
        }
    }
};
// A NodeTransform that tracks scope identifiers for scoped slots with v-for.
// This transform is only applied in non-browser builds with { prefixIdentifiers: true }
const trackVForSlotScopes = (node, context) => {
    let vFor;
    if (isTemplateNode(node) &&
        node.props.some(isVSlot) &&
        (vFor = findDir(node, 'for'))) {
        const result = (vFor.parseResult = parseForExpression(vFor.exp));
        if (result) {
            const { value, key, index } = result;
            const { addIdentifiers, removeIdentifiers } = context;
            value && addIdentifiers(value);
            key && addIdentifiers(key);
            index && addIdentifiers(index);
            return () => {
                value && removeIdentifiers(value);
                key && removeIdentifiers(key);
                index && removeIdentifiers(index);
            };
        }
    }
};
const buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);
// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));
    // If the slot is inside a v-for or another v-slot, force it to be dynamic
    // since it likely uses a scope variable.
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    // 1. Check for slot with slotProps on component itself.
    //    <Comp v-slot="{ prop }"/>
    const onComponentSlot = findDir(node, 'slot', true);
    if (onComponentSlot) {
        const { arg, exp } = onComponentSlot;
        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));
    }
    // 2. Iterate through children and check for template slots
    //    <template v-slot:foo="{ prop }">
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
        const slotElement = children[i];
        let slotDir;
        if (!isTemplateNode(slotElement) ||
            !(slotDir = findDir(slotElement, 'slot', true))) {
            // not a <template v-slot>, skip.
            if (slotElement.type !== 3 /* COMMENT */) {
                implicitDefaultChildren.push(slotElement);
            }
            continue;
        }
        if (onComponentSlot) {
            // already has on-component slot - this is incorrect usage.
            context.onError(createCompilerError(34 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));
            break;
        }
        hasTemplateSlots = true;
        const { children: slotChildren, loc: slotLoc } = slotElement;
        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
        // check if name is dynamic.
        let staticSlotName;
        if (isStaticExp(slotName)) {
            staticSlotName = slotName ? slotName.content : `default`;
        }
        else {
            hasDynamicSlots = true;
        }
        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
        // check if this slot is conditional (v-if/v-for)
        let vIf;
        let vElse;
        let vFor;
        if ((vIf = findDir(slotElement, 'if'))) {
            hasDynamicSlots = true;
            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
        }
        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {
            // find adjacent v-if
            let j = i;
            let prev;
            while (j--) {
                prev = children[j];
                if (prev.type !== 3 /* COMMENT */) {
                    break;
                }
            }
            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {
                // remove node
                children.splice(i, 1);
                i--;
                // attach this slot to previous conditional
                let conditional = dynamicSlots[dynamicSlots.length - 1];
                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {
                    conditional = conditional.alternate;
                }
                conditional.alternate = vElse.exp
                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)
                    : buildDynamicSlot(slotName, slotFunction);
            }
            else {
                context.onError(createCompilerError(28 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));
            }
        }
        else if ((vFor = findDir(slotElement, 'for'))) {
            hasDynamicSlots = true;
            const parseResult = vFor.parseResult ||
                parseForExpression(vFor.exp);
            if (parseResult) {
                // Render the dynamic slots as an array and add it to the createSlot()
                // args. The runtime knows how to handle it appropriately.
                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
                    parseResult.source,
                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)
                ]));
            }
            else {
                context.onError(createCompilerError(30 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));
            }
        }
        else {
            // check duplicate static names
            if (staticSlotName) {
                if (seenSlotNames.has(staticSlotName)) {
                    context.onError(createCompilerError(35 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));
                    continue;
                }
                seenSlotNames.add(staticSlotName);
                if (staticSlotName === 'default') {
                    hasNamedDefaultSlot = true;
                }
            }
            slotsProperties.push(createObjectProperty(slotName, slotFunction));
        }
    }
    if (!onComponentSlot) {
        if (!hasTemplateSlots) {
            // implicit default slot (on component)
            slotsProperties.push(buildDefaultSlotProperty(undefined, children));
        }
        else if (implicitDefaultChildren.length) {
            // implicit default slot (mixed with named slots)
            if (hasNamedDefaultSlot) {
                context.onError(createCompilerError(36 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));
            }
            else {
                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));
            }
        }
    }
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(`1`, false))), loc);
    if (dynamicSlots.length) {
        slots = createCallExpression(context.helper(CREATE_SLOTS), [
            slots,
            createArrayExpression(dynamicSlots)
        ]);
    }
    return {
        slots,
        hasDynamicSlots
    };
}
function buildDynamicSlot(name, fn) {
    return createObjectExpression([
        createObjectProperty(`name`, name),
        createObjectProperty(`fn`, fn)
    ]);
}

// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
const directiveImportMap = new WeakMap();
// generate a JavaScript AST for this element's codegen
const transformElement = (node, context) => {
    if (!(node.type === 1 /* ELEMENT */ &&
        (node.tagType === 0 /* ELEMENT */ ||
            node.tagType === 1 /* COMPONENT */))) {
        return;
    }
    // perform the work on exit, after all child expressions have been
    // processed and merged.
    return function postTransformElement() {
        const { tag, props } = node;
        const isComponent = node.tagType === 1 /* COMPONENT */;
        // The goal of the transform is to create a codegenNode implementing the
        // VNodeCall interface.
        const vnodeTag = isComponent
            ? resolveComponentType(node, context)
            : `"${tag}"`;
        const isDynamicComponent = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isObject"])(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
        let vnodeProps;
        let vnodeChildren;
        let vnodePatchFlag;
        let patchFlag = 0;
        let vnodeDynamicProps;
        let dynamicPropNames;
        let vnodeDirectives;
        let shouldUseBlock = 
        // dynamic component may resolve to plain elements
        isDynamicComponent ||
            (!isComponent &&
                // <svg> and <foreignObject> must be forced into blocks so that block
                // updates inside get proper isSVG flag at runtime. (#639, #643)
                // This is technically web-specific, but splitting the logic out of core
                // leads to too much unnecessary complexity.
                (tag === 'svg' ||
                    tag === 'foreignObject' ||
                    // #938: elements with dynamic keys should be forced into blocks
                    findProp(node, 'key', true)));
        // props
        if (props.length > 0) {
            const propsBuildResult = buildProps(node, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives = propsBuildResult.directives;
            vnodeDirectives =
                directives && directives.length
                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))
                    : undefined;
        }
        // children
        if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
                // Although a built-in component, we compile KeepAlive with raw children
                // instead of slot functions so that it can be used inside Transition
                // or other Transition-wrapping HOCs.
                // To ensure correct updates with block optimizations, we need to:
                // 1. Force keep-alive into a block. This avoids its children being
                //    collected by a parent block.
                shouldUseBlock = true;
                // 2. Force keep-alive to always be updated, since it uses raw children.
                patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                if (false) {}
            }
            const shouldBuildAsSlots = isComponent &&
                // Teleport is not a real component and has dedicated runtime handling
                vnodeTag !== TELEPORT &&
                // explained above.
                vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
                const { slots, hasDynamicSlots } = buildSlots(node, context);
                vnodeChildren = slots;
                if (hasDynamicSlots) {
                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
                const child = node.children[0];
                const type = child.type;
                // check for dynamic text children
                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||
                    type === 8 /* COMPOUND_EXPRESSION */;
                if (hasDynamicTextChild && !getStaticType(child)) {
                    patchFlag |= 1 /* TEXT */;
                }
                // pass directly if the only child is a text node
                // (plain / interpolation / expression)
                if (hasDynamicTextChild || type === 2 /* TEXT */) {
                    vnodeChildren = child;
                }
                else {
                    vnodeChildren = node.children;
                }
            }
            else {
                vnodeChildren = node.children;
            }
        }
        // patchFlag & dynamicPropNames
        if (patchFlag !== 0) {
            if ((false)) {}
            else {
                vnodePatchFlag = String(patchFlag);
            }
            if (dynamicPropNames && dynamicPropNames.length) {
                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
        }
        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* isForBlock */, node.loc);
    };
};
function resolveComponentType(node, context, ssr = false) {
    const { tag } = node;
    // 1. dynamic component
    const isProp = node.tag === 'component' ? findProp(node, 'is') : findDir(node, 'is');
    if (isProp) {
        const exp = isProp.type === 6 /* ATTRIBUTE */
            ? isProp.value && createSimpleExpression(isProp.value.content, true)
            : isProp.exp;
        if (exp) {
            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
                exp
            ]);
        }
    }
    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
        // built-ins are simply fallthroughs / have special handling during ssr
        // no we don't need to import their runtime equivalents
        if (!ssr)
            context.helper(builtIn);
        return builtIn;
    }
    // 3. user component (resolve)
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
}
function buildProps(node, context, props = node.props, ssr = false) {
    const { tag, loc: elementLoc } = node;
    const isComponent = node.tagType === 1 /* COMPONENT */;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    // patchFlag analysis
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key, value }) => {
        if (key.type === 4 /* SIMPLE_EXPRESSION */ && key.isStatic) {
            const name = key.content;
            if (!isComponent &&
                Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isOn"])(name) &&
                // omit the flag for click handlers becaues hydration gives click
                // dedicated fast path.
                name.toLowerCase() !== 'onclick' &&
                // omit v-model handlers
                name !== 'onUpdate:modelValue') {
                hasHydrationEventBinding = true;
            }
            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||
                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||
                    value.type === 8 /* COMPOUND_EXPRESSION */) &&
                    getStaticType(value) > 0)) {
                // skip if the prop is a cached handler or has constant value
                return;
            }
            if (name === 'ref') {
                hasRef = true;
            }
            else if (name === 'class' && !isComponent) {
                hasClassBinding = true;
            }
            else if (name === 'style' && !isComponent) {
                hasStyleBinding = true;
            }
            else if (name !== 'key' && !dynamicPropNames.includes(name)) {
                dynamicPropNames.push(name);
            }
        }
        else {
            hasDynamicKeys = true;
        }
    };
    for (let i = 0; i < props.length; i++) {
        // static attribute
        const prop = props[i];
        if (prop.type === 6 /* ATTRIBUTE */) {
            const { loc, name, value } = prop;
            if (name === 'ref') {
                hasRef = true;
            }
            // skip :is on <component>
            if (name === 'is' && tag === 'component') {
                continue;
            }
            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', true, value ? value.loc : loc)));
        }
        else {
            // directives
            const { name, arg, exp, loc } = prop;
            const isBind = name === 'bind';
            const isOn = name === 'on';
            // skip v-slot - it is handled by its dedicated transform.
            if (name === 'slot') {
                if (!isComponent) {
                    context.onError(createCompilerError(37 /* X_V_SLOT_MISPLACED */, loc));
                }
                continue;
            }
            // skip v-once - it is handled by its dedicated transform.
            if (name === 'once') {
                continue;
            }
            // skip v-is and :is on <component>
            if (name === 'is' ||
                (isBind && tag === 'component' && isBindKey(arg, 'is'))) {
                continue;
            }
            // skip v-on in SSR compilation
            if (isOn && ssr) {
                continue;
            }
            // special case for v-bind and v-on with no argument
            if (!arg && (isBind || isOn)) {
                hasDynamicKeys = true;
                if (exp) {
                    if (properties.length) {
                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
                        properties = [];
                    }
                    if (isBind) {
                        mergeArgs.push(exp);
                    }
                    else {
                        // v-on="obj" -> toHandlers(obj)
                        mergeArgs.push({
                            type: 14 /* JS_CALL_EXPRESSION */,
                            loc,
                            callee: context.helper(TO_HANDLERS),
                            arguments: [exp]
                        });
                    }
                }
                else {
                    context.onError(createCompilerError(isBind
                        ? 31 /* X_V_BIND_NO_EXPRESSION */
                        : 32 /* X_V_ON_NO_EXPRESSION */, loc));
                }
                continue;
            }
            const directiveTransform = context.directiveTransforms[name];
            if (directiveTransform) {
                // has built-in directive transform.
                const { props, needRuntime } = directiveTransform(prop, node, context);
                !ssr && props.forEach(analyzePatchFlag);
                properties.push(...props);
                if (needRuntime) {
                    runtimeDirectives.push(prop);
                    if (Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isSymbol"])(needRuntime)) {
                        directiveImportMap.set(prop, needRuntime);
                    }
                }
            }
            else {
                // no built-in transform, this is a user custom directive.
                runtimeDirectives.push(prop);
            }
        }
    }
    let propsExpression = undefined;
    // has v-bind="object" or v-on="object", wrap with mergeProps
    if (mergeArgs.length) {
        if (properties.length) {
            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
        }
        if (mergeArgs.length > 1) {
            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
        }
        else {
            // single v-bind with nothing else - no need for a mergeProps call
            propsExpression = mergeArgs[0];
        }
    }
    else if (properties.length) {
        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    // patchFlag analysis
    if (hasDynamicKeys) {
        patchFlag |= 16 /* FULL_PROPS */;
    }
    else {
        if (hasClassBinding) {
            patchFlag |= 2 /* CLASS */;
        }
        if (hasStyleBinding) {
            patchFlag |= 4 /* STYLE */;
        }
        if (dynamicPropNames.length) {
            patchFlag |= 8 /* PROPS */;
        }
        if (hasHydrationEventBinding) {
            patchFlag |= 32 /* HYDRATE_EVENTS */;
        }
    }
    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&
        (hasRef || runtimeDirectives.length > 0)) {
        patchFlag |= 512 /* NEED_PATCH */;
    }
    return {
        props: propsExpression,
        directives: runtimeDirectives,
        patchFlag,
        dynamicPropNames
    };
}
// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        // dynamic keys are always allowed
        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {
            deduped.push(prop);
            continue;
        }
        const name = prop.key.content;
        const existing = knownProps.get(name);
        if (existing) {
            if (name === 'style' || name === 'class' || name.startsWith('on')) {
                mergeAsArray(existing, prop);
            }
            // unexpected duplicate, should have emitted error during parse
        }
        else {
            knownProps.set(name, prop);
            deduped.push(prop);
        }
    }
    return deduped;
}
function mergeAsArray(existing, incoming) {
    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {
        existing.value.elements.push(incoming.value);
    }
    else {
        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
}
function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
        dirArgs.push(context.helperString(runtime));
    }
    else {
        // inject statement for resolving directive
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
    }
    const { loc } = dir;
    if (dir.exp)
        dirArgs.push(dir.exp);
    if (dir.arg) {
        if (!dir.exp) {
            dirArgs.push(`void 0`);
        }
        dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
        if (!dir.arg) {
            if (!dir.exp) {
                dirArgs.push(`void 0`);
            }
            dirArgs.push(`void 0`);
        }
        const trueExpression = createSimpleExpression(`true`, false, loc);
        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
}
function stringifyDynamicPropNames(props) {
    let propsNamesString = `[`;
    for (let i = 0, l = props.length; i < l; i++) {
        propsNamesString += JSON.stringify(props[i]);
        if (i < l - 1)
            propsNamesString += ', ';
    }
    return propsNamesString + `]`;
}

const transformSlotOutlet = (node, context) => {
    if (isSlotOutlet(node)) {
        const { children, loc } = node;
        const { slotName, slotProps } = processSlotOutlet(node, context);
        const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName
        ];
        if (slotProps) {
            slotArgs.push(slotProps);
        }
        if (children.length) {
            if (!slotProps) {
                slotArgs.push(`{}`);
            }
            slotArgs.push(createFunctionExpression([], children, false, false, loc));
        }
        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
    }
};
function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = undefined;
    // check for <slot name="xxx" OR :name="xxx" />
    const name = findProp(node, 'name');
    if (name) {
        if (name.type === 6 /* ATTRIBUTE */ && name.value) {
            // static name
            slotName = JSON.stringify(name.value.content);
        }
        else if (name.type === 7 /* DIRECTIVE */ && name.exp) {
            // dynamic name
            slotName = name.exp;
        }
    }
    const propsWithoutName = name
        ? node.props.filter(p => p !== name)
        : node.props;
    if (propsWithoutName.length > 0) {
        const { props, directives } = buildProps(node, context, propsWithoutName);
        slotProps = props;
        if (directives.length) {
            context.onError(createCompilerError(33 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));
        }
    }
    return {
        slotName,
        slotProps
    };
}

const fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
const transformOn = (dir, node, context, augmentor) => {
    const { loc, modifiers, arg } = dir;
    if (!dir.exp && !modifiers.length) {
        context.onError(createCompilerError(32 /* X_V_ON_NO_EXPRESSION */, loc));
    }
    let eventName;
    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
        if (arg.isStatic) {
            const rawName = arg.content;
            // for @vnode-xxx event listeners, auto convert it to camelCase
            const normalizedName = rawName.startsWith(`vnode`)
                ? Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["capitalize"])(Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["camelize"])(rawName))
                : Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["capitalize"])(rawName);
            eventName = createSimpleExpression(`on${normalizedName}`, true, arg.loc);
        }
        else {
            eventName = createCompoundExpression([`"on" + (`, arg, `)`]);
        }
    }
    else {
        // already a compound expression.
        eventName = arg;
        eventName.children.unshift(`"on" + (`);
        eventName.children.push(`)`);
    }
    // handler processing
    let exp = dir.exp;
    if (exp && !exp.content.trim()) {
        exp = undefined;
    }
    let isCacheable = !exp;
    if (exp) {
        const isMemberExp = isMemberExpression(exp.content);
        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
        const hasMultipleStatements = exp.content.includes(`;`);
        if (isInlineStatement || (isCacheable && isMemberExp)) {
            // wrap inline statement in a function expression
            exp = createCompoundExpression([
                `$event => ${hasMultipleStatements ? `{` : `(`}`,
                exp,
                hasMultipleStatements ? `}` : `)`
            ]);
        }
    }
    let ret = {
        props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
        ]
    };
    // apply extended compiler augmentor
    if (augmentor) {
        ret = augmentor(ret);
    }
    if (isCacheable) {
        // cache handlers so that it's always the same handler being passed down.
        // this avoids unnecessary re-renders when users use inline handlers on
        // components.
        ret.props[0].value = context.cache(ret.props[0].value);
    }
    return ret;
};

// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
const transformBind = (dir, node, context) => {
    const { exp, modifiers, loc } = dir;
    const arg = dir.arg;
    if (!exp || (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content)) {
        context.onError(createCompilerError(31 /* X_V_BIND_NO_EXPRESSION */, loc));
    }
    // .prop is no longer necessary due to new patch behavior
    // .sync is replaced by v-model:arg
    if (modifiers.includes('camel')) {
        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {
            if (arg.isStatic) {
                arg.content = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["camelize"])(arg.content);
            }
            else {
                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
        }
        else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
        }
    }
    return {
        props: [
            createObjectProperty(arg, exp || createSimpleExpression('', true, loc))
        ]
    };
};

// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
const transformText = (node, context) => {
    if (node.type === 0 /* ROOT */ ||
        node.type === 1 /* ELEMENT */ ||
        node.type === 11 /* FOR */ ||
        node.type === 10 /* IF_BRANCH */) {
        // perform the transform on node exit so that all expressions have already
        // been processed.
        return () => {
            const children = node.children;
            let currentContainer = undefined;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child)) {
                    hasText = true;
                    for (let j = i + 1; j < children.length; j++) {
                        const next = children[j];
                        if (isText(next)) {
                            if (!currentContainer) {
                                currentContainer = children[i] = {
                                    type: 8 /* COMPOUND_EXPRESSION */,
                                    loc: child.loc,
                                    children: [child]
                                };
                            }
                            // merge adjacent text node into current
                            currentContainer.children.push(` + `, next);
                            children.splice(j, 1);
                            j--;
                        }
                        else {
                            currentContainer = undefined;
                            break;
                        }
                    }
                }
            }
            if (!hasText ||
                // if this is a plain element with a single text child, leave it
                // as-is since the runtime has dedicated fast path for this by directly
                // setting textContent of the element.
                // for component root it's always normalized anyway.
                (children.length === 1 &&
                    (node.type === 0 /* ROOT */ ||
                        (node.type === 1 /* ELEMENT */ &&
                            node.tagType === 0 /* ELEMENT */)))) {
                return;
            }
            // pre-convert text nodes into createTextVNode(text) calls to avoid
            // runtime normalization.
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {
                    const callArgs = [];
                    // createTextVNode defaults to single whitespace, so if it is a
                    // single space the code could be an empty call to save bytes.
                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {
                        callArgs.push(child);
                    }
                    // mark dynamic text with flag so it gets patched inside a block
                    if (!context.ssr && child.type !== 2 /* TEXT */) {
                        callArgs.push(`${1 /* TEXT */} /* ${_vue_shared__WEBPACK_IMPORTED_MODULE_0__["PatchFlagNames"][1 /* TEXT */]} */`);
                    }
                    children[i] = {
                        type: 12 /* TEXT_CALL */,
                        content: child,
                        loc: child.loc,
                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                    };
                }
            }
        };
    }
};

const transformOnce = (node, context) => {
    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {
        context.helper(SET_BLOCK_TRACKING);
        return () => {
            if (node.codegenNode) {
                node.codegenNode = context.cache(node.codegenNode, true /* isVNode */);
            }
        };
    }
};

const transformModel = (dir, node, context) => {
    const { exp, arg } = dir;
    if (!exp) {
        context.onError(createCompilerError(38 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));
        return createTransformProps();
    }
    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : exp.loc.source;
    if (!isMemberExpression(expString)) {
        context.onError(createCompilerError(39 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));
        return createTransformProps();
    }
    const propName = arg ? arg : createSimpleExpression('modelValue', true);
    const eventName = arg
        ? arg.type === 4 /* SIMPLE_EXPRESSION */ && arg.isStatic
            ? `onUpdate:${arg.content}`
            : createCompoundExpression(['"onUpdate:" + ', arg])
        : `onUpdate:modelValue`;
    const props = [
        // modelValue: foo
        createObjectProperty(propName, dir.exp),
        // "onUpdate:modelValue": $event => (foo = $event)
        createObjectProperty(eventName, createCompoundExpression([`$event => (`, exp, ` = $event)`]))
    ];
    // modelModifiers: { foo: true, "bar-baz": true }
    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {
        const modifiers = dir.modifiers
            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)
            .join(`, `);
        const modifiersKey = arg
            ? arg.type === 4 /* SIMPLE_EXPRESSION */ && arg.isStatic
                ? `${arg.content}Modifiers`
                : createCompoundExpression([arg, ' + "Modifiers"'])
            : `modelModifiers`;
        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, true)));
    }
    return createTransformProps(props);
};
function createTransformProps(props = []) {
    return { props };
}

function getBaseTransformPreset(prefixIdentifiers) {
    return [
        [
            transformOnce,
            transformIf,
            transformFor,
            ...( []),
            transformSlotOutlet,
            transformElement,
            trackSlotScopes,
            transformText
        ],
        {
            on: transformOn,
            bind: transformBind,
            model: transformModel
        }
    ];
}
// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === 'module';
    /* istanbul ignore if */
    {
        if (options.prefixIdentifiers === true) {
            onError(createCompilerError(43 /* X_PREFIX_ID_NOT_SUPPORTED */));
        }
        else if (isModuleMode) {
            onError(createCompilerError(44 /* X_MODULE_MODE_NOT_SUPPORTED */));
        }
    }
    const prefixIdentifiers = !true ;
    if ( options.cacheHandlers) {
        onError(createCompilerError(45 /* X_CACHE_HANDLER_NOT_SUPPORTED */));
    }
    if (options.scopeId && !isModuleMode) {
        onError(createCompilerError(46 /* X_SCOPE_ID_NOT_SUPPORTED */));
    }
    const ast = Object(_vue_shared__WEBPACK_IMPORTED_MODULE_0__["isString"])(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, {
        ...options,
        prefixIdentifiers,
        nodeTransforms: [
            ...nodeTransforms,
            ...(options.nodeTransforms || []) // user transforms
        ],
        directiveTransforms: {
            ...directiveTransforms,
            ...(options.directiveTransforms || {}) // user transforms
        }
    });
    return generate(ast, {
        ...options,
        prefixIdentifiers
    });
}

const noopDirectiveTransform = () => ({ props: [] });




/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const makeMap_1 = __webpack_require__(65);
exports.parserOptionsMinimal = {
    isVoidTag: () => false,
    isNativeTag: (tag) => {
        return exports.isTree2dTag(tag);
    },
    isPreTag: () => false,
};
const TREE2D_TAGS = "container,direct-container,rectangle,picture,text,paragraph,styled-rectangle,drawing,texture,svg,grayscale,rounded,shader,box-blur";
exports.isTree2dTag = makeMap_1.makeMap(TREE2D_TAGS);


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Make a map and return a function for checking if a key
// is in that map.
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
exports.makeMap = makeMap;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = __webpack_require__(67);
const Comment_1 = __webpack_require__(141);
const TextNode_1 = __webpack_require__(142);
exports.nodeOps = (stage) => ({
    insert: (child, parent, anchor) => {
        if (anchor != null) {
            parent._insertBefore(child, anchor);
        }
        else {
            parent._appendChild(child);
        }
    },
    remove: (child) => {
        const parent = child.parent;
        if (parent != null) {
            parent._removeChild(child);
        }
    },
    createElement: (tag, isSVG) => {
        let type = types_1.types[tag];
        if (!type) {
            console.warn(`Unknown native tag: ${tag}`);
            type = types_1.types["container"];
        }
        return new type(stage);
    },
    createText: (text) => {
        return new TextNode_1.TextNode(text);
    },
    createComment: (text) => {
        return new Comment_1.Comment(text);
    },
    setText: (node, text) => {
        // Noop
    },
    setElementText: (node, text) => {
        node.setElementText(text);
    },
    parentNode: (node) => (node.parent ? node.parent : null),
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => {
        var _a;
        if (selector.startsWith("#")) {
            selector = selector.substr(1);
        }
        return ((_a = stage.getById(selector)) === null || _a === void 0 ? void 0 : _a.data) || null;
    },
});


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const textures_1 = __webpack_require__(9);
const textures_2 = __webpack_require__(9);
const textures_3 = __webpack_require__(9);
const Paragraph_1 = __webpack_require__(59);
const Container_1 = __webpack_require__(6);
const textures_4 = __webpack_require__(9);
const textures_5 = __webpack_require__(9);
const textures_6 = __webpack_require__(9);
const textures_7 = __webpack_require__(9);
const effects_1 = __webpack_require__(13);
const effects_2 = __webpack_require__(13);
const effects_3 = __webpack_require__(13);
const effects_4 = __webpack_require__(13);
const DirectContainer_1 = __webpack_require__(35);
exports.types = {
    container: Container_1.Container,
    // textures
    picture: textures_1.Picture,
    rectangle: textures_2.Rectangle,
    text: textures_3.TextTexture,
    "styled-rectangle": textures_4.StyledRectangle,
    drawing: textures_5.Drawing,
    texture: textures_6.Texture,
    svg: textures_7.Svg,
    // effects
    grayscale: effects_1.Grayscale,
    rounded: effects_2.Rounded,
    "box-blur": effects_4.BoxBlur,
    shader: effects_3.Shader,
    // advanced
    paragraph: Paragraph_1.Paragraph,
    "direct-container": DirectContainer_1.DirectContainer,
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tree2d_1 = __webpack_require__(4);
const DynamicSizeTexture_1 = __webpack_require__(17);
class Drawing extends DynamicSizeTexture_1.DynamicSizeTexture {
    constructor(stage) {
        super(stage);
        this.drawingTexture = new tree2d_1.DrawingTexture(this.stage);
        this.textureElement.texture = this.drawingTexture;
    }
    set onDraw(f) {
        this.drawingTexture.drawingFunction = f;
    }
    handleResize(element, w, h) {
        this.drawingTexture.canvasWidth = w;
        this.drawingTexture.canvasHeight = h;
    }
    update() {
        this.drawingTexture._changed();
    }
}
exports.Drawing = Drawing;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dShader_1 = __webpack_require__(22);
exports.C2dShader = C2dShader_1.C2dShader;
const C2dDefaultShader_1 = __webpack_require__(15);
exports.C2dDefaultShader = C2dDefaultShader_1.C2dDefaultShader;
const C2dGrayscaleShader_1 = __webpack_require__(37);
exports.C2dGrayscaleShader = C2dGrayscaleShader_1.C2dGrayscaleShader;
const C2dBlurShader_1 = __webpack_require__(71);
exports.C2dBlurShader = C2dBlurShader_1.C2dBlurShader;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class WebGLShaderProgram {
    constructor(gl, vertexShaderSource, fragmentShaderSource) {
        this.gl = gl;
        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;
        this._program = undefined;
        this._uniformLocations = new Map();
        this._attributeLocations = new Map();
        this._currentUniformValues = {};
    }
    compile() {
        if (this._program)
            return;
        const gl = this.gl;
        this._program = gl.createProgram();
        const glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
        const glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);
        gl.attachShader(this._program, glVertShader);
        gl.attachShader(this._program, glFragShader);
        gl.linkProgram(this._program);
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
            console.error("Error: Could not initialize shader.");
            console.error("gl.VALIDATE_STATUS", gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
            console.error("gl.getError()", gl.getError());
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(this._program) !== "") {
                console.warn("Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(this._program));
            }
            gl.deleteProgram(this._program);
            this._program = undefined;
        }
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
    }
    _glCompile(type, src) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.log(this.constructor.name, "Type: " + (type === this.gl.VERTEX_SHADER ? "vertex shader" : "fragment shader"));
            console.log(this.gl.getShaderInfoLog(shader));
            let idx = 0;
            console.log("========== source ==========\n" +
                src
                    .split("\n")
                    .map((line) => "" + ++idx + ": " + line)
                    .join("\n"));
            return null;
        }
        return shader;
    }
    getUniformLocation(name) {
        let location = this._uniformLocations.get(name);
        if (location === undefined) {
            location = this.gl.getUniformLocation(this._program, name);
            this._uniformLocations.set(name, location);
        }
        return location;
    }
    getAttribLocation(name) {
        let location = this._attributeLocations.get(name);
        if (location === undefined) {
            location = this.gl.getAttribLocation(this._program, name);
            this._attributeLocations.set(name, location);
        }
        return location;
    }
    destroy() {
        if (this._program) {
            this.gl.deleteProgram(this._program);
            this._program = undefined;
        }
    }
    get glProgram() {
        return this._program;
    }
    get compiled() {
        return !!this._program;
    }
    static _valueEquals(v1, v2) {
        // Uniform value is either a typed array or a numeric value.
        if (v1.length && v2.length) {
            for (let i = 0, n = v1.length; i < n; i++) {
                if (v1[i] !== v2[i])
                    return false;
            }
            return true;
        }
        else {
            return v1 === v2;
        }
    }
    static _valueClone(v) {
        if (v.length) {
            return v.slice(0);
        }
        else {
            return v;
        }
    }
    setUniformValue(name, value, glFunction) {
        const v = this._currentUniformValues[name];
        if (v === undefined || !WebGLShaderProgram._valueEquals(v, value)) {
            const clonedValue = WebGLShaderProgram._valueClone(value);
            this._currentUniformValues[name] = clonedValue;
            const loc = this.getUniformLocation(name);
            if (loc) {
                const isMatrix = glFunction === this.gl.uniformMatrix2fv ||
                    glFunction === this.gl.uniformMatrix3fv ||
                    glFunction === this.gl.uniformMatrix4fv;
                if (isMatrix) {
                    glFunction.call(this.gl, loc, false, clonedValue);
                }
                else {
                    glFunction.call(this.gl, loc, clonedValue);
                }
            }
        }
    }
}
exports.WebGLShaderProgram = WebGLShaderProgram;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dDefaultShader_1 = __webpack_require__(15);
class C2dBlurShader extends C2dDefaultShader_1.C2dDefaultShader {
    constructor() {
        super(...arguments);
        this._kernelRadius = 1;
    }
    get kernelRadius() {
        return this._kernelRadius;
    }
    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }
    useDefault() {
        return this._kernelRadius === 0;
    }
    _beforeDrawEl(info) {
        info.target.context.filter = "blur(" + this._kernelRadius + "px)";
    }
    _afterDrawEl(info) {
        info.target.context.filter = "none";
    }
}
exports.C2dBlurShader = C2dBlurShader;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var WebGLShader_1 = __webpack_require__(23);
exports.WebGLShader = WebGLShader_1.WebGLShader;
var WebGLDefaultShader_1 = __webpack_require__(5);
exports.WebGLDefaultShader = WebGLDefaultShader_1.WebGLDefaultShader;
var WebGLGrayscaleShader_1 = __webpack_require__(38);
exports.WebGLGrayscaleShader = WebGLGrayscaleShader_1.WebGLGrayscaleShader;
var WebGLBoxBlurShader_1 = __webpack_require__(73);
exports.WebGLBoxBlurShader = WebGLBoxBlurShader_1.WebGLBoxBlurShader;
var WebGLDitheringShader_1 = __webpack_require__(74);
exports.WebGLDitheringShader = WebGLDitheringShader_1.WebGLDitheringShader;
var WebGLCircularPushShader_1 = __webpack_require__(75);
exports.WebGLCircularPushShader = WebGLCircularPushShader_1.WebGLCircularPushShader;
var WebGLInversionShader_1 = __webpack_require__(76);
exports.WebGLInversionShader = WebGLInversionShader_1.WebGLInversionShader;
var WebGLLinearBlurShader_1 = __webpack_require__(77);
exports.WebGLLinearBlurShader = WebGLLinearBlurShader_1.WebGLLinearBlurShader;
var WebGLOutlineShader_1 = __webpack_require__(78);
exports.WebGLOutlineShader = WebGLOutlineShader_1.WebGLOutlineShader;
var WebGLPixelateShader_1 = __webpack_require__(79);
exports.WebGLPixelateShader = WebGLPixelateShader_1.WebGLPixelateShader;
var WebGLRadialFilterShader_1 = __webpack_require__(80);
exports.WebGLRadialFilterShader = WebGLRadialFilterShader_1.WebGLRadialFilterShader;
var WebGLRoundedRectangleShader_1 = __webpack_require__(81);
exports.WebGLRoundedRectangleShader = WebGLRoundedRectangleShader_1.WebGLRoundedRectangleShader;
var WebGLRadialGradientShader_1 = __webpack_require__(82);
exports.WebGLRadialGradientShader = WebGLRadialGradientShader_1.WebGLRadialGradientShader;
var WebGLLight3dShader_1 = __webpack_require__(83);
exports.WebGLLight3dShader = WebGLLight3dShader_1.WebGLLight3dShader;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
/**
 * 4x4 box blur shader which works in conjunction with a 50% rescale.
 */
class WebGLBoxBlurShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    setupUniforms(operation) {
        super.setupUniforms(operation);
        const dx = 1.0 / operation.getTextureWidth(0);
        const dy = 1.0 / operation.getTextureHeight(0);
        this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
    }
}
exports.WebGLBoxBlurShader = WebGLBoxBlurShader;
WebGLBoxBlurShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLBoxBlurShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const NoiseTexture_1 = __webpack_require__(39);
const WebGLDefaultShader_1 = __webpack_require__(5);
/**
 * This shader can be used to fix a problem that is known as 'gradient banding'.
 */
class WebGLDitheringShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor() {
        super(...arguments);
        this._noiseTexture = new NoiseTexture_1.NoiseTexture(this.context.stage);
        this._graining = 1 / 256;
        this._random = false;
    }
    set graining(v) {
        this._graining = v;
        this.redraw();
    }
    get graining() {
        return this._graining;
    }
    set random(v) {
        this._random = v;
        this.redraw();
    }
    get random() {
        return this._random;
    }
    setExtraAttribsInBuffer(operation) {
        // Make sure that the noise texture is uploaded to the GPU.
        this._noiseTexture.load();
        let offset = operation.extraAttribsDataByteOffset / 4;
        const floats = operation.quadList.floats;
        const length = operation.length;
        for (let i = 0; i < length; i++) {
            // Calculate noise texture coordinates so that it spans the full element.
            let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
            let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();
            let ulx = 0;
            let uly = 0;
            if (this._random) {
                ulx = Math.random();
                uly = Math.random();
                brx += ulx;
                bry += uly;
                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = ulx;
                    ulx = brx;
                    brx = t;
                }
                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = uly;
                    uly = bry;
                    bry = t;
                }
            }
            // Specify all corner points.
            floats[offset] = ulx;
            floats[offset + 1] = uly;
            floats[offset + 2] = brx;
            floats[offset + 3] = uly;
            floats[offset + 4] = brx;
            floats[offset + 5] = bry;
            floats[offset + 6] = ulx;
            floats[offset + 7] = bry;
            offset += 8;
        }
    }
    beforeDraw(operation) {
        const gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
        const glTexture = this._noiseTexture.getUpdatedSource().nativeTexture;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }
    getExtraAttribBytesPerVertex() {
        return 8;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
        this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
    }
    enableAttribs() {
        super.enableAttribs();
        const gl = this.gl;
        gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }
    disableAttribs() {
        super.disableAttribs();
        const gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }
    useDefault() {
        return this._graining === 0;
    }
    afterDraw(operation) {
        if (this._random) {
            this.redraw();
        }
    }
}
exports.WebGLDitheringShader = WebGLDitheringShader;
WebGLDitheringShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLDitheringShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLCircularPushShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._inputValue = 0;
        this._maxDerivative = 0.01;
        this._normalizedValue = 0;
        // The offset between buckets. A value between 0 and 1.
        this._offset = 0;
        this._amount = 0.1;
        this._aspectRatio = 1;
        this._offsetX = 0;
        this._offsetY = 0;
        this._valuesTexture = undefined;
        this._values = new Uint8Array([]);
        this._buckets = 0;
        this.buckets = 100;
    }
    get aspectRatio() {
        return this._aspectRatio;
    }
    set aspectRatio(v) {
        this._aspectRatio = v;
        this.redraw();
    }
    get offsetX() {
        return this._offsetX;
    }
    set offsetX(v) {
        this._offsetX = v;
        this.redraw();
    }
    get offsetY() {
        return this._offsetY;
    }
    set offsetY(v) {
        this._offsetY = v;
        this.redraw();
    }
    set amount(v) {
        this._amount = v;
        this.redraw();
    }
    get amount() {
        return this._amount;
    }
    set inputValue(v) {
        this._inputValue = v;
    }
    get inputValue() {
        return this._inputValue;
    }
    set maxDerivative(v) {
        this._maxDerivative = v;
    }
    get maxDerivative() {
        return this._maxDerivative;
    }
    set buckets(v) {
        if (v > 100) {
            console.warn("CircularPushShader: supports max 100 buckets");
            v = 100;
        }
        // This should be set before starting.
        this._buckets = v;
        // Init values array in the correct length.
        this._values = new Uint8Array(this._getValues(v));
        this.redraw();
    }
    get buckets() {
        return this._buckets;
    }
    _getValues(n) {
        const v = [];
        for (let i = 0; i < n; i++) {
            v.push(this._inputValue);
        }
        return v;
    }
    /**
     * Progresses the shader with the specified (fractional) number of buckets.
     * @param o - A number from 0 to 1 (1 = all buckets).
     */
    progress(o) {
        this._offset += o * this._buckets;
        const full = Math.floor(this._offset);
        this._offset -= full;
        this._shiftBuckets(full);
        this.redraw();
    }
    _shiftBuckets(n) {
        for (let i = this._buckets - 1; i >= 0; i--) {
            const targetIndex = i - n;
            if (targetIndex < 0) {
                this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                this._values[i] = 255 * this._normalizedValue;
            }
            else {
                this._values[i] = this._values[targetIndex];
            }
        }
    }
    set offset(v) {
        this._offset = v;
        this.redraw();
    }
    get offset() {
        return this._offset;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
        this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
        this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
        this._setUniform("offset", this._offset, this.gl.uniform1f);
        this._setUniform("buckets", this._buckets, this.gl.uniform1f);
        this._setUniform("uValueSampler", 1, this.gl.uniform1i);
    }
    useDefault() {
        return this._amount === 0;
    }
    beforeDraw(operation) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        if (!this._valuesTexture) {
            this._valuesTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        }
        else {
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
        }
        // Upload new values.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
        gl.activeTexture(gl.TEXTURE0);
    }
    cleanup() {
        if (this._valuesTexture) {
            this.gl.deleteTexture(this._valuesTexture);
        }
    }
}
exports.WebGLCircularPushShader = WebGLCircularPushShader;
WebGLCircularPushShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLCircularPushShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLInversionShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._amount = 1;
    }
    set amount(v) {
        this._amount = v;
        this.redraw();
    }
    get amount() {
        return this._amount;
    }
    useDefault() {
        return this._amount === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }
}
exports.WebGLInversionShader = WebGLInversionShader;
WebGLInversionShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLLinearBlurShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._direction = new Float32Array([1, 0]);
        this._kernelRadius = 1;
    }
    get x() {
        return this._direction[0];
    }
    set x(v) {
        this._direction[0] = v;
        this.redraw();
    }
    get y() {
        return this._direction[1];
    }
    set y(v) {
        this._direction[1] = v;
        this.redraw();
    }
    get kernelRadius() {
        return this._kernelRadius;
    }
    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }
    useDefault() {
        return this._kernelRadius === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("direction", this._direction, this.gl.uniform2fv);
        this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);
        const w = operation.getRenderWidth();
        const h = operation.getRenderHeight();
        this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
    }
}
exports.WebGLLinearBlurShader = WebGLLinearBlurShader;
WebGLLinearBlurShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ColorUtils_1 = __webpack_require__(10);
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLOutlineShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._width = 5;
        this._col = 0xffffffff;
        this._color = [1, 1, 1, 1];
    }
    set width(v) {
        this._width = v;
        this.redraw();
    }
    get width() {
        return this._width;
    }
    get color() {
        return this._col;
    }
    set color(v) {
        if (this._col !== v) {
            const col = ColorUtils_1.ColorUtils.getRgbaComponentsNormalized(v);
            col[0] = col[0] * col[3];
            col[1] = col[1] * col[3];
            col[2] = col[2] * col[3];
            this._color = col;
            this.redraw();
            this._col = v;
        }
    }
    useDefault() {
        return this._width === 0 || this._color[3] === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        const gl = this.gl;
        this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
    }
    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aCorner"));
    }
    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aCorner"));
    }
    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        const floats = operation.quadList.floats;
        const length = operation.length;
        for (let i = 0; i < length; i++) {
            const elementCore = operation.getElementCore(i);
            // We are setting attributes such that if the value is < 0 or > 1, a border should be drawn.
            const ddw = this._width / elementCore.getLayoutW();
            const dw = ddw / (1 - 2 * ddw);
            const ddh = this._width / elementCore.getLayoutH();
            const dh = ddh / (1 - 2 * ddh);
            // Specify all corner points.
            floats[offset] = -dw;
            floats[offset + 1] = -dh;
            floats[offset + 2] = 1 + dw;
            floats[offset + 3] = -dh;
            floats[offset + 4] = 1 + dw;
            floats[offset + 5] = 1 + dh;
            floats[offset + 6] = -dw;
            floats[offset + 7] = 1 + dh;
            offset += 8;
        }
    }
    beforeDraw(operation) {
        const gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    }
    getExtraAttribBytesPerVertex() {
        return 8;
    }
}
exports.WebGLOutlineShader = WebGLOutlineShader;
WebGLOutlineShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLOutlineShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLPixelateShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._size = new Float32Array([4, 4]);
    }
    get x() {
        return this._size[0];
    }
    set x(v) {
        this._size[0] = v;
        this.redraw();
    }
    get y() {
        return this._size[1];
    }
    set y(v) {
        this._size[1] = v;
        this.redraw();
    }
    get size() {
        return this._size[0];
    }
    set size(v) {
        this._size[0] = v;
        this._size[1] = v;
        this.redraw();
    }
    useDefault() {
        return this._size[0] === 0 && this._size[1] === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        const gl = this.gl;
        this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
    }
    getExtraAttribBytesPerVertex() {
        return 8;
    }
    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
    }
    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
    }
    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        const floats = operation.quadList.floats;
        const length = operation.length;
        for (let i = 0; i < length; i++) {
            const w = operation.quadList.getTextureWidth(operation.index + i);
            const h = operation.quadList.getTextureHeight(operation.index + i);
            floats[offset] = w;
            floats[offset + 1] = h;
            floats[offset + 2] = w;
            floats[offset + 3] = h;
            floats[offset + 4] = w;
            floats[offset + 5] = h;
            floats[offset + 6] = w;
            floats[offset + 7] = h;
            offset += 8;
        }
    }
    beforeDraw(operation) {
        const gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
    }
}
exports.WebGLPixelateShader = WebGLPixelateShader;
WebGLPixelateShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLPixelateShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLRadialFilterShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._radius = 0;
        this._cutoff = 1;
    }
    set radius(v) {
        this._radius = v;
        this.redraw();
    }
    get radius() {
        return this._radius;
    }
    set cutoff(v) {
        this._cutoff = v;
        this.redraw();
    }
    get cutoff() {
        return this._cutoff;
    }
    useDefault() {
        return this._radius === 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        // We substract half a pixel to get a better cutoff effect.
        this._setUniform("radius", (2 * (this._radius - 0.5)) / operation.getRenderWidth(), this.gl.uniform1f);
        this._setUniform("cutoff", (0.5 * operation.getRenderWidth()) / this._cutoff, this.gl.uniform1f);
    }
}
exports.WebGLRadialFilterShader = WebGLRadialFilterShader;
WebGLRadialFilterShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;
WebGLRadialFilterShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLRoundedRectangleShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._radius = 0;
    }
    set radius(v) {
        if (v < 1) {
            v = 1;
        }
        this._radius = v;
        this.redraw();
    }
    get radius() {
        return this._radius;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const pixelRatio = this.context.stage.getPixelRatio();
        this._setUniform("radius", (this._radius + 0.5) * pixelRatio, this.gl.uniform1f);
        this._setUniform("resolution", new Float32Array([owner.getLayoutW() * pixelRatio, owner.getLayoutH() * pixelRatio]), this.gl.uniform2fv);
    }
}
exports.WebGLRoundedRectangleShader = WebGLRoundedRectangleShader;
WebGLRoundedRectangleShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLRoundedRectangleShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    #define PI 3.14159265359
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform float radius;
    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(0.0, 1.0, d);
    }
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        float b = roundBox(vTextureCoord.xy * resolution - halfRes, halfRes, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
const ColorUtils_1 = __webpack_require__(10);
class WebGLRadialGradientShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor() {
        super(...arguments);
        this._x = 0;
        this._y = 0;
        this._radiusX = 100;
        this._radiusY = 100;
        this._color = 0xffffffff;
        this._rawColor = new Float32Array([255, 255, 255, 255]);
    }
    set x(v) {
        this._x = v;
        this.redraw();
    }
    get x() {
        return this._x;
    }
    set y(v) {
        this._y = v;
        this.redraw();
    }
    get y() {
        return this._y;
    }
    set radiusX(v) {
        this._radiusX = v;
        this.redraw();
    }
    get radiusX() {
        return this._radiusX;
    }
    set radiusY(v) {
        this._radiusY = v;
        this.redraw();
    }
    get radiusY() {
        return this._radiusY;
    }
    set radius(v) {
        this.radiusX = v;
        this.radiusY = v;
    }
    get radius() {
        return this.radiusX;
    }
    get color() {
        return this._color;
    }
    set color(v) {
        if (this._color !== v) {
            const col = ColorUtils_1.ColorUtils.getRgbaComponentsNormalized(v);
            col[0] = col[0] * col[3];
            col[1] = col[1] * col[3];
            col[2] = col[2] * col[3];
            this._rawColor = new Float32Array(col);
            this.redraw();
            this._color = v;
        }
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        // We substract half a pixel to get a better cutoff effect.
        const rtc = operation.getNormalRenderTextureCoords(this._x, this._y);
        this._setUniform("center", new Float32Array(rtc), this.gl.uniform2fv);
        this._setUniform("radius", (2 * this._radiusX) / operation.getRenderWidth(), this.gl.uniform1f);
        // Radial gradient shader is expected to be used on a single element. That element's alpha is used.
        this._setUniform("alpha", operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform("color", this._rawColor, this.gl.uniform4fv);
        this._setUniform("aspectRatio", ((this._radiusX / this._radiusY) * operation.getRenderHeight()) / operation.getRenderWidth(), this.gl.uniform1f);
    }
}
exports.WebGLRadialGradientShader = WebGLRadialGradientShader;
WebGLRadialGradientShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform vec2 center;
    uniform float aspectRatio;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy - center;
        pos.y = pos.y * aspectRatio;
    }
`;
WebGLRadialGradientShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 pos;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform vec4 color;
    uniform float alpha;
    void main(void){
        float dist = length(pos);
        gl_FragColor = mix(color * alpha, texture2D(uSampler, vTextureCoord) * vColor, min(1.0, dist / radius));
    }
`;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WebGLDefaultShader_1 = __webpack_require__(5);
class WebGLLight3dShader extends WebGLDefaultShader_1.WebGLDefaultShader {
    constructor(context) {
        super(context);
        this._strength = 0.5;
        this._ambient = 0.5;
        this._fudge = 0.4;
        this._rx = 0;
        this._ry = 0;
        this._z = 0;
        this._pivotX = NaN;
        this._pivotY = NaN;
        this._pivotZ = NaN;
        this._lightY = 0;
        this._lightZ = 0;
    }
    setupUniforms(operation) {
        super.setupUniforms(operation);
        const vr = operation.shaderOwner;
        const element = vr.element;
        const pivotX = isNaN(this._pivotX) ? element.pivotX * vr.getLayoutW() : this._pivotX;
        const pivotY = isNaN(this._pivotY) ? element.pivotY * vr.getLayoutH() : this._pivotY;
        const coords = vr.getRenderTextureCoords(pivotX, pivotY);
        // Counter normal rotation.
        const rz = -Math.atan2(vr.renderContext.tc, vr.renderContext.ta);
        const gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("lightY", this.lightY, gl.uniform1f);
        this._setUniform("lightZ", this.lightZ, gl.uniform1f);
        this._setUniform("strength", this._strength, gl.uniform1f);
        this._setUniform("ambient", this._ambient, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }
    set strength(v) {
        this._strength = v;
        this.redraw();
    }
    get strength() {
        return this._strength;
    }
    set ambient(v) {
        this._ambient = v;
        this.redraw();
    }
    get ambient() {
        return this._ambient;
    }
    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }
    get fudge() {
        return this._fudge;
    }
    get rx() {
        return this._rx;
    }
    set rx(v) {
        this._rx = v;
        this.redraw();
    }
    get ry() {
        return this._ry;
    }
    set ry(v) {
        this._ry = v;
        this.redraw();
    }
    get z() {
        return this._z;
    }
    set z(v) {
        this._z = v;
        this.redraw();
    }
    get pivotX() {
        return this._pivotX;
    }
    set pivotX(v) {
        this._pivotX = v + 1;
        this.redraw();
    }
    get pivotY() {
        return this._pivotY;
    }
    set pivotY(v) {
        this._pivotY = v + 1;
        this.redraw();
    }
    get lightY() {
        return this._lightY;
    }
    set lightY(v) {
        this._lightY = v;
        this.redraw();
    }
    get pivotZ() {
        return this._pivotZ;
    }
    set pivotZ(v) {
        this._pivotZ = v;
        this.redraw();
    }
    get lightZ() {
        return this._lightZ;
    }
    set lightZ(v) {
        this._lightZ = v;
        this.redraw();
    }
    useDefault() {
        return this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1;
    }
}
exports.WebGLLight3dShader = WebGLLight3dShader;
WebGLLight3dShader.prototype.vertexShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;
WebGLLight3dShader.prototype.fragmentShaderSource = `
    #ifdef GL_ES
    precision lowp float;
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class DrawingTexture extends Texture_1.Texture {
    constructor() {
        super(...arguments);
        this._drawingFunction = undefined;
        this._canvasWidth = 0;
        this._canvasHeight = 0;
    }
    set drawingFunction(f) {
        this._drawingFunction = f;
        this._changed();
    }
    get drawingFunction() {
        return this._drawingFunction;
    }
    set canvasWidth(v) {
        if (this._canvasWidth !== v) {
            this._canvasWidth = v;
            this._changed();
        }
    }
    set canvasHeight(v) {
        if (this._canvasHeight !== v) {
            this._canvasHeight = v;
            this._changed();
        }
    }
    _getIsValid() {
        return !!this._drawingFunction && this._canvasWidth > 0 && this._canvasHeight > 0;
    }
    _getSourceLoader() {
        return (cb) => {
            const canvas = this.stage.platform.getDrawingCanvas();
            canvas.width = this._canvasWidth;
            canvas.height = this._canvasHeight;
            const context = canvas.getContext("2d");
            context.imageSmoothingEnabled = true;
            let result;
            try {
                result = this._drawingFunction({ context, w: this._canvasWidth, h: this._canvasHeight });
            }
            catch (e) {
                if (e instanceof Error) {
                    cb(e);
                }
                else {
                    cb(new Error("Error while drawing: " + e));
                }
                return;
            }
            const handleResult = (result) => {
                const textureSourceOptions = result;
                textureSourceOptions.source = canvas;
                cb(undefined, textureSourceOptions);
            };
            if (result instanceof Promise) {
                result.then((r) => handleResult(r)).catch((e) => cb(e));
            }
            else {
                handleResult(result);
            }
        };
    }
}
exports.DrawingTexture = DrawingTexture;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class HtmlTexture extends Texture_1.Texture {
    constructor() {
        super(...arguments);
        this._htmlElement = undefined;
        this._scale = 1;
    }
    set htmlElement(v) {
        this._htmlElement = v;
        this._changed();
    }
    get htmlElement() {
        return this._htmlElement;
    }
    set scale(v) {
        this._scale = v;
        this._changed();
    }
    get scale() {
        return this._scale;
    }
    set html(v) {
        if (!v) {
            this.htmlElement = undefined;
        }
        else {
            const d = document.createElement("div");
            d.innerHTML = "<div>" + v + "</div>";
            if (d.firstElementChild) {
                this.htmlElement = d.firstElementChild;
            }
        }
    }
    get html() {
        return this._htmlElement ? this._htmlElement.innerHTML : "";
    }
    _getIsValid() {
        return !!this.htmlElement;
    }
    _getLookupId() {
        return this._scale + ":" + this.html;
    }
    _getSourceLoader() {
        const htmlElement = this._htmlElement;
        const scale = this._scale;
        return (cb) => {
            const html2canvas = window.html2canvas;
            if (!window.html2canvas) {
                return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
            }
            const area = HtmlTexture.getPreloadArea();
            area.appendChild(htmlElement);
            html2canvas(htmlElement, { backgroundColor: null, scale })
                .then((canvas) => {
                area.removeChild(htmlElement);
                if (canvas.height === 0) {
                    return cb(new Error("Canvas height is 0"));
                }
                cb(undefined, { source: canvas, width: canvas.width, height: canvas.height });
            })
                .catch((e) => {
                console.error(e);
            });
        };
    }
    static getPreloadArea() {
        if (!this._preloadArea) {
            // Preload area must be included in document body and must be visible to trigger html element rendering.
            this._preloadArea = document.createElement("div");
            if (this._preloadArea.attachShadow) {
                // Use a shadow DOM if possible to prevent styling from interfering.
                this._preloadArea.attachShadow({ mode: "closed" });
            }
            this._preloadArea.style.opacity = "0";
            this._preloadArea.style.pointerEvents = "none";
            this._preloadArea.style.position = "fixed";
            this._preloadArea.style.display = "block";
            this._preloadArea.style.top = "100vh";
            this._preloadArea.style.overflow = "hidden";
            document.body.appendChild(this._preloadArea);
        }
        return this._preloadArea;
    }
}
exports.HtmlTexture = HtmlTexture;
HtmlTexture._preloadArea = undefined;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class ImageTexture extends Texture_1.Texture {
    constructor() {
        super(...arguments);
        this._src = undefined;
        this._hasAlpha = false;
    }
    get src() {
        return this._src;
    }
    set src(v) {
        if (this._src !== v) {
            this._src = v;
            this._changed();
        }
    }
    get hasAlpha() {
        return this._hasAlpha;
    }
    set hasAlpha(v) {
        if (this._hasAlpha !== v) {
            this._hasAlpha = v;
            this._changed();
        }
    }
    _getIsValid() {
        return !!this._src;
    }
    _getLookupId() {
        return this._src;
    }
    _getSourceLoader() {
        const src = this._src;
        const hasAlpha = this._hasAlpha;
        return (cb) => {
            return this.stage.platform.loadSrcTexture({ src, hasAlpha }, cb);
        };
    }
    getNonDefaults() {
        const obj = super.getNonDefaults();
        if (this._src) {
            obj.src = this._src;
        }
        return obj;
    }
}
exports.ImageTexture = ImageTexture;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class RectangleTexture extends Texture_1.Texture {
    constructor(stage) {
        super(stage);
        this.stage = stage;
        // For performance reasons, we skip all element and active count registration for this specific texture type.
        // This means that clipping will also not work, but that doesn't matter for rectangles anyway.
        this.becomesUsed();
    }
    _getLookupId() {
        return "__whitepix";
    }
    _getSourceLoader() {
        return (cb) => {
            const whitePixel = new Uint8Array([255, 255, 255, 255]);
            cb(undefined, { source: whitePixel, width: 1, height: 1, permanent: true });
        };
    }
    addElement(v) {
        // Ignore.
    }
    removeElement(v) {
        // Ignore.
    }
    incActiveCount() {
        // Ignore.
    }
    decActiveCount() {
        // Ignore.
    }
    isAutosizeTexture() {
        return false;
    }
}
exports.RectangleTexture = RectangleTexture;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
const Utils_1 = __webpack_require__(7);
const ColorUtils_1 = __webpack_require__(10);
class RoundRectTexture extends Texture_1.Texture {
    constructor(stage) {
        super(stage);
        this._options = undefined;
        this.pixelRatio = this.stage.pixelRatio;
    }
    set options(options) {
        this._options = options;
        this._changed();
    }
    get options() {
        return this._options;
    }
    _getIsValid() {
        return !!this._options && !!this._options.w && !!this._options.h;
    }
    _getLookupId() {
        return "RC$" + Texture_1.Texture.getLookupIdFromSettings(this._options) + "|" + this.pixelRatio;
    }
    _getSourceLoader() {
        const options = Utils_1.Utils.clone(this._options);
        const pixelRatio = this.pixelRatio;
        return (cb) => {
            const canvas = this.stage.platform.getDrawingCanvas();
            const renderInfo = RoundRectTexture.drawOnCanvas(canvas, options, pixelRatio);
            cb(undefined, { source: canvas, renderInfo });
        };
    }
    static drawOnCanvas(canvas, options, pixelRatio) {
        let { w, h, radius = [0, 0, 0, 0], strokeWidth = 0, shadowBlur = 0, shadowOffsetX = 0, shadowOffsetY = 0, } = options;
        const { strokeColor = 0xffffffff, fill = true, fillColor = 0xffffffff, shadowColor = 0xffffffff } = options;
        w *= pixelRatio;
        h *= pixelRatio;
        radius = radius.map((r) => r * pixelRatio);
        strokeWidth *= pixelRatio;
        shadowBlur *= pixelRatio;
        shadowOffsetX *= pixelRatio;
        shadowOffsetY *= pixelRatio;
        const context = canvas.getContext("2d");
        context.imageSmoothingEnabled = true;
        canvas.width = w + strokeWidth + 2 + shadowBlur * 2 + Math.abs(shadowOffsetX);
        canvas.height = h + strokeWidth + 2 + shadowBlur * 2 + Math.abs(shadowOffsetY);
        context.beginPath();
        const x = 0.5 * strokeWidth + 1 + shadowBlur - Math.max(0, shadowOffsetX);
        const y = 0.5 * strokeWidth + 1 + shadowBlur - Math.max(0, shadowOffsetY);
        context.moveTo(x + radius[0], y);
        context.lineTo(x + w - radius[1], y);
        context.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        context.lineTo(x + w, y + h - radius[2]);
        context.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        context.lineTo(x + radius[3], y + h);
        context.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        context.lineTo(x, y + radius[0]);
        context.arcTo(x, y, x + radius[0], y, radius[0]);
        context.closePath();
        if (shadowBlur) {
            context.shadowBlur = shadowBlur;
            context.shadowOffsetX = shadowOffsetX;
            context.shadowOffsetY = shadowOffsetY;
            context.shadowColor = this.convertToCanvasColor(shadowColor);
        }
        if (strokeWidth) {
            context.strokeStyle = this.convertToCanvasColor(strokeColor);
            context.lineWidth = strokeWidth;
            context.stroke();
        }
        if (fill) {
            context.fillStyle = this.convertToCanvasColor(fillColor);
            context.fill();
        }
        return { offsetX: x / pixelRatio, offsetY: y / pixelRatio };
    }
    static convertToCanvasColor(c) {
        if (Utils_1.Utils.isNumber(c)) {
            return ColorUtils_1.ColorUtils.getRgbaString(c);
        }
        else {
            return c;
        }
    }
}
exports.RoundRectTexture = RoundRectTexture;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
class SourceTexture extends Texture_1.Texture {
    constructor() {
        super(...arguments);
        this._textureSource = undefined;
    }
    get textureSource() {
        return this._textureSource;
    }
    set textureSource(v) {
        if (v !== this._textureSource) {
            if (v && v.isResultTexture) {
                // In case of a result texture, automatically inherit the pixel ratio.
                this.pixelRatio = this.stage.getPixelRatio();
            }
            this._textureSource = v;
            this._changed();
        }
    }
    _getIsValid() {
        return !!this._textureSource;
    }
}
exports.SourceTexture = SourceTexture;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
const Utils_1 = __webpack_require__(7);
class SvgTexture extends Texture_1.Texture {
    constructor(stage) {
        super(stage);
        this._options = undefined;
        this.pixelRatio = this.stage.pixelRatio;
    }
    set options(options) {
        this._options = options;
        this._changed();
    }
    get options() {
        return this._options;
    }
    _getIsValid() {
        return !!this._options && !!this._options.src && !!this._options.w && !!this._options.h;
    }
    _getLookupId() {
        const { w, h, src } = this._options;
        return "svg" + [w, h, src].join(",") + "|" + this.pixelRatio;
    }
    _getSourceLoader() {
        const options = Utils_1.Utils.clone(this._options);
        return (cb) => {
            const canvas = this.stage.platform.getDrawingCanvas();
            const context = canvas.getContext("2d");
            context.imageSmoothingEnabled = true;
            const img = new Image();
            img.onload = () => {
                const w = options.w * this.pixelRatio;
                const h = options.h * this.pixelRatio;
                canvas.width = w;
                canvas.height = h;
                context.drawImage(img, 0, 0, canvas.width, canvas.height);
                cb(undefined, { source: canvas });
            };
            img.onerror = (err) => {
                return cb(new Error("Image load error: " + err.toString()));
            };
            img.src = options.src;
        };
    }
}
exports.SvgTexture = SvgTexture;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(8);
const TextTextureRenderer_1 = __webpack_require__(42);
const Utils_1 = __webpack_require__(7);
class TextTexture extends Texture_1.Texture {
    constructor(stage) {
        super(stage);
        this.settings = {};
        this._text = "";
        this.pixelRatio = this.stage.pixelRatio;
    }
    setSettings(settings) {
        this.settings = settings;
        this._changed();
    }
    get text() {
        return this._text;
    }
    set text(v) {
        if (this._text !== v) {
            this._text = v;
            this._changed();
        }
    }
    get fontWeight() {
        return this.settings.fontWeight;
    }
    set fontWeight(v) {
        if (this.settings.fontWeight !== v) {
            this.settings.fontWeight = v;
            this._changed();
        }
    }
    get fontStyle() {
        return this.settings.fontStyle;
    }
    set fontStyle(v) {
        if (this.settings.fontStyle !== v) {
            this.settings.fontStyle = v;
            this._changed();
        }
    }
    get fontSize() {
        return this.settings.fontSize;
    }
    set fontSize(v) {
        if (this.settings.fontSize !== v) {
            this.settings.fontSize = v;
            this._changed();
        }
    }
    get fontFace() {
        return this.settings.fontFace;
    }
    set fontFace(v) {
        if (this.settings.fontFace !== v) {
            this.settings.fontFace = v;
            this._changed();
        }
    }
    get cutSx() {
        return this.settings.cutSx;
    }
    set cutSx(v) {
        if (this.settings.cutSx !== v) {
            this.settings.cutSx = v;
            this._changed();
        }
    }
    get cutEx() {
        return this.settings.cutEx;
    }
    set cutEx(v) {
        if (this.settings.cutEx !== v) {
            this.settings.cutEx = v;
            this._changed();
        }
    }
    get cutSy() {
        return this.settings.cutSy;
    }
    set cutSy(v) {
        if (this.settings.cutSy !== v) {
            this.settings.cutSy = v;
            this._changed();
        }
    }
    get cutEy() {
        return this.settings.cutEy;
    }
    set cutEy(v) {
        if (this.settings.cutEy !== v) {
            this.settings.cutEy = v;
            this._changed();
        }
    }
    get pixelRatio() {
        return super.pixelRatio;
    }
    set pixelRatio(v) {
        // We actually draw differently when the pixel ratio changes.
        if (this.pixelRatio !== v) {
            super.pixelRatio = v;
            this._changed();
        }
    }
    _getIsValid() {
        return !!this._text;
    }
    _getLookupId() {
        return "TX$" + this.text + "|" + Texture_1.Texture.getLookupIdFromSettings(this.settings) + "|" + this.pixelRatio;
    }
    _getSourceLoader() {
        const args = this.cloneArgs();
        return (cb) => {
            const canvas = this.stage.platform.getDrawingCanvas();
            const renderer = new TextTextureRenderer_1.TextTextureRenderer(this.stage, canvas, this.text, args, this.pixelRatio);
            const p = renderer.draw();
            const respond = () => {
                cb(undefined, Object.assign({ renderInfo: renderer.renderInfo }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
            };
            if (p) {
                p.then(() => {
                    respond();
                }).catch((err) => {
                    cb(err);
                });
            }
            else {
                respond();
            }
        };
    }
    getNonDefaults() {
        const nonDefaults = super.getNonDefaults();
        for (const [key, value] of Object.entries(this.settings)) {
            nonDefaults[key] = value;
        }
        return nonDefaults;
    }
    cloneArgs() {
        return Utils_1.Utils.clone(this.settings);
    }
}
exports.TextTexture = TextTexture;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const ColorUtils_1 = __webpack_require__(10);
exports.ColorUtils = ColorUtils_1.ColorUtils;
const Element_1 = __webpack_require__(16);
exports.Element = Element_1.Element;
const ElementChildList_1 = __webpack_require__(47);
exports.ElementChildList = ElementChildList_1.ElementChildList;
const ElementListeners_1 = __webpack_require__(25);
exports.ElementListeners = ElementListeners_1.ElementListeners;
const ObjectList_1 = __webpack_require__(48);
exports.ObjectList = ObjectList_1.ObjectList;
const Shader_1 = __webpack_require__(14);
exports.Shader = Shader_1.Shader;
const Stage_1 = __webpack_require__(107);
exports.Stage = Stage_1.Stage;
const Texture_1 = __webpack_require__(8);
exports.Texture = Texture_1.Texture;
const TextureManager_1 = __webpack_require__(55);
exports.TextureManager = TextureManager_1.TextureManager;
const TextureSource_1 = __webpack_require__(24);
exports.TextureSource = TextureSource_1.TextureSource;
var CoreContext_1 = __webpack_require__(56);
exports.CoreContext = CoreContext_1.CoreContext;
__export(__webpack_require__(25));
var Utils_1 = __webpack_require__(7);
exports.Utils = Utils_1.Utils;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ElementTexturizer_1 = __webpack_require__(94);
const ElementCoreContext_1 = __webpack_require__(95);
const flexbox_js_1 = __webpack_require__(96);
class ElementCore {
    constructor(element) {
        /**
         * Recalc flags in bits.
         */
        this.flags = 0;
        this._parent = undefined;
        this._onUpdate = undefined;
        this.updatedFlags = 0;
        this._worldContext = new ElementCoreContext_1.ElementCoreContext();
        this._hasUpdates = false;
        this._localAlpha = 1;
        this._onAfterCalcs = undefined;
        this._onAfterUpdate = undefined;
        // All local translation/transform updates: directly propagated from x/y/w/h/scale/whatever.
        this._localPx = 0;
        this._localPy = 0;
        this._localTa = 1;
        this._localTb = 0;
        this._localTc = 0;
        this._localTd = 1;
        this._isComplex = false;
        this._dimsUnknown = false;
        this._clipping = false;
        this._zSort = false;
        this._outOfBounds = 0;
        /**
         * The texture source to be displayed.
         */
        this._displayedTextureSource = undefined;
        this._zContextUsage = 0;
        this._children = undefined;
        this._hasRenderUpdates = 0;
        this._zIndexedChildren = undefined;
        this._renderContext = this._worldContext;
        this._scissor = undefined;
        // The ancestor ElementCore that defined the inherited shader. Undefined if none is active (default shader).
        this._shaderOwner = undefined;
        // Counter while updating the tree order.
        this._updateTreeOrder = 0;
        // Texture corner point colors.
        this._colorUl = 0xffffffff;
        this._colorUr = 0xffffffff;
        this._colorBl = 0xffffffff;
        this._colorBr = 0xffffffff;
        // Internal coords.
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        // Actual settings.
        this._sx = 0;
        this._sy = 0;
        this._sw = 0;
        this._sh = 0;
        // Active texture size.
        this._tw = 0;
        this._th = 0;
        // Defines which relative functions are enabled.
        this._relFuncFlags = 0;
        this._funcX = undefined;
        this._funcY = undefined;
        this._funcW = undefined;
        this._funcH = undefined;
        this._scaleX = 1;
        this._scaleY = 1;
        this._pivotX = 0.5;
        this._pivotY = 0.5;
        this._mountX = 0;
        this._mountY = 0;
        this._rotation = 0;
        this._alpha = 1;
        this._visible = true;
        // Texture clipping.
        this.ulx = 0;
        this.uly = 0;
        this.brx = 1;
        this.bry = 1;
        this._isRoot = false;
        this._zIndex = 0;
        this._forceZIndexContext = false;
        this._zParent = undefined;
        /**
         * Iff true, during next zSort, this element should be 're-sorted' because either:
         * - zIndex did change
         * - zParent did change
         * - element was moved in the render tree
         */
        this._zIndexResort = false;
        this._shader = undefined;
        // Element is rendered on another texture.
        this._renderToTextureEnabled = false;
        // Manages the render texture.
        this._texturizer = undefined;
        this._useRenderToTexture = false;
        this._withinBoundsMargin = false;
        this._viewport = undefined;
        // If this element is out of viewport, the branch is also skipped in updating and rendering.
        this._clipbox = false;
        // The render function. _renderAdvanced is only used if necessary.
        this.render = this._renderSimple;
        // Flex layouting if enabled.
        this._layout = undefined;
        this._stashedTexCoords = undefined;
        this._stashedColors = undefined;
        this._element = element;
        this.context = element.stage.context;
        this.renderState = this.context.renderState;
    }
    getRenderContext() {
        return this._renderContext;
    }
    get x() {
        return this._sx;
    }
    set x(v) {
        const dx = v - this._sx;
        if (dx) {
            this._sx = v;
            if (!this._funcX) {
                this._x += dx;
                this.updateLocalTranslateDelta(dx, 0);
            }
        }
    }
    get funcX() {
        return this._funcX;
    }
    set funcX(v) {
        if (this._funcX !== v) {
            if (v) {
                this._relFuncFlags |= 1;
                this._funcX = v;
            }
            else {
                this._disableFuncX();
            }
            if (this.hasFlexLayout()) {
                this.layout.forceLayout();
            }
            else {
                this._triggerRecalcTranslate();
            }
        }
    }
    _disableFuncX() {
        this._relFuncFlags = this._relFuncFlags & (0xffff - 1);
        this._funcX = undefined;
    }
    get y() {
        return this._sy;
    }
    set y(v) {
        const dy = v - this._sy;
        if (dy) {
            this._sy = v;
            if (!this._funcY) {
                this._y += dy;
                this.updateLocalTranslateDelta(0, dy);
            }
        }
    }
    get funcY() {
        return this._funcY;
    }
    set funcY(v) {
        if (this._funcY !== v) {
            if (v) {
                this._relFuncFlags |= 2;
                this._funcY = v;
            }
            else {
                this._disableFuncY();
            }
            if (this.hasFlexLayout()) {
                this.layout.forceLayout();
            }
            else {
                this._triggerRecalcTranslate();
            }
        }
    }
    _disableFuncY() {
        this._relFuncFlags = this._relFuncFlags & (0xffff - 2);
        this._funcY = undefined;
    }
    get w() {
        return this._sw;
    }
    set w(v) {
        if (this._sw !== v) {
            this._sw = v;
            this._updateBaseDimensions();
        }
    }
    get funcW() {
        return this._funcW;
    }
    set funcW(v) {
        if (this._funcW !== v) {
            if (v) {
                this._relFuncFlags |= 4;
                this._funcW = v;
            }
            else {
                this._disableFuncW();
            }
            this._updateBaseDimensions();
        }
    }
    _disableFuncW() {
        this._relFuncFlags = this._relFuncFlags & (0xffff - 4);
        this._funcW = undefined;
    }
    get h() {
        return this._sh;
    }
    set h(v) {
        if (this._sh !== v) {
            this._sh = v;
            this._updateBaseDimensions();
        }
    }
    get funcH() {
        return this._funcH;
    }
    set funcH(v) {
        if (this._funcH !== v) {
            if (v) {
                this._relFuncFlags |= 8;
                this._funcH = v;
            }
            else {
                this._disableFuncH();
            }
            this._updateBaseDimensions();
        }
    }
    _disableFuncH() {
        this._relFuncFlags = this._relFuncFlags & (0xffff - 8);
        this._funcH = undefined;
    }
    get scaleX() {
        return this._scaleX;
    }
    set scaleX(v) {
        if (this._scaleX !== v) {
            this._scaleX = v;
            this._updateLocalTransform();
        }
    }
    get scaleY() {
        return this._scaleY;
    }
    set scaleY(v) {
        if (this._scaleY !== v) {
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }
    get scale() {
        return this.scaleX;
    }
    set scale(v) {
        if (this._scaleX !== v || this._scaleY !== v) {
            this._scaleX = v;
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }
    get pivotX() {
        return this._pivotX;
    }
    set pivotX(v) {
        if (this._pivotX !== v) {
            this._pivotX = v;
            this._updateLocalTranslate();
        }
    }
    get pivotY() {
        return this._pivotY;
    }
    set pivotY(v) {
        if (this._pivotY !== v) {
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }
    get pivot() {
        return this._pivotX;
    }
    set pivot(v) {
        if (this._pivotX !== v || this._pivotY !== v) {
            this._pivotX = v;
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }
    get mountX() {
        return this._mountX;
    }
    set mountX(v) {
        if (this._mountX !== v) {
            this._mountX = v;
            this._updateLocalTranslate();
        }
    }
    get mountY() {
        return this._mountY;
    }
    set mountY(v) {
        if (this._mountY !== v) {
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }
    get mount() {
        return this._mountX;
    }
    set mount(v) {
        if (this._mountX !== v || this._mountY !== v) {
            this._mountX = v;
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }
    get rotation() {
        return this._rotation;
    }
    set rotation(v) {
        if (this._rotation !== v) {
            this._rotation = v;
            this._updateLocalTransform();
        }
    }
    get alpha() {
        return this._alpha;
    }
    set alpha(v) {
        // Account for rounding errors.
        v = v > 1 ? 1 : v < 1e-14 ? 0 : v;
        if (this._alpha !== v) {
            const prev = this._alpha;
            this._alpha = v;
            this.updateLocalAlpha();
            if ((prev === 0) !== (v === 0)) {
                this._element._updateEnabledFlag();
            }
        }
    }
    get visible() {
        return this._visible;
    }
    set visible(v) {
        if (this._visible !== v) {
            this._visible = v;
            this.updateLocalAlpha();
            this._element._updateEnabledFlag();
            if (this.hasFlexLayout()) {
                this.layout.updateVisible();
            }
        }
    }
    _updateLocalTransform() {
        if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            const _sr = Math.sin(this._rotation);
            const _cr = Math.cos(this._rotation);
            this._setLocalTransform(_cr * this._scaleX, -_sr * this._scaleY, _sr * this._scaleX, _cr * this._scaleY);
        }
        else {
            this._setLocalTransform(this._scaleX, 0, 0, this._scaleY);
        }
        this._updateLocalTranslate();
    }
    _updateLocalTranslate() {
        this.updateLocalTranslate();
        this._triggerRecalcTranslate();
    }
    updateLocalTranslate() {
        const pivotXMul = this._pivotX * this._w;
        const pivotYMul = this._pivotY * this._h;
        let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
        let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
        px -= this._mountX * this._w;
        py -= this._mountY * this._h;
        this._localPx = px;
        this._localPy = py;
    }
    updateLocalTranslateDelta(dx, dy) {
        this._addLocalTranslate(dx, dy);
    }
    updateLocalAlpha() {
        this._setLocalAlpha(this._visible ? this._alpha : 0);
    }
    hasUpdates() {
        return this._hasUpdates;
    }
    hasRenderUpdates() {
        return this._hasRenderUpdates > 0;
    }
    hasRenderTextureUpdates() {
        return this._hasRenderUpdates >= 3;
    }
    clearHasRenderUpdates() {
        this._hasRenderUpdates = 0;
    }
    /**
     * @param level - Level of updates:
     *  0: no updates
     *  1: re-invoke shader
     *  3: re-create render texture and re-invoke shader
     */
    setHasRenderUpdates(level) {
        if (this._worldContext.alpha) {
            // Ignore if 'world invisible'. Render updates will be reset to 3 for every element that becomes visible.
            let p = this;
            p._hasRenderUpdates = Math.max(level, p._hasRenderUpdates);
            while (true) {
                p = p._parent;
                if (!p || p._hasRenderUpdates >= 3) {
                    break;
                }
                p._hasRenderUpdates = 3;
            }
        }
    }
    /**
     * Marks recalculation updates.
     * @param type - What needs to be recalculated
     *  1: alpha
     *  2: translate
     *  4: transform
     *  128: becomes visible
     *  256: flex layout updated
     */
    setFlag(type) {
        this.flags |= type;
        this._setHasUpdates();
        // Any changes in descendants should trigger texture updates.
        if (this._parent) {
            this._parent.setHasRenderUpdates(3);
        }
    }
    _setHasUpdates() {
        let p = this;
        while (p && !p._hasUpdates) {
            p._hasUpdates = true;
            p = p._parent;
        }
    }
    getParent() {
        return this._parent;
    }
    setParent(parent) {
        var _a;
        if (parent !== this._parent) {
            const prevIsZContext = this.isZContext();
            const prevParent = this._parent;
            this._parent = parent;
            // Notify flex layout engine.
            if (this._layout || ((_a = flexbox_js_1.FlexNode.getActiveLayoutNode(parent)) === null || _a === void 0 ? void 0 : _a.isFlexEnabled())) {
                this.layout.setParent(prevParent, parent);
            }
            if (prevParent) {
                // When elements are deleted, the render texture must be re-rendered.
                prevParent.setHasRenderUpdates(3);
            }
            this.setFlag(1 + 2 + 4);
            if (this._parent) {
                // Force parent to propagate hasUpdates flag.
                this._parent._setHasUpdates();
            }
            if (this._zIndex === 0) {
                this.setZParent(parent);
            }
            else {
                this.setZParent(parent ? parent.findZContext() : undefined);
            }
            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                }
                else {
                    const prevZContext = prevParent ? prevParent.findZContext() : undefined;
                    this.enableZContext(prevZContext);
                }
            }
            // Tree order did change: even if zParent stays the same, we must resort.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }
            if (!this._shader) {
                const newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : undefined;
                if (newShaderOwner !== this._shaderOwner) {
                    this.setHasRenderUpdates(1);
                    this._setShaderOwnerRecursive(newShaderOwner);
                }
            }
        }
    }
    enableZSort(force = false) {
        if (!this._zSort && this._zContextUsage > 0) {
            this._zSort = true;
            if (force) {
                // ZSort must be done, even if this element is invisible.
                // This is done to prevent memory leaks when removing element from inactive render branches.
                this.context.forceZSort(this);
            }
        }
    }
    addChildAt(index, child) {
        if (!this._children)
            this._children = [];
        if (this._children.length === index) {
            this._children.push(child);
        }
        else {
            this._children.splice(index, 0, child);
        }
        child.setParent(this);
    }
    setChildAt(index, child) {
        if (!this._children)
            this._children = [];
        this._children[index].setParent(undefined);
        this._children[index] = child;
        child.setParent(this);
    }
    removeChildAt(index) {
        if (this._children) {
            const child = this._children[index];
            this._children.splice(index, 1);
            child.setParent(undefined);
        }
    }
    removeChildren() {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i].setParent(undefined);
            }
            this._children.splice(0);
            if (this._zIndexedChildren) {
                this._zIndexedChildren.splice(0);
            }
        }
    }
    syncChildren(removed, added, order) {
        this._children = order;
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i].setParent(undefined);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            added[i].setParent(this);
        }
    }
    moveChild(fromIndex, toIndex) {
        if (this._children) {
            const c = this._children[fromIndex];
            this._children.splice(fromIndex, 1);
            this._children.splice(toIndex, 0, c);
        }
        // Tree order changed: must resort!
        this._zIndexResort = true;
        if (this._zParent) {
            this._zParent.enableZSort();
        }
    }
    _setLocalTransform(a, b, c, d) {
        this.setFlag(4);
        this._localTa = a;
        this._localTb = b;
        this._localTc = c;
        this._localTd = d;
        // We also regard negative scaling as a complex case, so that we can optimize the non-complex case better.
        this._isComplex = b !== 0 || c !== 0 || a < 0 || d < 0;
    }
    _addLocalTranslate(dx, dy) {
        this._localPx += dx;
        this._localPy += dy;
        this._triggerRecalcTranslate();
    }
    _setLocalAlpha(a) {
        if (!this._worldContext.alpha && this._parent && this._parent._worldContext.alpha && a) {
            // Element is becoming visible. We need to force update.
            this.setFlag(1 + 128);
        }
        else {
            this.setFlag(1);
        }
        if (a < 1e-14) {
            // Tiny rounding errors may cause failing visibility tests.
            a = 0;
        }
        this._localAlpha = a;
    }
    setTextureDimensions(w, h, isEstimate = this._dimsUnknown) {
        // In case of an estimation, the update loop should perform different bound checks.
        this._dimsUnknown = isEstimate;
        if (this._tw !== w || this._th !== h) {
            this._tw = w;
            this._th = h;
            this._updateBaseDimensions();
        }
    }
    _updateBaseDimensions() {
        if (this._funcW || this._funcH) {
            this._triggerRecalcTranslate();
        }
        const w = this._sw || this._tw;
        const h = this._sh || this._th;
        if (this.hasFlexLayout()) {
            // Notify layout.
            this.layout.updatedSourceW();
            this.layout.updatedSourceH();
        }
        else {
            if ((!this._funcW && this._w !== w) || (!this._funcH && this._h !== h)) {
                if (!this._funcW) {
                    this._w = w;
                }
                if (!this._funcH) {
                    this._h = h;
                }
                this.onDimensionsChanged();
            }
        }
    }
    setLayoutCoords(x, y) {
        if (this._x !== x || this._y !== y) {
            this._x = x;
            this._y = y;
            this._updateLocalTranslate();
        }
    }
    setLayoutDimensions(w, h) {
        if (this._w !== w || this._h !== h) {
            this._w = w;
            this._h = h;
            this.onDimensionsChanged();
        }
    }
    onDimensionsChanged() {
        // Due to width/height change: update the translation vector.
        this._updateLocalTranslate();
        if (this._texturizer) {
            this._texturizer.releaseRenderTexture();
            this._texturizer.updateResultTexture();
        }
        this.element._onResize(this._w, this._h);
    }
    setTextureCoords(ulx, uly, brx, bry) {
        this.setHasRenderUpdates(3);
        this.ulx = ulx;
        this.uly = uly;
        this.brx = brx;
        this.bry = bry;
    }
    get displayedTextureSource() {
        return this._displayedTextureSource;
    }
    setDisplayedTextureSource(textureSource) {
        this.setHasRenderUpdates(3);
        this._displayedTextureSource = textureSource;
    }
    get isRoot() {
        return this._isRoot;
    }
    setupAsRoot() {
        // Use parent dummy.
        this._parent = new ElementCore(this._element);
        // After setting root, make sure it's updated.
        this._parent.w = this.context.stage.coordsWidth;
        this._parent.h = this.context.stage.coordsHeight;
        this._parent._hasRenderUpdates = 3;
        this._parent._hasUpdates = true;
        // Root is, and will always be, the primary zContext.
        this._isRoot = true;
        this.context.root = this;
        // Set scissor area of 'fake parent' to stage's viewport.
        this._parent._viewport = [0, 0, this.context.stage.coordsWidth, this.context.stage.coordsHeight];
        this._parent._scissor = this._parent._viewport;
        // When recBoundsMargin is undefined, the defaults are used (100 for all sides).
        this._parent._recBoundsMargin = undefined;
        this.setFlag(1 + 2 + 4);
    }
    isAncestorOf(c) {
        let p = c;
        while (true) {
            p = p._parent;
            if (!p) {
                return false;
            }
            if (this === p)
                return true;
        }
    }
    isZContext() {
        return (this._forceZIndexContext ||
            this._renderToTextureEnabled ||
            this._zIndex !== 0 ||
            this._isRoot ||
            !this._parent);
    }
    findZContext() {
        if (this.isZContext()) {
            return this;
        }
        else {
            return this._parent.findZContext();
        }
    }
    setZParent(newZParent) {
        if (this._zParent !== newZParent) {
            if (this._zParent) {
                if (this._zIndex !== 0) {
                    this._zParent.decZContextUsage();
                }
                // We must filter out this item upon the next resort.
                this._zParent.enableZSort();
            }
            if (newZParent !== undefined) {
                const hadZContextUsage = newZParent._zContextUsage > 0;
                // @pre: new parent's children array has already been modified.
                if (this._zIndex !== 0) {
                    newZParent.incZContextUsage();
                }
                if (newZParent._zContextUsage > 0) {
                    if (!hadZContextUsage && this._parent === newZParent) {
                        // This child was already in the children list.
                        // Do not add double.
                    }
                    else {
                        // Add new child to array.
                        newZParent._zIndexedChildren.push(this);
                    }
                    // Order should be checked.
                    newZParent.enableZSort();
                }
            }
            this._zParent = newZParent;
            // Newly added element must be marked for resort.
            this._zIndexResort = true;
        }
    }
    incZContextUsage() {
        this._zContextUsage++;
        if (this._zContextUsage === 1) {
            if (!this._zIndexedChildren) {
                this._zIndexedChildren = [];
            }
            if (this._children) {
                // Copy.
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._zIndexedChildren.push(this._children[i]);
                }
                // Initially, children are already sorted properly (tree order).
                this._zSort = false;
            }
        }
    }
    decZContextUsage() {
        this._zContextUsage--;
        if (this._zContextUsage === 0) {
            this._zSort = false;
            this._zIndexedChildren.splice(0);
        }
    }
    get zIndex() {
        return this._zIndex;
    }
    set zIndex(zIndex) {
        if (this._zIndex !== zIndex) {
            this.setHasRenderUpdates(1);
            let newZParent = this._zParent;
            const prevIsZContext = this.isZContext();
            if (zIndex === 0 && this._zIndex !== 0) {
                if (this._parent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.decZContextUsage();
                    }
                }
                else {
                    newZParent = this._parent;
                }
            }
            else if (zIndex !== 0 && this._zIndex === 0) {
                newZParent = this._parent ? this._parent.findZContext() : undefined;
                if (newZParent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.incZContextUsage();
                        this._zParent.enableZSort();
                    }
                }
            }
            else if (zIndex !== this._zIndex) {
                if (this._zParent && this._zParent._zContextUsage) {
                    this._zParent.enableZSort();
                }
            }
            if (newZParent !== this._zParent) {
                this.setZParent(undefined);
            }
            this._zIndex = zIndex;
            if (newZParent !== this._zParent) {
                this.setZParent(newZParent);
            }
            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                }
                else {
                    const prevZContext = this._parent ? this._parent.findZContext() : undefined;
                    this.enableZContext(prevZContext);
                }
            }
            // Make sure that resort is done.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }
        }
    }
    get forceZIndexContext() {
        return this._forceZIndexContext;
    }
    set forceZIndexContext(v) {
        this.setHasRenderUpdates(1);
        const prevIsZContext = this.isZContext();
        this._forceZIndexContext = v;
        if (prevIsZContext !== this.isZContext()) {
            if (!this.isZContext()) {
                this.disableZContext();
            }
            else {
                const prevZContext = this._parent ? this._parent.findZContext() : undefined;
                this.enableZContext(prevZContext);
            }
        }
    }
    enableZContext(prevZContext) {
        if (prevZContext && prevZContext._zContextUsage > 0) {
            // Transfer from upper z context to this z context.
            const results = this._getZIndexedDescs();
            results.forEach((c) => {
                if (this.isAncestorOf(c) && c._zIndex !== 0) {
                    c.setZParent(this);
                }
            });
        }
    }
    _getZIndexedDescs() {
        const results = [];
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
        return results;
    }
    _getZIndexedDescsRec(results) {
        if (this._zIndex) {
            results.push(this);
        }
        else if (this._children && !this.isZContext()) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
    }
    disableZContext() {
        // Transfer from this z context to upper z context.
        if (this._zContextUsage > 0) {
            const newZParent = this._parent ? this._parent.findZContext() : undefined;
            // Make sure that z-indexed children are up to date (old ones removed).
            if (this._zSort) {
                this.sortZIndexedChildren();
            }
            this._zIndexedChildren.slice().forEach((c) => {
                if (c._zIndex !== 0) {
                    c.setZParent(newZParent);
                }
            });
        }
    }
    get colorUl() {
        return this._colorUl;
    }
    set colorUl(color) {
        if (this._colorUl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUl = color;
        }
    }
    get colorUr() {
        return this._colorUr;
    }
    set colorUr(color) {
        if (this._colorUr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUr = color;
        }
    }
    get colorBl() {
        return this._colorBl;
    }
    set colorBl(color) {
        if (this._colorBl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBl = color;
        }
    }
    get colorBr() {
        return this._colorBr;
    }
    set colorBr(color) {
        if (this._colorBr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBr = color;
        }
    }
    set onUpdate(f) {
        this._onUpdate = f;
        this.setFlag(7);
    }
    get onUpdate() {
        return this._onUpdate;
    }
    set onAfterUpdate(f) {
        this._onAfterUpdate = f;
        this.setFlag(7);
    }
    get onAfterUpdate() {
        return this._onUpdate;
    }
    set onAfterCalcs(f) {
        this._onAfterCalcs = f;
        this.setFlag(7);
    }
    get onAfterCalcs() {
        return this._onUpdate;
    }
    get shader() {
        return this._shader;
    }
    set shader(v) {
        this.setHasRenderUpdates(1);
        const prevShader = this._shader;
        this._shader = v;
        if (!v && prevShader) {
            // Disabled shader.
            const newShaderOwner = this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : undefined;
            this._setShaderOwnerRecursive(newShaderOwner);
        }
        else if (v) {
            // Enabled shader.
            this._setShaderOwnerRecursive(this);
        }
    }
    get activeShader() {
        return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
    }
    get activeShaderOwner() {
        return this._shaderOwner;
    }
    get clipping() {
        return this._clipping;
    }
    set clipping(v) {
        if (this._clipping !== v) {
            this._clipping = v;
            // Force update of scissor by updating translate.
            // Alpha must also be updated because the scissor area may have been empty.
            this.setFlag(1 + 2);
        }
    }
    get clipbox() {
        return this._clipbox;
    }
    set clipbox(v) {
        // In case of out-of-bounds element, all children will also be ignored.
        // It will save us from executing the update/render loops for those.
        // The optimization will be used immediately during the next frame.
        this._clipbox = v;
    }
    _setShaderOwnerRecursive(elementCore) {
        this._shaderOwner = elementCore;
        if (this._children && !this._renderToTextureEnabled) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                const c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    }
    _setShaderOwnerChildrenRecursive(elementCore) {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                const c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    }
    _hasRenderContext() {
        return this._renderContext !== this._worldContext;
    }
    get renderContext() {
        return this._renderContext;
    }
    updateRenderToTextureEnabled() {
        // Enforce texturizer initialisation.
        const texturizer = this.texturizer;
        const v = texturizer.enabled;
        if (v) {
            this._enableRenderToTexture();
        }
        else {
            this._disableRenderToTexture();
            texturizer.releaseRenderTexture();
        }
    }
    _enableRenderToTexture() {
        if (!this._renderToTextureEnabled) {
            const prevIsZContext = this.isZContext();
            this._renderToTextureEnabled = true;
            this._renderContext = new ElementCoreContext_1.ElementCoreContext();
            // If render to texture is active, a new shader context is started.
            this._setShaderOwnerChildrenRecursive(undefined);
            if (!prevIsZContext) {
                // Render context forces z context.
                this.enableZContext(this._parent ? this._parent.findZContext() : undefined);
            }
            this.setHasRenderUpdates(3);
            // Make sure that the render coordinates get updated.
            this.setFlag(7);
            this.render = this._renderAdvanced;
        }
    }
    _disableRenderToTexture() {
        if (this._renderToTextureEnabled) {
            this._renderToTextureEnabled = false;
            this._setShaderOwnerChildrenRecursive(this._shaderOwner);
            this._renderContext = this._worldContext;
            if (!this.isZContext()) {
                this.disableZContext();
            }
            // Make sure that the render coordinates get updated.
            this.setFlag(7);
            this.setHasRenderUpdates(3);
            this.render = this._renderSimple;
        }
    }
    isWhite() {
        return (this._colorUl === 0xffffffff &&
            this._colorUr === 0xffffffff &&
            this._colorBl === 0xffffffff &&
            this._colorBr === 0xffffffff);
    }
    hasSimpleTexCoords() {
        return this.ulx === 0 && this.uly === 0 && this.brx === 1 && this.bry === 1;
    }
    _stashTexCoords() {
        this._stashedTexCoords = [this.ulx, this.uly, this.brx, this.bry];
        this.ulx = 0;
        this.uly = 0;
        this.brx = 1;
        this.bry = 1;
    }
    _unstashTexCoords() {
        this.ulx = this._stashedTexCoords[0];
        this.uly = this._stashedTexCoords[1];
        this.brx = this._stashedTexCoords[2];
        this.bry = this._stashedTexCoords[3];
        this._stashedTexCoords = undefined;
    }
    _stashColors() {
        this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
        this._colorUl = 0xffffffff;
        this._colorUr = 0xffffffff;
        this._colorBr = 0xffffffff;
        this._colorBl = 0xffffffff;
    }
    _unstashColors() {
        this._colorUl = this._stashedColors[0];
        this._colorUr = this._stashedColors[1];
        this._colorBr = this._stashedColors[2];
        this._colorBl = this._stashedColors[3];
        this._stashedColors = undefined;
    }
    isDisplayed() {
        return this._visible;
    }
    isVisible() {
        return this._localAlpha > 1e-14;
    }
    get outOfBounds() {
        return this._outOfBounds;
    }
    set boundsMargin(v) {
        /**
         *  undefined: inherit from parent.
         *  number[4]: specific margins: left, top, right, bottom.
         */
        this._boundsMargin = v ? v.slice() : undefined;
        // We force recalc in order to set all boundsMargin recursively during the next update.
        this._triggerRecalcTranslate();
    }
    get boundsMargin() {
        return this._boundsMargin;
    }
    hasRelativeDimensionFunctions() {
        return this._relFuncFlags & 12;
    }
    update() {
        // Inherit flags.
        this.flags |= this._parent.updatedFlags & 135;
        if (this._layout && this._layout.isEnabled()) {
            const relativeDimsFlexRoot = this.isFlexLayoutRoot() && this.hasRelativeDimensionFunctions();
            if (this.flags & 256 || relativeDimsFlexRoot) {
                this._layout.layoutFlexTree();
            }
        }
        else if (this.flags & 2 && this._relFuncFlags) {
            this._applyRelativeDimFuncs();
        }
        if (this._onUpdate) {
            // Block all 'upwards' updates when changing things in this branch.
            this._hasUpdates = true;
            this._onUpdate({ element: this.element });
        }
        const pw = this._parent._worldContext;
        const w = this._worldContext;
        const visible = pw.alpha && this._localAlpha;
        /**
         * We must update if:
         * - branch contains updates (even when invisible because it may contain z-indexed descendants)
         * - there are (inherited) updates and this branch is visible
         * - this branch becomes invisible (descs may be z-indexed so we must update all alpha values)
         */
        if (this._hasUpdates || (this.flags && visible) || (w.alpha && !visible)) {
            let recalc = this.flags;
            // Update world coords/alpha.
            if (recalc & 1) {
                if (!w.alpha && visible) {
                    // Becomes visible.
                    this._hasRenderUpdates = 3;
                }
                w.alpha = pw.alpha * this._localAlpha;
                if (w.alpha < 1e-14) {
                    // Tiny rounding errors may cause failing visibility tests.
                    w.alpha = 0;
                }
            }
            if (recalc & 6) {
                w.px = pw.px + this._localPx * pw.ta;
                w.py = pw.py + this._localPy * pw.td;
                if (pw.tb !== 0)
                    w.px += this._localPy * pw.tb;
                if (pw.tc !== 0)
                    w.py += this._localPx * pw.tc;
            }
            if (recalc & 4) {
                w.ta = this._localTa * pw.ta;
                w.tb = this._localTd * pw.tb;
                w.tc = this._localTa * pw.tc;
                w.td = this._localTd * pw.td;
                if (this._isComplex) {
                    w.ta += this._localTc * pw.tb;
                    w.tb += this._localTb * pw.ta;
                    w.tc += this._localTc * pw.td;
                    w.td += this._localTb * pw.tc;
                }
            }
            // Update render coords/alpha.
            const pr = this._parent._renderContext;
            if (this._parent._hasRenderContext()) {
                const init = this._renderContext === this._worldContext;
                if (init) {
                    // First render context build: make sure that it is fully initialized correctly.
                    // Otherwise, if we get into bounds later, the render context would not be initialized correctly.
                    this._renderContext = new ElementCoreContext_1.ElementCoreContext();
                }
                const rc = this._renderContext;
                // Update world coords/alpha.
                if (init || recalc & 1) {
                    rc.alpha = pr.alpha * this._localAlpha;
                    if (rc.alpha < 1e-14) {
                        rc.alpha = 0;
                    }
                }
                if (init || recalc & 6) {
                    rc.px = pr.px + this._localPx * pr.ta;
                    rc.py = pr.py + this._localPy * pr.td;
                    if (pr.tb !== 0)
                        rc.px += this._localPy * pr.tb;
                    if (pr.tc !== 0)
                        rc.py += this._localPx * pr.tc;
                }
                if (init) {
                    // We set the recalc toggle, because we must make sure that the scissor is updated.
                    recalc |= 2;
                }
                if (init || recalc & 4) {
                    rc.ta = this._localTa * pr.ta;
                    rc.tb = this._localTd * pr.tb;
                    rc.tc = this._localTa * pr.tc;
                    rc.td = this._localTd * pr.td;
                    if (this._isComplex) {
                        rc.ta += this._localTc * pr.tb;
                        rc.tb += this._localTb * pr.ta;
                        rc.tc += this._localTc * pr.td;
                        rc.td += this._localTb * pr.tc;
                    }
                }
            }
            else {
                this._renderContext = this._worldContext;
            }
            if (this.context.updateTreeOrder === -1) {
                this.context.updateTreeOrder = this._updateTreeOrder + 1;
            }
            else {
                this._updateTreeOrder = this.context.updateTreeOrder++;
            }
            // Determine whether we must use a 'renderTexture'.
            const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
            if (this._useRenderToTexture !== useRenderToTexture) {
                // Coords must be changed.
                this.flags |= 2 + 4;
                // Scissor may change: force update.
                recalc |= 2;
                if (!this._useRenderToTexture) {
                    // We must release the texture.
                    this._texturizer.release();
                }
            }
            this._useRenderToTexture = useRenderToTexture;
            const r = this._renderContext;
            const bboxW = this._dimsUnknown ? 2048 : this._w;
            const bboxH = this._dimsUnknown ? 2048 : this._h;
            // Calculate a bbox for this element.
            let sx;
            let sy;
            let ex;
            let ey;
            const rComplex = r.tb !== 0 || r.tc !== 0 || r.ta < 0 || r.td < 0;
            if (rComplex) {
                sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            }
            else {
                sx = r.px;
                ex = r.px + r.ta * bboxW;
                sy = r.py;
                ey = r.py + r.td * bboxH;
            }
            if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTd < 1)) {
                // If we are dealing with a non-identity matrix, we must extend the bbox so that withinBounds and
                //  scissors will include the complete range of (positive) dimensions.
                const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                if (nx < sx)
                    sx = nx;
                if (ny < sy)
                    sy = ny;
                if (nx > ex)
                    ex = nx;
                if (ny > ey)
                    ey = ny;
            }
            if (recalc & 6 || !this._scissor /* initial */) {
                // Determine whether we must 'clip'.
                if (this._clipping && r.isSquare()) {
                    // If the parent renders to a texture, it's scissor should be ignored;
                    const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                    if (area) {
                        // Merge scissor areas.
                        const lx = Math.max(area[0], sx);
                        const ly = Math.max(area[1], sy);
                        this._scissor = [
                            lx,
                            ly,
                            Math.min(area[2] + area[0], ex) - lx,
                            Math.min(area[3] + area[1], ey) - ly,
                        ];
                    }
                    else {
                        this._scissor = [sx, sy, ex - sx, ey - sy];
                    }
                }
                else {
                    // No clipping: reuse parent scissor.
                    this._scissor = this._parent._useRenderToTexture
                        ? this._parent._viewport
                        : this._parent._scissor;
                }
            }
            // Calculate the outOfBounds margin.
            if (this._boundsMargin) {
                this._recBoundsMargin = this._boundsMargin;
            }
            else {
                this._recBoundsMargin = this._parent._recBoundsMargin;
            }
            if (this._onAfterCalcs) {
                this._onAfterCalcs({ element: this.element });
                // After calcs may change render coords, scissor and/or recBoundsMargin.
                // Recalculate bbox.
                if (rComplex) {
                    sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                    ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                    sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                    ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                }
                else {
                    sx = r.px;
                    ex = r.px + r.ta * bboxW;
                    sy = r.py;
                    ey = r.py + r.td * bboxH;
                }
                if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                    const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                    const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                    if (nx < sx)
                        sx = nx;
                    if (ny < sy)
                        sy = ny;
                    if (nx > ex)
                        ex = nx;
                    if (ny > ey)
                        ey = ny;
                }
            }
            if (this._parent._outOfBounds === 2) {
                // Inherit parent out of boundsness.
                this._outOfBounds = 2;
                if (this._withinBoundsMargin) {
                    this._withinBoundsMargin = false;
                    this.element._disableWithinBoundsMargin();
                }
            }
            else {
                if (recalc & 6) {
                    // Recheck if element is out-of-bounds (all settings that affect this should enable recalc bit 2 or 4).
                    this._outOfBounds = 0;
                    let withinMargin = true;
                    // Offscreens are always rendered as long as the parent is within bounds.
                    if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                        const scissor = this._scissor;
                        if (scissor && (scissor[2] <= 0 || scissor[3] <= 0)) {
                            // Empty scissor area.
                            this._outOfBounds = 2;
                        }
                        else {
                            // Use bbox to check out-of-boundness.
                            if (scissor[0] > ex ||
                                scissor[1] > ey ||
                                sx > scissor[0] + scissor[2] ||
                                sy > scissor[1] + scissor[3]) {
                                this._outOfBounds = 1;
                            }
                            if (this._outOfBounds) {
                                if (this._clipping || this._useRenderToTexture || (this._clipbox && bboxW && bboxH)) {
                                    this._outOfBounds = 2;
                                }
                            }
                        }
                        withinMargin = this._outOfBounds === 0;
                        if (!withinMargin) {
                            // Re-test, now with margins.
                            if (this._recBoundsMargin) {
                                withinMargin = !(ex < scissor[0] - this._recBoundsMargin[2] ||
                                    ey < scissor[1] - this._recBoundsMargin[3] ||
                                    sx > scissor[0] + scissor[2] + this._recBoundsMargin[0] ||
                                    sy > scissor[1] + scissor[3] + this._recBoundsMargin[1]);
                            }
                            else {
                                withinMargin = !(ex < scissor[0] - 100 ||
                                    ey < scissor[1] - 100 ||
                                    sx > scissor[0] + scissor[2] + 100 ||
                                    sy > scissor[1] + scissor[3] + 100);
                            }
                            if (withinMargin && this._outOfBounds === 2) {
                                // Children must be visited because they may contain elements that are within margin, so must be visible.
                                this._outOfBounds = 1;
                            }
                        }
                    }
                    if (this._withinBoundsMargin !== withinMargin) {
                        this._withinBoundsMargin = withinMargin;
                        if (this._withinBoundsMargin) {
                            // This may update things (txLoaded events) in the element itself, but also in descendants and ancestors.
                            // Changes in ancestors should be executed during the next call of the stage update. But we must
                            // take care that the _recalc and _hasUpdates flags are properly registered. That's why we clear
                            // both before entering the children, and use _pRecalc to transfer inherited updates instead of
                            // _recalc directly.
                            // Changes in descendants are automatically executed within the current update loop, though we must
                            // take care to not update the hasUpdates flag unnecessarily in ancestors. We achieve this by making
                            // sure that the hasUpdates flag of this element is turned on, which blocks it for ancestors.
                            this._hasUpdates = true;
                            const savedRecalc = this.flags;
                            this.flags = 0;
                            this.element._enableWithinBoundsMargin();
                            if (this.flags) {
                                this.flags = savedRecalc | this.flags;
                                // This element needs to be re-updated now, because we want the dimensions (and other changes) to be updated.
                                return this.update();
                            }
                            this.flags = savedRecalc;
                        }
                        else {
                            this.element._disableWithinBoundsMargin();
                        }
                    }
                }
            }
            if (this._useRenderToTexture) {
                // Set viewport necessary for children scissor calculation.
                if (this._viewport) {
                    this._viewport[2] = bboxW;
                    this._viewport[3] = bboxH;
                }
                else {
                    this._viewport = [0, 0, bboxW, bboxH];
                }
            }
            // Copy inheritable flags (except layout).
            this.updatedFlags = this.flags & 151;
            // Clear flags so that future updates are properly detected.
            this.flags = 0;
            this._hasUpdates = false;
            if (this._outOfBounds < 2) {
                if (this._useRenderToTexture) {
                    if (this._worldContext.isIdentity()) {
                        // Optimization.
                        // The world context is already identity: use the world context as render context to prevents the
                        // ancestors from having to update the render context.
                        this._renderContext = this._worldContext;
                    }
                    else {
                        // Temporarily replace the render coord attribs by the identity matrix.
                        // This allows the children to calculate the render context.
                        this._renderContext = ElementCoreContext_1.ElementCoreContext.IDENTITY;
                    }
                }
                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        this._children[i].update();
                    }
                }
                if (this._useRenderToTexture) {
                    this._renderContext = r;
                }
            }
            else {
                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._hasUpdates) {
                            this._children[i].update();
                        }
                        else {
                            // Make sure we don't lose the 'inherited' updates when they become active again.
                            this._children[i].flags |= this.updatedFlags;
                            this._children[i].updateOutOfBounds();
                        }
                    }
                }
            }
            if (this._onAfterUpdate) {
                this._onAfterUpdate({ element: this.element });
            }
        }
        else {
            if (this.context.updateTreeOrder === -1 || this._updateTreeOrder >= this.context.updateTreeOrder) {
                // If new tree order does not interfere with the current (gaps allowed) there's no need to traverse the branch.
                this.context.updateTreeOrder = -1;
            }
            else {
                this.updateTreeOrder();
            }
        }
    }
    _applyRelativeDimFuncs() {
        const layoutParent = this.getLayoutParent();
        if (this._relFuncFlags & 1) {
            const x = this._funcX(layoutParent._w, layoutParent._h);
            if (x !== this._x) {
                this._localPx += x - this._x;
                this._x = x;
            }
        }
        if (this._relFuncFlags & 2) {
            const y = this._funcY(layoutParent._w, layoutParent._h);
            if (y !== this._y) {
                this._localPy += y - this._y;
                this._y = y;
            }
        }
        let changedDims = false;
        if (this._relFuncFlags & 4) {
            const w = this._funcW(layoutParent._w, layoutParent._h);
            if (w !== this._w) {
                this._w = w;
                changedDims = true;
            }
        }
        if (this._relFuncFlags & 8) {
            const h = this._funcH(layoutParent._w, layoutParent._h);
            if (h !== this._h) {
                this._h = h;
                changedDims = true;
            }
        }
        if (changedDims) {
            this.onDimensionsChanged();
        }
    }
    getLayoutParent() {
        let current = this.getParent();
        while (current.skipInLayout) {
            const parent = current.getParent();
            if (!parent)
                return current;
            current = parent;
        }
        return current;
    }
    updateOutOfBounds() {
        // Propagate outOfBounds flag to descendants (necessary because of z-indexing).
        // Invisible elements are not drawn anyway. When alpha is updated, so will _outOfBounds.
        if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {
            // Inherit parent out of boundsness.
            this._outOfBounds = 2;
            if (this._withinBoundsMargin) {
                this._withinBoundsMargin = false;
                this.element._disableWithinBoundsMargin();
            }
            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateOutOfBounds();
                }
            }
        }
    }
    updateTreeOrder() {
        if (this._localAlpha && this._outOfBounds !== 2) {
            this._updateTreeOrder = this.context.updateTreeOrder++;
            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateTreeOrder();
                }
            }
        }
    }
    _renderSimple() {
        this._hasRenderUpdates = 0;
        if (this._zSort) {
            this.sortZIndexedChildren();
        }
        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            const renderState = this.renderState;
            if (this._outOfBounds === 0 && this._displayedTextureSource) {
                renderState.setShader(this.activeShader, this._shaderOwner);
                renderState.setScissor(this._scissor);
                renderState.addElementCore(this);
            }
            // Also add children to the VBO.
            if (this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                }
                else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }
                    }
                }
            }
        }
    }
    _renderAdvanced() {
        const hasRenderUpdates = this._hasRenderUpdates;
        // We must clear the hasRenderUpdates flag before rendering, because updating result textures in combination
        // with z-indexing may trigger render updates on a render branch that is 'half done'.
        // We need to ensure that the full render branch is marked for render updates, not only half (leading to freeze).
        this._hasRenderUpdates = 0;
        if (this._zSort) {
            this.sortZIndexedChildren();
        }
        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            const renderState = this.renderState;
            let mustRenderChildren = true;
            let renderTextureInfo;
            let prevRenderTextureInfo;
            if (this._useRenderToTexture) {
                if (this._w === 0 || this._h === 0) {
                    // Ignore this branch and don't draw anything.
                    return;
                }
                else if (!this._texturizer.hasRenderTexture() || hasRenderUpdates >= 3) {
                    // Switch to default shader for building up the render texture.
                    renderState.setShader(renderState.defaultShader, this);
                    prevRenderTextureInfo = renderState.renderTextureInfo;
                    renderTextureInfo = {
                        renderTexture: undefined,
                        reusableTexture: undefined,
                        reusableRenderStateOffset: 0,
                        w: this._w,
                        h: this._h,
                        empty: true,
                        cleared: false,
                        ignore: false,
                        cache: false,
                    };
                    if (this._texturizer.hasResultTexture() ||
                        (!renderState.isCachingTexturizer && hasRenderUpdates < 3)) {
                        /**
                         * Normally, we cache render textures. But there are exceptions to preserve memory usage!
                         *
                         * The rule is, that caching for a specific render texture is only enabled if:
                         * - There is a result texture to be updated.
                         * - There were no render updates -within the contents- since last frame (ElementCore.hasRenderUpdates < 3)
                         * - AND there are no ancestors that are being cached during this frame (CoreRenderState.isCachingTexturizer)
                         *   If an ancestor is cached anyway, deeper caches are unlikely to be used. If the top level is to
                         *   change later while a lower one is not, that lower level will be cached instead at that instant.
                         *
                         * In some cases, this prevents having to cache all blur levels and stages, saving a huge amount
                         * of GPU memory!
                         *
                         * Especially when using multiple stacked layers of the same dimensions that are render-to-texture this will have a very
                         * noticable effect on performance as less render textures need to be allocated.
                         */
                        renderTextureInfo.cache = true;
                        renderState.isCachingTexturizer = true;
                    }
                    if (!this._texturizer.hasResultTexture()) {
                        // We can already release the current texture to the pool, as it will be rebuild anyway.
                        // In case of multiple layers of 'filtering', this may save us from having to create one
                        //  render-to-texture layer.
                        // Notice that we don't do this when there is a result texture, as any other element may rely on
                        //  that result texture being filled.
                        this._texturizer.releaseRenderTexture();
                    }
                    renderState.setRenderTextureInfo(renderTextureInfo);
                    renderState.setScissor(undefined);
                    if (this._displayedTextureSource) {
                        const r = this._renderContext;
                        // Use an identity context for drawing the displayed texture to the render texture.
                        this._renderContext = ElementCoreContext_1.ElementCoreContext.IDENTITY;
                        // Add displayed texture source in local coordinates.
                        this.renderState.addElementCore(this);
                        this._renderContext = r;
                    }
                }
                else {
                    mustRenderChildren = false;
                }
            }
            else {
                if (this._outOfBounds === 0 && this._displayedTextureSource) {
                    renderState.setShader(this.activeShader, this._shaderOwner);
                    renderState.setScissor(this._scissor);
                    this.renderState.addElementCore(this);
                }
            }
            // Also add children to the VBO.
            if (mustRenderChildren && this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                }
                else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }
                    }
                }
            }
            if (this._useRenderToTexture) {
                let updateResultTexture = false;
                if (mustRenderChildren) {
                    // Finished refreshing renderTexture.
                    renderState.finishedRenderTexture();
                    // If nothing was rendered, we store a flag in the texturizer and prevent unnecessary
                    //  render-to-texture and filtering.
                    this._texturizer.empty = renderTextureInfo.empty;
                    if (renderTextureInfo.empty) {
                        // We ignore empty render textures and do not draw the final quad.
                        // The following cleans up memory and enforces that the result texture is also cleared.
                        this._texturizer.releaseRenderTexture();
                    }
                    else if (renderTextureInfo.reusableTexture) {
                        // If nativeTexture is set, we can reuse that directly instead of creating a new render texture.
                        this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.reusableTexture);
                        renderTextureInfo.ignore = true;
                    }
                    else {
                        if (this._texturizer.renderTextureReused) {
                            // Quad operations must be written to a render texture actually owned.
                            this._texturizer.releaseRenderTexture();
                        }
                        // Just create the render texture.
                        renderTextureInfo.renderTexture = this._texturizer.getRenderTexture();
                    }
                    // Restore the parent's render texture.
                    renderState.setRenderTextureInfo(prevRenderTextureInfo);
                    updateResultTexture = true;
                }
                if (!this._texturizer.empty) {
                    const resultTexture = this._texturizer.getResultTexture();
                    if (updateResultTexture) {
                        if (resultTexture) {
                            // Logging the update frame can be handy.
                            resultTexture.updateFrame = this.element.stage.frameCounter;
                        }
                        this._texturizer.updateResultTexture();
                    }
                    if (!this._texturizer.renderOffscreen) {
                        // Render result texture to the actual render target.
                        renderState.setShader(this.activeShader, this._shaderOwner);
                        renderState.setScissor(this._scissor);
                        // If no render texture info is set, the cache can be reused.
                        const cache = !renderTextureInfo || renderTextureInfo.cache;
                        renderState.setTexturizer(this._texturizer, cache);
                        this._stashTexCoords();
                        if (!this._texturizer.colorize)
                            this._stashColors();
                        this.renderState.addElementCore(this);
                        if (!this._texturizer.colorize)
                            this._unstashColors();
                        this._unstashTexCoords();
                        renderState.setTexturizer(undefined, false);
                    }
                }
            }
            if (renderTextureInfo && renderTextureInfo.cache) {
                // Allow siblings to cache.
                renderState.isCachingTexturizer = false;
            }
        }
    }
    get zSort() {
        return this._zSort;
    }
    sortZIndexedChildren() {
        /**
         * We want to avoid resorting everything. Instead, we do a single pass of the full array:
         * - filtering out elements with a different zParent than this (were removed)
         * - filtering out, but also gathering (in a temporary array) the elements that have zIndexResort flag
         * - then, finally, we merge-sort both the new array and the 'old' one
         * - element may have been added 'double', so when merge-sorting also check for doubles.
         * - if the old one is larger (in size) than it should be, splice off the end of the array.
         */
        const n = this._zIndexedChildren.length;
        let ptr = 0;
        const a = this._zIndexedChildren;
        // Notice that items may occur multiple times due to z-index changing.
        const b = [];
        for (let i = 0; i < n; i++) {
            if (a[i]._zParent === this) {
                if (a[i]._zIndexResort) {
                    b.push(a[i]);
                }
                else {
                    if (ptr !== i) {
                        a[ptr] = a[i];
                    }
                    ptr++;
                }
            }
        }
        const m = b.length;
        if (m) {
            for (let j = 0; j < m; j++) {
                b[j]._zIndexResort = false;
            }
            b.sort(ElementCore.sortZIndexedChildren);
            const amount = ptr;
            if (!amount) {
                ptr = 0;
                let j = 0;
                do {
                    a[ptr++] = b[j++];
                } while (j < m);
                if (a.length > ptr) {
                    // Slice old (unnecessary) part off array.
                    a.splice(ptr);
                }
            }
            else {
                // Merge-sort arrays;
                ptr = 0;
                let i = 0;
                let j = 0;
                const mergeResult = [];
                do {
                    const v = a[i]._zIndex === b[j]._zIndex
                        ? a[i]._updateTreeOrder - b[j]._updateTreeOrder
                        : a[i]._zIndex - b[j]._zIndex;
                    const add = v > 0 ? b[j++] : a[i++];
                    if (ptr === 0 || mergeResult[ptr - 1] !== add) {
                        mergeResult[ptr++] = add;
                    }
                    if (i >= amount) {
                        do {
                            const elementCore = b[j++];
                            if (ptr === 0 || mergeResult[ptr - 1] !== elementCore) {
                                mergeResult[ptr++] = elementCore;
                            }
                        } while (j < m);
                        break;
                    }
                    else if (j >= m) {
                        do {
                            const elementCore = a[i++];
                            if (ptr === 0 || mergeResult[ptr - 1] !== elementCore) {
                                mergeResult[ptr++] = elementCore;
                            }
                        } while (i < amount);
                        break;
                    }
                } while (true);
                this._zIndexedChildren = mergeResult;
            }
        }
        else {
            if (a.length > ptr) {
                // Slice old (unnecessary) part off array.
                a.splice(ptr);
            }
        }
        this._zSort = false;
    }
    get localTa() {
        return this._localTa;
    }
    get localTb() {
        return this._localTb;
    }
    get localTc() {
        return this._localTc;
    }
    get localTd() {
        return this._localTd;
    }
    get element() {
        return this._element;
    }
    get renderUpdates() {
        return this._hasRenderUpdates;
    }
    get texturizer() {
        if (!this._texturizer) {
            this._texturizer = new ElementTexturizer_1.ElementTexturizer(this);
        }
        return this._texturizer;
    }
    getCornerPoints() {
        const w = this._worldContext;
        return [
            w.px,
            w.py,
            w.px + this._w * w.ta,
            w.py + this._w * w.tc,
            w.px + this._w * w.ta + this._h * w.tb,
            w.py + this._w * w.tc + this._h * w.td,
            w.px + this._h * w.tb,
            w.py + this._h * w.td,
        ];
    }
    getRenderTextureCoords(relX, relY) {
        const r = this._renderContext;
        return [r.px + r.ta * relX + r.tb * relY, r.py + r.tc * relX + r.td * relY];
    }
    getAbsoluteCoords(relX, relY) {
        const w = this._renderContext;
        return [w.px + w.ta * relX + w.tb * relY, w.py + w.tc * relX + w.td * relY];
    }
    get skipInLayout() {
        return this._layout ? this._layout.skip : false;
    }
    set skipInLayout(v) {
        if (this.skipInLayout !== v) {
            // Force an update as absolute layout may be affected (on itself or on layout children).
            this._triggerRecalcTranslate();
            this.layout.skip = v;
        }
    }
    get layout() {
        this._ensureLayout();
        return this._layout;
    }
    hasLayout() {
        return !!this._layout;
    }
    getLayout() {
        return this.layout;
    }
    enableFlexLayout() {
        this._ensureLayout();
    }
    _ensureLayout() {
        if (!this._layout) {
            this._layout = new flexbox_js_1.FlexNode(this);
        }
    }
    disableFlexLayout() {
        this._triggerRecalcTranslate();
    }
    hasFlexLayout() {
        return this._layout && this._layout.isEnabled();
    }
    isFlexLayoutRoot() {
        return this._layout && this._layout.isLayoutRoot();
    }
    getFlexContainer() {
        return this.layout.isFlexEnabled() ? this.layout.flex : undefined;
    }
    getFlexItem() {
        return this.layout.flexItem;
    }
    triggerLayout() {
        this.setFlag(256);
    }
    _triggerRecalcTranslate() {
        this.setFlag(2);
    }
    getRenderWidth() {
        return this._w;
    }
    getRenderHeight() {
        return this._h;
    }
    isWithinBoundsMargin() {
        return this._withinBoundsMargin;
    }
    get parent() {
        return this._parent;
    }
    hasTexturizer() {
        return !!this._texturizer;
    }
    getChildren() {
        return this._children;
    }
    getSourceFuncX() {
        return this._funcX;
    }
    getSourceFuncY() {
        return this._funcY;
    }
    getSourceFuncW() {
        return this._funcW;
    }
    getSourceFuncH() {
        return this._funcH;
    }
    static sortZIndexedChildren(a, b) {
        return a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex;
    }
    getSourceX() {
        return this._sx;
    }
    getSourceY() {
        return this._sy;
    }
    getSourceW() {
        // If no source width is specified, the texture width is automatically used.
        return this._sw || this._tw;
    }
    getSourceH() {
        return this._sh || this._th;
    }
    getLayoutX() {
        return this._x;
    }
    getLayoutY() {
        return this._y;
    }
    getLayoutW() {
        return this._w;
    }
    getLayoutH() {
        return this._h;
    }
    convertWorldCoordsToLocal(worldX, worldY) {
        const wc = this._worldContext;
        worldX = worldX - wc.px;
        worldY = worldY - wc.py;
        if (wc.isIdentity()) {
            return [worldX, worldY];
        }
        else if (wc.isSquare()) {
            return [worldX / wc.ta, worldY / wc.td];
        }
        else {
            // Solve linear system of equations by substitution.
            const tcTa = wc.tc / wc.ta;
            const iy = (worldY - tcTa * worldX) / (wc.td - wc.tb * tcTa);
            const ix = (worldX - wc.tb * iy) / wc.ta;
            return [ix, iy];
        }
    }
    isCoordsWithinElement(localOffsetX, localOffsetY) {
        return localOffsetX >= 0 && localOffsetY >= 0 && localOffsetX < this._w && localOffsetY < this._h;
    }
    getCoordinatesOrigin() {
        const parent = this._parent;
        if (!parent) {
            return this;
        }
        else if (parent._useRenderToTexture) {
            return parent;
        }
        else {
            return parent.getCoordinatesOrigin();
        }
    }
    isWorldCoordinatesInScissor(worldX, worldY) {
        const s = this._scissor;
        if (s) {
            const renderRoot = this.getCoordinatesOrigin();
            const [rx, ry] = renderRoot.convertWorldCoordsToLocal(worldX, worldY);
            if (rx < s[0] || ry < s[1] || rx >= s[0] + s[2] || ry >= s[1] + s[3]) {
                return false;
            }
            else {
                return true;
            }
        }
        else {
            return true;
        }
    }
    /**
     * @pre element core must be up-to-date (update method called).
     */
    gatherElementsAtCoordinates(worldX, worldY, results) {
        let withinBounds = false;
        if (!this._renderContext.alpha) {
            return;
        }
        const [offsetX, offsetY] = this.convertWorldCoordsToLocal(worldX, worldY);
        // Make coords relative to world context.
        withinBounds = this.isCoordsWithinElement(offsetX, offsetY);
        if (withinBounds && this.zIndex !== 0) {
            // We must make sure that the not yet visited ancestors do not clip out this texture.
            // renderToTexture is no problem as it creates a new z context so must already be checked.
            // clipping is a possible problem, so we must check the scissor.
            if (!this.isWorldCoordinatesInScissor(worldX, worldY)) {
                withinBounds = false;
            }
        }
        if (withinBounds) {
            results.push({ offsetX, offsetY, element: this.element });
        }
        // When the render context is not square, clipping is ignored while rendering.
        const useClipping = this._useRenderToTexture || (this._clipping && this._renderContext.isSquare());
        const mustRecurse = withinBounds || !useClipping;
        if (this._children && mustRecurse) {
            if (this._zContextUsage) {
                for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                    this._zIndexedChildren[i].gatherElementsAtCoordinates(worldX, worldY, results);
                }
            }
            else {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    if (this._children[i]._zIndex === 0) {
                        // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                        this._children[i].gatherElementsAtCoordinates(worldX, worldY, results);
                    }
                }
            }
        }
    }
    checkWithinBounds() {
        this.setFlag(6);
    }
}
exports.ElementCore = ElementCore;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextureSource_1 = __webpack_require__(24);
class ElementTexturizer {
    constructor(_core) {
        this._core = _core;
        this._element = this._core.element;
        this.context = this._core.context;
        this._enabled = false;
        // In lazy mode, render to texture will be disabled when there are changes since the last frame.
        this.lazy = false;
        this._colorize = false;
        this._renderTexture = undefined;
        this._reusedTexture = undefined;
        this._resultTextureSource = undefined;
        this._renderOffscreen = false;
        this.empty = false;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(v) {
        this._enabled = v;
        this._core.updateRenderToTextureEnabled();
    }
    get renderOffscreen() {
        return this._renderOffscreen;
    }
    set renderOffscreen(v) {
        this._renderOffscreen = v;
        this._core.setHasRenderUpdates(1);
        this._core.checkWithinBounds();
    }
    get colorize() {
        return this._colorize;
    }
    set colorize(v) {
        if (this._colorize !== v) {
            this._colorize = v;
            // Only affects the finally drawn quad.
            this._core.setHasRenderUpdates(1);
        }
    }
    _getTextureSource() {
        if (!this._resultTextureSource) {
            this._resultTextureSource = new TextureSource_1.TextureSource(this._element.stage.textureManager);
            this.updateResultTexture();
        }
        return this._resultTextureSource;
    }
    hasResultTexture() {
        return !!this._resultTextureSource;
    }
    resultTextureInUse() {
        return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
    }
    updateResultTexture() {
        const resultTexture = this.getResultTexture();
        if (this._resultTextureSource) {
            if (this._resultTextureSource.nativeTexture !== resultTexture) {
                const w = resultTexture ? resultTexture.w : 0;
                const h = resultTexture ? resultTexture.h : 0;
                this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
            }
            // Texture will be updated: all elements using the source need to be updated as well.
            this._resultTextureSource.forEachEnabledElement((element) => {
                element._updateTextureDimensions();
                element.core.setHasRenderUpdates(3);
            });
        }
    }
    mustRenderToTexture() {
        // Check if we must really render as texture.
        if (this._enabled && !this.lazy) {
            return true;
        }
        else if (this._enabled && this.lazy && !this._core.hasRenderTextureUpdates()) {
            // Static-only: if renderToTexture did not need to update during last drawn frame, generate it as a cache.
            return true;
        }
        return false;
    }
    deactivate() {
        this.release();
    }
    get renderTextureReused() {
        return !!this._reusedTexture;
    }
    release() {
        this.releaseRenderTexture();
    }
    releaseRenderTexture() {
        if (this._renderTexture) {
            this.context.releaseRenderTexture(this._renderTexture);
            this._renderTexture = undefined;
            this.updateResultTexture();
        }
    }
    // Reuses the specified texture as the render texture (in ancestor).
    reuseTextureAsRenderTexture(nativeTexture) {
        if (this._renderTexture !== nativeTexture) {
            this.releaseRenderTexture();
            this._reusedTexture = nativeTexture;
        }
    }
    hasRenderTexture() {
        return !!this._renderTexture;
    }
    getRenderTexture() {
        if (!this._renderTexture) {
            this._renderTexture = this.context.allocateRenderTexture(this._core.getLayoutW(), this._core.getLayoutH());
            this._reusedTexture = undefined;
        }
        return this._renderTexture;
    }
    getResultTexture() {
        return this._reusedTexture || this._renderTexture;
    }
}
exports.ElementTexturizer = ElementTexturizer;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ElementCoreContext {
    constructor() {
        this.alpha = 1;
        this.px = 0;
        this.py = 0;
        this.ta = 1;
        this.tb = 0;
        this.tc = 0;
        this.td = 1;
    }
    isIdentity() {
        return (this.alpha === 1 &&
            this.px === 0 &&
            this.py === 0 &&
            this.ta === 1 &&
            this.tb === 0 &&
            this.tc === 0 &&
            this.td === 1);
    }
    isSquare() {
        return this.tb === 0 && this.tc === 0;
    }
}
exports.ElementCoreContext = ElementCoreContext;
ElementCoreContext.IDENTITY = new ElementCoreContext();


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlexContainer_1 = __webpack_require__(43);
exports.FlexContainer = FlexContainer_1.FlexContainer;
const FlexItem_1 = __webpack_require__(45);
exports.FlexItem = FlexItem_1.FlexItem;
const FlexNode_1 = __webpack_require__(46);
exports.FlexNode = FlexNode_1.FlexNode;
const FlexTarget_1 = __webpack_require__(106);
exports.FlexTarget = FlexTarget_1.FlexTarget;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ContentAligner_1 = __webpack_require__(98);
const LineLayouter_1 = __webpack_require__(99);
const ItemCoordinatesUpdater_1 = __webpack_require__(105);
/**
 * Layouts a flex container (and descendants).
 */
class FlexLayouter {
    constructor(container) {
        this.container = container;
        this.lineLayouter = new LineLayouter_1.LineLayouter(this);
        this.resizingMainAxis = false;
        this.resizingCrossAxis = false;
        this.cachedInitialWidth = 0;
        this.cachedInitialHeight = 0;
        this.cachedLayoutWidth = 0;
        this.cachedLayoutHeight = 0;
        this.shrunk = false;
        this.totalCrossAxisSize = 0;
    }
    layoutTree() {
        if (this.isSubTree()) {
            // This can occur if only a part of the flex hierarchy needs to be updated.
            if (!this.shouldSkipSubTree()) {
                this.updateSubTreeLayout();
                this.updateItemCoords();
            }
        }
        else {
            this.updateTreeLayout();
            this.updateItemCoords();
        }
    }
    isSubTree() {
        return !!this.item.flexParent;
    }
    shouldSkipSubTree() {
        // If the recalc flag has already been cleared when getting here, we can assume that this subtree was already
        // updated as part of a parent flex tree update. In that case we must not update this subtree individually as it
        // may fail to take the flex ancestors into account - giving incorrect results.
        return !this.container.node.isChanged();
    }
    updateTreeLayout() {
        if (this.recalc) {
            this.performUpdateLayoutTree();
        }
        else {
            this.performUpdateLayoutTreeFromCache();
        }
    }
    performUpdateLayoutTree() {
        this.setCachedInitialSizes();
        this.initializeAxisSizes();
        this.layoutAxes();
        this.setLayoutCache();
    }
    setCachedInitialSizes() {
        this.cachedInitialWidth = this.item.getRelAxisSize(true);
        this.cachedInitialHeight = this.item.getRelAxisSize(false);
    }
    setLayoutCache() {
        this.cachedLayoutWidth = this.item.getAxisLayoutSize(true);
        this.cachedLayoutHeight = this.item.getAxisLayoutSize(false);
    }
    performUpdateLayoutTreeFromCache() {
        if (this.isInitialSizeCacheValid()) {
            this.useLayoutCache();
        }
        else {
            this.item.enableLocalRecalcFlag();
            this.performUpdateLayoutTree();
        }
    }
    useLayoutCache() {
        this.item.setAxisLayoutSize(true, this.cachedLayoutWidth);
        this.item.setAxisLayoutSize(false, this.cachedLayoutHeight);
    }
    isInitialSizeCacheValid() {
        const initialWidth = this.item.getRelAxisSize(true);
        const initialHeight = this.item.getRelAxisSize(false);
        return this.cachedInitialWidth === initialWidth && this.cachedInitialHeight === initialHeight;
    }
    updateItemCoords() {
        const updater = new ItemCoordinatesUpdater_1.ItemCoordinatesUpdater(this);
        updater.finalize();
    }
    updateSubTreeLayout() {
        // The dimensions of this container are guaranteed not to have changed.
        // That's why we can safely 'reuse' those and re-layout the contents.
        const crossAxisSize = this.crossAxisSize;
        this.layoutMainAxis();
        this.performResizeCrossAxis(crossAxisSize);
    }
    initializeAxisSizes() {
        if (this.item.isFlexItemEnabled()) {
            if (this.item.flexItem) {
                this.item.flexItem.resetLayoutSize();
            }
        }
        else {
            this.mainAxisSize = this.getMainAxisBasis();
            this.crossAxisSize = this.getCrossAxisBasis();
        }
        this.resizingMainAxis = false;
        this.resizingCrossAxis = false;
        this.shrunk = false;
    }
    layoutAxes() {
        this.layoutMainAxis();
        this.layoutCrossAxis();
    }
    layoutMainAxis() {
        this.lineLayouter.layoutLines();
        this.fitMainAxisSizeToContents();
    }
    getLines() {
        return this.lineLayouter.getLines();
    }
    fitMainAxisSizeToContents() {
        if (!this.resizingMainAxis) {
            if (this.isMainAxisFitToContents()) {
                this.mainAxisSize = this.lineLayouter.getMainAxisContentSize();
            }
        }
    }
    layoutCrossAxis() {
        const aligner = new ContentAligner_1.ContentAligner(this);
        this.totalCrossAxisSize = aligner.getTotalCrossAxisSize();
        this.fitCrossAxisSizeToContents();
        aligner.align();
    }
    fitCrossAxisSizeToContents() {
        if (!this.resizingCrossAxis) {
            if (this.isCrossAxisFitToContents()) {
                this.crossAxisSize = this.totalCrossAxisSize;
            }
        }
    }
    isWrapping() {
        return this.container.wrap;
    }
    isAxisFitToContents(horizontal) {
        if (this.horizontal === horizontal) {
            return this.isMainAxisFitToContents();
        }
        else {
            return this.isCrossAxisFitToContents();
        }
    }
    isMainAxisFitToContents() {
        return !this.isWrapping() && !this.hasFixedMainAxisBasis();
    }
    isCrossAxisFitToContents() {
        return !this.hasFixedCrossAxisBasis();
    }
    hasFixedMainAxisBasis() {
        return !this.item.isZeroAxisSize(this.horizontal);
    }
    hasFixedCrossAxisBasis() {
        return !this.item.isZeroAxisSize(!this.horizontal);
    }
    getAxisMinLineSize(horizontal) {
        if (this.horizontal === horizontal) {
            return this.lineLayouter.getMainAxisMinSize();
        }
        else {
            return this.lineLayouter.getCrossAxisMinSize();
        }
    }
    resizeMainAxis(size) {
        if (this.mainAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeMainAxis(size);
            }
            else {
                if (this.checkValidCacheMainAxisResize(size)) {
                    this.mainAxisSize = size;
                    this.fitCrossAxisSizeToContents();
                }
                else {
                    // Cache miss.
                    this.item.enableLocalRecalcFlag();
                    this.performResizeMainAxis(size);
                }
            }
        }
    }
    checkValidCacheMainAxisResize(size) {
        const isFinalMainAxisSize = size === this.subjectMainAxisSize;
        if (isFinalMainAxisSize) {
            return true;
        }
        const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
        // Allow other main axis resizes and check if final resize matches the subject main axis size
        //  (ItemCoordinatesUpdater).
        return canIgnoreCacheMiss;
    }
    performResizeMainAxis(size) {
        this.shrunk = size < this.mainAxisSize;
        this.mainAxisSize = size;
        this.resizingMainAxis = true;
        this.layoutAxes();
        this.resizingMainAxis = false;
    }
    resizeCrossAxis(size) {
        if (this.crossAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeCrossAxis(size);
            }
            else {
                this.crossAxisSize = size;
            }
        }
    }
    performResizeCrossAxis(size) {
        this.crossAxisSize = size;
        this.resizingCrossAxis = true;
        this.layoutCrossAxis();
        this.resizingCrossAxis = false;
    }
    get subjectMainAxisSize() {
        return this.horizontal ? this.item.subject.getLayoutW() : this.item.subject.getLayoutH();
    }
    getParentFlexContainer() {
        return this.item.isFlexItemEnabled() ? this.item.flexItem.getContainer() : undefined;
    }
    getMainAxisBasis() {
        return this.item.getRelAxisSize(this.horizontal);
    }
    getCrossAxisBasis() {
        return this.item.getRelAxisSize(!this.horizontal);
    }
    get horizontal() {
        return this.container.horizontal;
    }
    get reverse() {
        return this.container.reverse;
    }
    get item() {
        return this.container.node;
    }
    get items() {
        return this.item.items;
    }
    isResizingMainAxis() {
        return this.resizingMainAxis;
    }
    isResizingCrossAxis() {
        return this.resizingCrossAxis;
    }
    get mainAxisSize() {
        return this.item.getAxisLayoutSize(this.horizontal);
    }
    set mainAxisSize(v) {
        this.item.setAxisLayoutSize(this.horizontal, v);
    }
    get crossAxisSize() {
        return this.item.getAxisLayoutSize(!this.horizontal);
    }
    set crossAxisSize(v) {
        this.item.setAxisLayoutSize(!this.horizontal, v);
    }
    hasShrunk() {
        return this.shrunk;
    }
    get recalc() {
        return this.item.recalc;
    }
}
exports.FlexLayouter = FlexLayouter;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const spacing_1 = __webpack_require__(44);
class ContentAligner {
    constructor(layout) {
        this.layout = layout;
        this.totalCrossAxisSize = 0;
        this.init();
    }
    init() {
        this.totalCrossAxisSize = this.calcTotalCrossAxisSize();
    }
    get lines() {
        return this.layout.getLines();
    }
    align() {
        const crossAxisSize = this.layout.crossAxisSize;
        const remainingSpace = crossAxisSize - this.totalCrossAxisSize;
        const { spacingBefore, spacingBetween } = this.getSpacing(remainingSpace);
        const lines = this.lines;
        const mode = this.layout.container.alignContent;
        let growSize = 0;
        if (mode === "stretch" && lines.length && remainingSpace > 0) {
            growSize = remainingSpace / lines.length;
        }
        let currentPos = spacingBefore;
        for (let i = 0, n = lines.length; i < n; i++) {
            const crossAxisLayoutOffset = currentPos;
            const aligner = lines[i].createItemAligner();
            const finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;
            aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
            aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);
            aligner.align();
            if (aligner.getRecursiveResizeOccured()) {
                lines[i].setItemPositions();
            }
            currentPos += finalCrossAxisLayoutSize;
            currentPos += spacingBetween;
        }
    }
    getTotalCrossAxisSize() {
        return this.totalCrossAxisSize;
    }
    calcTotalCrossAxisSize() {
        const lines = this.lines;
        let total = 0;
        for (let i = 0, n = lines.length; i < n; i++) {
            const line = lines[i];
            total += line.crossAxisLayoutSize;
        }
        return total;
    }
    getSpacing(remainingSpace) {
        const mode = this.layout.container.alignContent;
        const numberOfItems = this.lines.length;
        return spacing_1.getSpacing(mode, numberOfItems, remainingSpace);
    }
}
exports.ContentAligner = ContentAligner;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LineLayout_1 = __webpack_require__(100);
/**
 * Distributes items over layout lines.
 */
class LineLayouter {
    constructor(_layout) {
        this._layout = _layout;
        this.mainAxisContentSize = 0;
        this.curMainAxisPos = 0;
        this.mainAxisSize = 0;
        this.maxMainAxisPos = 0;
    }
    layoutLines() {
        this.setup();
        const items = this._layout.items;
        const wrap = this._layout.isWrapping();
        let startIndex = 0;
        let i;
        const n = items.length;
        for (i = 0; i < n; i++) {
            const item = items[i];
            this.layoutFlexItem(item);
            // Get predicted main axis size.
            const itemMainAxisSize = item.flexItem.getMainAxisLayoutSizeWithPaddingAndMargin();
            if (wrap && i > startIndex) {
                const isOverflowing = this.curMainAxisPos + itemMainAxisSize > this.mainAxisSize;
                if (isOverflowing) {
                    this.layoutLine(startIndex, i - 1);
                    this.curMainAxisPos = 0;
                    startIndex = i;
                }
            }
            this.addToMainAxisPos(itemMainAxisSize);
        }
        if (startIndex < i) {
            this.layoutLine(startIndex, i - 1);
        }
    }
    setup() {
        this.mainAxisSize = this._layout.mainAxisSize;
        this.curMainAxisPos = 0;
        this.maxMainAxisPos = 0;
        this.lines = [];
        this.mainAxisMinSize = undefined;
        this.crossAxisMinSize = undefined;
        this.mainAxisContentSize = 0;
    }
    layoutFlexItem(item) {
        if (item.isFlexEnabled()) {
            item.flexLayout.updateTreeLayout();
        }
        else {
            item.flexItem.resetLayoutSize();
        }
    }
    addToMainAxisPos(itemMainAxisSize) {
        this.curMainAxisPos += itemMainAxisSize;
        if (this.curMainAxisPos > this.maxMainAxisPos) {
            this.maxMainAxisPos = this.curMainAxisPos;
        }
    }
    layoutLine(startIndex, endIndex) {
        const availableSpace = this.getAvailableMainAxisLayoutSpace();
        const line = new LineLayout_1.LineLayout(this._layout, startIndex, endIndex, availableSpace);
        line.performLayout();
        this.lines.push(line);
        if (this.mainAxisContentSize === 0 || this.curMainAxisPos > this.mainAxisContentSize) {
            this.mainAxisContentSize = this.curMainAxisPos;
        }
    }
    getAvailableMainAxisLayoutSpace() {
        if (!this._layout.isResizingMainAxis() && this._layout.isMainAxisFitToContents()) {
            return 0;
        }
        else {
            return this.mainAxisSize - this.curMainAxisPos;
        }
    }
    calcCrossAxisMinSize() {
        let crossAxisMinSize = 0;
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const itemCrossAxisMinSize = item.flexItem.getCrossAxisMinSizeWithPaddingAndMargin();
            crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
        }
        return crossAxisMinSize;
    }
    calcMainAxisMinSize() {
        const lines = this.lines;
        if (lines.length === 1) {
            return lines[0].getMainAxisMinSize();
        }
        else {
            // Wrapping lines: specified width is used as min width (in accordance to W3C flexbox).
            return this._layout.mainAxisSize;
        }
    }
    getLines() {
        return this.lines;
    }
    getMainAxisMinSize() {
        if (this.mainAxisMinSize === undefined) {
            this.mainAxisMinSize = this.calcMainAxisMinSize();
        }
        return this.mainAxisMinSize;
    }
    getCrossAxisMinSize() {
        if (this.crossAxisMinSize === undefined) {
            this.crossAxisMinSize = this.calcCrossAxisMinSize();
        }
        return this.crossAxisMinSize;
    }
    getMainAxisContentSize() {
        return this.mainAxisContentSize;
    }
}
exports.LineLayouter = LineLayouter;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SizeShrinker_1 = __webpack_require__(101);
const SizeGrower_1 = __webpack_require__(102);
const ItemPositioner_1 = __webpack_require__(103);
const ItemAligner_1 = __webpack_require__(104);
class LineLayout {
    constructor(layout, startIndex, endIndex, availableSpace) {
        this.layout = layout;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.availableSpace = availableSpace;
        this.crossAxisMaxLayoutSize = 0;
        this.items = layout.items;
    }
    getLayout() {
        return this.layout;
    }
    performLayout() {
        this._setItemSizes();
        this.setItemPositions();
        this._calcLayoutInfo();
    }
    _setItemSizes() {
        if (this.availableSpace > 0) {
            this._growItemSizes(this.availableSpace);
        }
        else if (this.availableSpace < 0) {
            this._shrinkItemSizes(-this.availableSpace);
        }
    }
    _growItemSizes(amount) {
        const grower = new SizeGrower_1.SizeGrower(this);
        grower.grow(amount);
        this.availableSpace -= grower.getGrownSize();
    }
    _shrinkItemSizes(amount) {
        const shrinker = new SizeShrinker_1.SizeShrinker(this);
        shrinker.shrink(amount);
        this.availableSpace += shrinker.getShrunkSize();
    }
    setItemPositions() {
        const positioner = new ItemPositioner_1.ItemPositioner(this);
        positioner.position();
    }
    createItemAligner() {
        return new ItemAligner_1.ItemAligner(this);
    }
    _calcLayoutInfo() {
        this._calcCrossAxisMaxLayoutSize();
    }
    getMainAxisMinSize() {
        let mainAxisMinSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            mainAxisMinSize += item.flexItem.getMainAxisMinSizeWithPaddingAndMargin();
        }
        return mainAxisMinSize;
    }
    get numberOfItems() {
        return this.endIndex - this.startIndex + 1;
    }
    get crossAxisLayoutSize() {
        const noSpecifiedCrossAxisSize = this.layout.isCrossAxisFitToContents() && !this.layout.isResizingCrossAxis();
        const shouldFitToContents = this.layout.isWrapping() || noSpecifiedCrossAxisSize;
        if (shouldFitToContents) {
            return this.crossAxisMaxLayoutSize;
        }
        else {
            return this.layout.crossAxisSize;
        }
    }
    _calcCrossAxisMaxLayoutSize() {
        this.crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
    }
    _getCrossAxisMaxLayoutSize() {
        let crossAxisMaxSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem.getCrossAxisLayoutSizeWithPaddingAndMargin());
        }
        return crossAxisMaxSize;
    }
}
exports.LineLayout = LineLayout;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class SizeShrinker {
    constructor(line) {
        this.line = line;
        this.amountRemaining = 0;
        this.shrunkSize = 0;
    }
    shrink(amount) {
        this.shrunkSize = 0;
        this.amountRemaining = amount;
        let totalShrinkAmount = this.getTotalShrinkAmount();
        if (totalShrinkAmount) {
            const items = this.line.items;
            do {
                const amountPerShrink = this.amountRemaining / totalShrinkAmount;
                for (let i = this.line.startIndex; i <= this.line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const shrinkAmount = flexItem.shrink;
                    const isShrinkableItem = shrinkAmount > 0;
                    if (isShrinkableItem) {
                        let shrink = shrinkAmount * amountPerShrink;
                        const minSize = flexItem.getMainAxisMinSize();
                        const size = flexItem.getMainAxisLayoutSize();
                        if (size > minSize) {
                            const maxShrink = size - minSize;
                            const isFullyShrunk = shrink >= maxShrink;
                            if (isFullyShrunk) {
                                shrink = maxShrink;
                                // Destribute remaining amount over the other flex items.
                                totalShrinkAmount -= shrinkAmount;
                            }
                            const finalSize = size - shrink;
                            flexItem.resizeMainAxis(finalSize);
                            this.shrunkSize += shrink;
                            this.amountRemaining -= shrink;
                            if (Math.abs(this.amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while (totalShrinkAmount && Math.abs(this.amountRemaining) > 10e-6);
        }
    }
    getTotalShrinkAmount() {
        let total = 0;
        const items = this.line.items;
        for (let i = this.line.startIndex; i <= this.line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;
            if (flexItem.shrink) {
                const minSize = flexItem.getMainAxisMinSize();
                const size = flexItem.getMainAxisLayoutSize();
                // Exclude those already fully shrunk.
                if (size > minSize) {
                    total += flexItem.shrink;
                }
            }
        }
        return total;
    }
    getShrunkSize() {
        return this.shrunkSize;
    }
}
exports.SizeShrinker = SizeShrinker;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class SizeGrower {
    constructor(line) {
        this.line = line;
        this.amountRemaining = 0;
        this.grownSize = 0;
    }
    grow(amount) {
        this.grownSize = 0;
        this.amountRemaining = amount;
        let totalGrowAmount = this.getTotalGrowAmount();
        if (totalGrowAmount) {
            const items = this.line.items;
            do {
                const amountPerGrow = this.amountRemaining / totalGrowAmount;
                for (let i = this.line.startIndex; i <= this.line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const growAmount = flexItem.grow;
                    const isGrowableItem = growAmount > 0;
                    if (isGrowableItem) {
                        let grow = growAmount * amountPerGrow;
                        const maxSize = flexItem.getMainAxisMaxSizeSetting();
                        const size = flexItem.getMainAxisLayoutSize();
                        if (maxSize > 0) {
                            if (size >= maxSize) {
                                // Already fully grown.
                                grow = 0;
                            }
                            else {
                                const maxGrow = maxSize - size;
                                const isFullyGrown = grow >= maxGrow;
                                if (isFullyGrown) {
                                    grow = maxGrow;
                                    // Destribute remaining amount over the other flex items.
                                    totalGrowAmount -= growAmount;
                                }
                            }
                        }
                        if (grow > 0) {
                            const finalSize = size + grow;
                            flexItem.resizeMainAxis(finalSize);
                            this.grownSize += grow;
                            this.amountRemaining -= grow;
                            if (Math.abs(this.amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while (totalGrowAmount && Math.abs(this.amountRemaining) > 10e-6);
        }
    }
    getTotalGrowAmount() {
        let total = 0;
        const items = this.line.items;
        for (let i = this.line.startIndex; i <= this.line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;
            if (flexItem.grow) {
                const maxSize = flexItem.getMainAxisMaxSizeSetting();
                const size = flexItem.getMainAxisLayoutSize();
                // Exclude those already fully grown.
                if (maxSize === 0 || size < maxSize) {
                    total += flexItem.grow;
                }
            }
        }
        return total;
    }
    getGrownSize() {
        return this.grownSize;
    }
}
exports.SizeGrower = SizeGrower;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const spacing_1 = __webpack_require__(44);
class ItemPositioner {
    constructor(line) {
        this.line = line;
    }
    get _layout() {
        return this.line.getLayout();
    }
    position() {
        const { spacingBefore, spacingBetween } = this.getSpacing();
        let currentPos = spacingBefore;
        const items = this.line.items;
        for (let i = this.line.startIndex; i <= this.line.endIndex; i++) {
            const item = items[i];
            item.flexItem.setMainAxisLayoutPos(currentPos);
            currentPos += item.flexItem.getMainAxisLayoutSizeWithPaddingAndMargin();
            currentPos += spacingBetween;
        }
    }
    getSpacing() {
        const remainingSpace = this.line.availableSpace;
        const mode = this._layout.container.justifyContent;
        const numberOfItems = this.line.numberOfItems;
        return spacing_1.getSpacing(mode, numberOfItems, remainingSpace);
    }
}
exports.ItemPositioner = ItemPositioner;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ItemAligner {
    constructor(_line) {
        this._line = _line;
        this.crossAxisLayoutSize = 0;
        this.crossAxisLayoutOffset = 0;
        this.recursiveResizeOccured = false;
        this.isCrossAxisFitToContents = false;
    }
    get _layout() {
        return this._line.getLayout();
    }
    get _flexContainer() {
        return this._layout.container;
    }
    setCrossAxisLayoutSize(size) {
        this.crossAxisLayoutSize = size;
    }
    setCrossAxisLayoutOffset(offset) {
        this.crossAxisLayoutOffset = offset;
    }
    align() {
        this.alignItemsSetting = this._flexContainer.alignItems;
        this.isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer.horizontal);
        this.recursiveResizeOccured = false;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            this._alignItem(item);
        }
    }
    getRecursiveResizeOccured() {
        return this.recursiveResizeOccured;
    }
    _alignItem(item) {
        const flexItem = item.flexItem;
        let align = flexItem.alignSelf || this.alignItemsSetting;
        if (align === "stretch" && this.preventStretch(flexItem)) {
            align = "flex-start";
        }
        if (align !== "center" && !this.isCrossAxisFitToContents) {
            if (flexItem.hasRelCrossAxisSize()) {
                // As cross axis size might have changed, we need to recalc the relative flex item's size.
                flexItem.resetCrossAxisLayoutSize();
            }
        }
        switch (align) {
            case "flex-start":
                this._alignItemFlexStart(flexItem);
                break;
            case "flex-end":
                this._alignItemFlexEnd(flexItem);
                break;
            case "center":
                this._alignItemFlexCenter(flexItem);
                break;
            case "stretch":
                this._alignItemStretch(flexItem);
                break;
        }
    }
    _alignItemFlexStart(flexItem) {
        flexItem.setCrossAxisLayoutPos(this.crossAxisLayoutOffset);
    }
    _alignItemFlexEnd(flexItem) {
        const itemCrossAxisSize = flexItem.getCrossAxisLayoutSizeWithPaddingAndMargin();
        flexItem.setCrossAxisLayoutPos(this.crossAxisLayoutOffset + (this.crossAxisLayoutSize - itemCrossAxisSize));
    }
    _alignItemFlexCenter(flexItem) {
        const itemCrossAxisSize = flexItem.getCrossAxisLayoutSizeWithPaddingAndMargin();
        const center = (this.crossAxisLayoutSize - itemCrossAxisSize) / 2;
        flexItem.setCrossAxisLayoutPos(this.crossAxisLayoutOffset + center);
    }
    _alignItemStretch(flexItem) {
        flexItem.setCrossAxisLayoutPos(this.crossAxisLayoutOffset);
        const mainAxisLayoutSizeBeforeResize = flexItem.getMainAxisLayoutSize();
        let size = this.crossAxisLayoutSize - flexItem.getCrossAxisMargin() - flexItem.getCrossAxisPadding();
        const crossAxisMinSizeSetting = flexItem.getCrossAxisMinSizeSetting();
        if (crossAxisMinSizeSetting > 0) {
            size = Math.max(size, crossAxisMinSizeSetting);
        }
        const crossAxisMaxSizeSetting = flexItem.getCrossAxisMaxSizeSetting();
        const crossAxisMaxSizeSettingEnabled = crossAxisMaxSizeSetting > 0;
        if (crossAxisMaxSizeSettingEnabled) {
            size = Math.min(size, crossAxisMaxSizeSetting);
        }
        flexItem.resizeCrossAxis(size);
        const mainAxisLayoutSizeAfterResize = flexItem.getMainAxisLayoutSize();
        const recursiveResize = mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize;
        if (recursiveResize) {
            // Recursive resize can happen when this flex item has the opposite direction than the container
            // and is wrapping and auto-sizing. Due to item/content stretching the main axis size of the flex
            // item may decrease. If it does so, we must re-justify-content the complete line.
            // Notice that we don't account for changes to the (if autosized) main axis size caused by recursive
            // resize, which may cause the container's main axis to not shrink to the contents properly.
            // This is by design, because if we had re-run the main axis layout, we could run into issues such
            // as slow layout or endless loops.
            this.recursiveResizeOccured = true;
        }
    }
    preventStretch(flexItem) {
        const hasFixedCrossAxisSize = flexItem.hasFixedCrossAxisSize();
        const forceStretch = flexItem.alignSelf === "stretch";
        return hasFixedCrossAxisSize && !forceStretch;
    }
}
exports.ItemAligner = ItemAligner;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ItemCoordinatesUpdater {
    constructor(layout) {
        this.layout = layout;
        this.isReverse = this.flexContainer.reverse;
        this.horizontalPaddingOffset = this.flexContainer.node.getHorizontalPaddingOffset();
        this.verticalPaddingOffset = this.flexContainer.node.getVerticalPaddingOffset();
    }
    get flexContainer() {
        return this.layout.container;
    }
    finalize() {
        const parentFlex = this.layout.getParentFlexContainer();
        if (parentFlex) {
            // We must update it from the parent to set padding offsets and reverse position.
            const updater = new ItemCoordinatesUpdater(parentFlex.layout);
            updater.finalizeItemAndChildren(this.flexContainer.node);
        }
        else {
            const validCache = this.validateItemCache(this.flexContainer.node);
            if (!validCache) {
                this.finalizeRoot();
                this.finalizeItems();
            }
        }
    }
    finalizeRoot() {
        const flexNode = this.flexContainer.node;
        const x = flexNode.getAxisLayoutPos(true);
        const y = flexNode.getAxisLayoutPos(false);
        let w = flexNode.getAxisLayoutSize(true);
        let h = flexNode.getAxisLayoutSize(false);
        w += flexNode.getHorizontalPadding();
        h += flexNode.getVerticalPadding();
        flexNode.clearRecalcFlag();
        flexNode.setLayout(x, y, w, h);
    }
    finalizeItems() {
        const items = this.layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const validCache = this.validateItemCache(item);
            // Notice that we must also finalize a cached item, as it's coordinates may have changed.
            this.finalizeItem(item);
            if (!validCache) {
                this.finalizeItemChildren(item);
            }
        }
    }
    validateItemCache(item) {
        if (item.recalc === 0) {
            if (item.isFlexEnabled()) {
                const layout = item.flex.layout;
                const dimensionsMatchPreviousResult = item.w === item.subject.getLayoutW() && item.h === item.subject.getLayoutH();
                if (dimensionsMatchPreviousResult) {
                    // Cache is valid.
                    return true;
                }
                else {
                    const crossAxisSize = layout.crossAxisSize;
                    layout.performResizeMainAxis(layout.mainAxisSize);
                    layout.performResizeCrossAxis(crossAxisSize);
                }
            }
        }
        return false;
    }
    finalizeItemAndChildren(item) {
        this.finalizeItem(item);
        this.finalizeItemChildren(item);
    }
    finalizeItem(item) {
        if (this.isReverse) {
            this.reverseMainAxisLayoutPos(item);
        }
        let x = item.getAxisLayoutPos(true);
        let y = item.getAxisLayoutPos(false);
        let w = item.getAxisLayoutSize(true);
        let h = item.getAxisLayoutSize(false);
        x += this.horizontalPaddingOffset;
        y += this.verticalPaddingOffset;
        w += item.getHorizontalPadding();
        h += item.getVerticalPadding();
        x += item.getHorizontalMarginOffset();
        y += item.getVerticalMarginOffset();
        item.clearRecalcFlag();
        item.setLayout(x, y, w, h);
    }
    finalizeItemChildren(item) {
        if (item.isFlexEnabled()) {
            const updater = new ItemCoordinatesUpdater(item.flex.layout);
            updater.finalizeItems();
        }
    }
    reverseMainAxisLayoutPos(item) {
        const endPos = item.flexItem.getMainAxisLayoutPos() + item.flexItem.getMainAxisLayoutSizeWithPaddingAndMargin();
        const reversedPos = this.layout.mainAxisSize - endPos;
        item.flexItem.setMainAxisLayoutPos(reversedPos);
    }
}
exports.ItemCoordinatesUpdater = ItemCoordinatesUpdater;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlexNode_1 = __webpack_require__(46);
const COORDINATES_CHANGED = 2;
const LAYOUT_CHANGED = 256;
class FlexTarget {
    constructor() {
        this._children = [];
        // Layout results.
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        // Specified coordinates and dimensions.
        this._sx = 0;
        this._sy = 0;
        this._sw = 0;
        this._sh = 0;
        this._optFlags = 0;
        this._visible = true;
        this.flags = 0;
        this.hasUpdates = false;
    }
    getChildren() {
        return this._children;
    }
    get skipInLayout() {
        return this._layout ? this._layout.skip : false;
    }
    set skipInLayout(v) {
        if (this.skipInLayout !== v) {
            // Force an update as absolute layout may be affected (on itself or on layout children).
            this.triggerRecalcTranslate();
            this.layout.skip = v;
        }
    }
    get layout() {
        this.ensureLayout();
        return this._layout;
    }
    hasLayout() {
        return !!this._layout;
    }
    getLayout() {
        return this.layout;
    }
    get flex() {
        return this.layout.flex;
    }
    get flexItem() {
        return this.layout.flexItem;
    }
    ensureLayout() {
        if (!this._layout) {
            this._layout = new FlexNode_1.FlexNode(this);
        }
    }
    hasFlexLayout() {
        return this._layout && this._layout.isEnabled();
    }
    isFlexLayoutRoot() {
        return this._layout && this._layout.isLayoutRoot();
    }
    triggerLayout() {
        this.setFlag(LAYOUT_CHANGED);
    }
    onDimensionsChanged() {
        this.triggerRecalcTranslate();
    }
    triggerRecalcTranslate() {
        this.setFlag(COORDINATES_CHANGED);
    }
    setFlag(type) {
        this.flags |= type;
        this.setHasUpdates();
    }
    setHasUpdates() {
        let p = this;
        while (p && !p.hasUpdates) {
            p.hasUpdates = true;
            p = p._parent;
        }
    }
    hasRelativeDimensionFunctions() {
        return this._optFlags & 12;
    }
    update() {
        // Parent width or height could have been changed while we are using relative dimension functions.
        // Width or height might have been changed, which affects the flexbox layout.
        // Notice that this edge case only occurs for root flex containers.
        const relativeDimsFlexRoot = this.isFlexLayoutRoot() && this.hasRelativeDimensionFunctions();
        const mustLayout = this.flags & LAYOUT_CHANGED || relativeDimsFlexRoot;
        if (mustLayout) {
            this._layout.layoutFlexTree();
        }
        if (this._optFlags && !this.hasFlexLayout()) {
            this.applyRelativeFunctions();
        }
        if (this.flags & COORDINATES_CHANGED) {
            this.onChangedLayout();
        }
        if (this.hasUpdates) {
            this.flags = 0;
            this.hasUpdates = false;
            const children = this._children;
            if (children) {
                for (let i = 0, n = children.length; i < n; i++) {
                    children[i].update();
                }
            }
        }
    }
    applyRelativeFunctions() {
        const layoutParent = this.getLayoutParent();
        if (this._optFlags & 1) {
            const x = this._funcX(layoutParent.getLayoutW(), layoutParent.getLayoutH());
            if (x !== this._x) {
                this._x = x;
                this.flags |= COORDINATES_CHANGED;
            }
        }
        if (this._optFlags & COORDINATES_CHANGED) {
            const y = this._funcY(layoutParent.getLayoutW(), layoutParent.getLayoutH());
            if (y !== this._y) {
                this._y = y;
                this.flags |= COORDINATES_CHANGED;
            }
        }
        let changedDims = false;
        if (this._optFlags & 4) {
            const w = this._funcW(layoutParent.getLayoutW(), layoutParent.getLayoutH());
            if (w !== this._w) {
                this._w = w;
                changedDims = true;
            }
        }
        if (this._optFlags & 8) {
            const h = this._funcH(layoutParent.getLayoutW(), layoutParent.getLayoutH());
            if (h !== this._h) {
                this._h = h;
                changedDims = true;
            }
        }
        if (changedDims) {
            this.onDimensionsChanged();
        }
    }
    getLayoutParent() {
        let current = this.getParent();
        while (current.skipInLayout) {
            const parent = current.getParent();
            if (!parent)
                return current;
            current = parent;
        }
        return current;
    }
    onChangedLayout() {
        // This is invoked when layout coordinates were changed.
    }
    get x() {
        return this._sx;
    }
    set x(v) {
        const dx = v - this._sx;
        if (dx) {
            this._sx = v;
            if (!this._funcX) {
                // No recalc is necessary because the layout offset can be updated directly.
                this._x += dx;
            }
        }
    }
    getSourceFuncX() {
        return this._funcX;
    }
    set funcX(v) {
        if (this._funcX !== v) {
            if (v) {
                this._optFlags |= 1;
                this._funcX = v;
            }
            else {
                this.disableFuncX();
            }
            if (this.hasFlexLayout()) {
                this._layout.forceLayout();
            }
            else {
                this.triggerRecalcTranslate();
            }
        }
    }
    disableFuncX() {
        this._optFlags = this._optFlags & (0xffff - 1);
        this._funcX = undefined;
    }
    get y() {
        return this._sy;
    }
    set y(v) {
        const dy = v - this._sy;
        if (dy) {
            this._sy = v;
            if (!this._funcY) {
                // No recalc is necessary because the layout offset can be updated directly.
                this._y += dy;
            }
        }
    }
    getSourceFuncY() {
        return this._funcY;
    }
    set funcY(v) {
        if (this._funcY !== v) {
            if (v) {
                this._optFlags |= 2;
                this._funcY = v;
            }
            else {
                this.disableFuncY();
            }
            if (this.hasFlexLayout()) {
                this._layout.forceLayout();
            }
            else {
                this.triggerRecalcTranslate();
            }
        }
    }
    disableFuncY() {
        this._optFlags = this._optFlags & (0xffff - 2);
        this._funcY = undefined;
    }
    get w() {
        return this._sw;
    }
    set w(v) {
        if (this._sw !== v) {
            this._sw = v;
            if (this.hasFlexLayout()) {
                this._layout.updatedSourceW();
            }
            else {
                this._w = v;
                this.onDimensionsChanged();
            }
        }
    }
    getSourceFuncW() {
        return this._funcW;
    }
    set funcW(v) {
        if (this._funcW !== v) {
            if (v) {
                this._optFlags |= 4;
                this._funcW = v;
            }
            else {
                this.disableFuncW();
            }
            if (this.hasFlexLayout()) {
                this.layout.updatedSourceW();
            }
            else {
                this.onDimensionsChanged();
            }
        }
    }
    disableFuncW() {
        this._optFlags = this._optFlags & (0xffff - 4);
        this._funcW = undefined;
    }
    get h() {
        return this._sh;
    }
    set h(v) {
        if (this._sh !== v) {
            this._sh = v;
            if (this.hasFlexLayout()) {
                this._layout.updatedSourceH();
            }
            else {
                this._h = v;
                this.onDimensionsChanged();
            }
        }
    }
    getSourceFuncH() {
        return this._funcH;
    }
    set funcH(v) {
        if (this._funcH !== v) {
            if (v) {
                this._optFlags |= 8;
                this._funcH = v;
            }
            else {
                this.disableFuncH();
            }
            if (this.hasFlexLayout()) {
                this.layout.updatedSourceH();
            }
            else {
                this.onDimensionsChanged();
            }
        }
    }
    disableFuncH() {
        this._optFlags = this._optFlags & (0xffff - 8);
        this._funcH = undefined;
    }
    getParent() {
        return this._parent;
    }
    setParent(p) {
        var _a;
        if (this._parent !== p) {
            const prevParent = this._parent;
            this._parent = p;
            if (this._layout || ((_a = FlexNode_1.FlexNode.getActiveLayoutNode(p)) === null || _a === void 0 ? void 0 : _a.isFlexEnabled())) {
                this.layout.setParent(prevParent, p);
            }
            if (prevParent) {
                prevParent.triggerRecalcTranslate();
            }
            if (p) {
                p.triggerRecalcTranslate();
            }
        }
    }
    setChildren(children) {
        this._children = children;
        children.forEach((child) => {
            child.setParent(this);
        });
    }
    get children() {
        return this._children;
    }
    addChild(child) {
        this.addChildAt(child, this._children.length);
    }
    addChildAt(child, index) {
        if (!this._children)
            this._children = [];
        this._children.splice(index, 0, child);
        child.setParent(this);
    }
    removeChildAt(index) {
        if (this._children) {
            const child = this._children[index];
            this._children.splice(index, 1);
            child.setParent(undefined);
        }
    }
    setLayoutCoords(x, y) {
        if (this._x !== x || this._y !== y) {
            this._x = x;
            this._y = y;
            this.triggerRecalcTranslate();
        }
    }
    setLayoutDimensions(w, h) {
        if (this._w !== w || this._h !== h) {
            this._w = w;
            this._h = h;
            this.triggerRecalcTranslate();
        }
    }
    get visible() {
        return this._visible;
    }
    set visible(v) {
        if (this._visible !== v) {
            this._visible = v;
            if (this.hasFlexLayout()) {
                this.layout.updateVisible();
            }
        }
    }
    isDisplayed() {
        return this._visible;
    }
    toJson(path = []) {
        const layout = [this._x, this._y, this._w, this._h];
        const json = {
            path: "[" + path.join("][") + "]",
            layout: layout.join(" "),
            w: this.getLayoutW(),
            h: this.getLayoutH(),
            x: this.getLayoutX(),
            y: this.getLayoutY(),
            sw: this.getSourceW(),
            sh: this.getSourceH(),
            sx: this.getSourceX(),
            sy: this.getSourceY(),
            flex: this._layout && this._layout.flex ? FlexTarget.flexToJson(this._layout.flex) : false,
            flexItem: this._layout && this._layout.flexItem ? FlexTarget.flexItemToJson(this._layout.flexItem) : false,
            children: this._children.map((c, index) => c.toJson(path.concat([index]))),
        };
        return json;
    }
    static flexToJson(flex) {
        return {
            direction: flex.direction,
            alignItems: flex.alignItems,
            alignContent: flex.alignContent,
            justifyContent: flex.justifyContent,
        };
    }
    static flexItemToJson(flexItem) {
        return {
            grow: flexItem.grow,
            shrink: flexItem.shrink,
            alignSelf: flexItem.alignSelf,
        };
    }
    toString() {
        const obj = this.toJson();
        return JSON.stringify(obj, null, 2);
    }
    getLocationString() {
        const i = this._parent ? this._parent._children.indexOf(this) : "R";
        let str = this._parent ? this._parent.getLocationString() : "";
        str += "[" + i + "]";
        return str;
    }
    getSourceX() {
        return this._sx;
    }
    getSourceY() {
        return this._sy;
    }
    getSourceW() {
        return this._sw;
    }
    getSourceH() {
        return this._sh;
    }
    getLayoutX() {
        return this._x;
    }
    getLayoutY() {
        return this._y;
    }
    getLayoutW() {
        return this._w;
    }
    getLayoutH() {
        return this._h;
    }
    static isFunction(value) {
        return typeof value === "function";
    }
}
exports.FlexTarget = FlexTarget;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Application render tree.
 * Copyright Metrological, 2017
 * Copyright Bas van Meurs, 2020
 */
Object.defineProperty(exports, "__esModule", { value: true });
const patch_1 = __webpack_require__(49);
const WebGLRenderer_1 = __webpack_require__(113);
const C2dRenderer_1 = __webpack_require__(118);
const Element_1 = __webpack_require__(16);
const ColorUtils_1 = __webpack_require__(10);
const TextureManager_1 = __webpack_require__(55);
const CoreContext_1 = __webpack_require__(56);
const textures_1 = __webpack_require__(40);
const WebPlatform_1 = __webpack_require__(125);
class Stage {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.destroyed = false;
        this._usedMemory = 0;
        this._lastGcFrame = 0;
        this.platform = new WebPlatform_1.WebPlatform(this);
        this.frameCounter = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.dt = 0;
        this._updateTextures = new Set();
        this._updatingFrame = false;
        this.clearColor = null;
        this.canvasWidth = -1;
        this.canvasHeight = -1;
        this.idsMap = new Map();
        this.gpuPixelsMemory = options.gpuPixelsMemory || 32e6;
        this.bufferMemory = options.bufferMemory || 16e6;
        this.defaultFontFace = options.defaultFontFace || ["sans-serif"];
        this.fixedTimestep = options.fixedTimestep || 0;
        this.useImageWorker = options.useImageWorker === undefined || options.useImageWorker;
        this.autostart = options.autostart !== false;
        this.pixelRatio = options.pixelRatio || this.getDefaultPixelRatio() || 1;
        this.canvas2d = options.canvas2d === true || !Stage.isWebglSupported();
        this.destroyed = false;
        this._usedMemory = 0;
        this._lastGcFrame = 0;
        this.platform.init();
        if (this.canvas2d) {
            console.log("Using canvas2d renderer");
            this.c2d = this.platform.createCanvasContext();
            this.gl = undefined;
            this._renderer = new C2dRenderer_1.C2dRenderer(this);
        }
        else {
            this.gl = this.platform.createWebGLContext();
            this.c2d = undefined;
            this._renderer = new WebGLRenderer_1.WebGLRenderer(this);
        }
        this.frameCounter = 0;
        this.textureManager = new TextureManager_1.TextureManager(this);
        // Preload rectangle texture.
        this.rectangleTexture = new textures_1.RectangleTexture(this);
        this.context = new CoreContext_1.CoreContext(this);
        this.root = new Element_1.Element(this);
        this.root.setAsRoot();
        this.context.root = this.root.core;
        this.processClearColorOption(options.clearColor);
        this.checkCanvasDimensions();
        if (this.autostart) {
            this.platform.startLoop();
        }
    }
    processClearColorOption(option) {
        switch (option) {
            case null:
                this.setClearColor(null);
                break;
            case undefined:
                this.setClearColor([0, 0, 0, 0]);
                break;
            default:
                this.setClearColor(ColorUtils_1.ColorUtils.getRgbaComponentsNormalized(ColorUtils_1.ColorUtils.getArgbFromAny(option)));
        }
    }
    get w() {
        return this.canvas.width;
    }
    get h() {
        return this.canvas.height;
    }
    get renderer() {
        return this._renderer;
    }
    static isWebglSupported() {
        try {
            return !!window.WebGLRenderingContext;
        }
        catch (e) {
            return false;
        }
    }
    destroy() {
        this.destroyed = true;
        this.platform.stopLoop();
        this.platform.destroy();
        this.context.destroy();
        this.textureManager.destroy();
        this._renderer.destroy();
    }
    stop() {
        this.platform.stopLoop();
    }
    resume() {
        this.platform.startLoop();
    }
    getCanvas() {
        return this.canvas;
    }
    getPixelRatio() {
        return this.pixelRatio;
    }
    // Marks a texture for updating it's source upon the next drawFrame.
    addUpdateTexture(texture) {
        if (this._updatingFrame) {
            // When called from the upload loop, we must immediately load the texture in order to avoid a 'flash'.
            texture._performUpdateSource();
        }
        else {
            this._updateTextures.add(texture);
        }
    }
    removeUpdateTexture(texture) {
        if (this._updateTextures) {
            this._updateTextures.delete(texture);
        }
    }
    hasUpdateTexture(texture) {
        return this._updateTextures && this._updateTextures.has(texture);
    }
    drawFrame() {
        this.checkCanvasDimensions();
        this.startTime = this.currentTime;
        this.currentTime = this.platform.getHrTime();
        if (this.fixedTimestep) {
            this.dt = this.fixedTimestep;
        }
        else {
            this.dt = !this.startTime ? 0.02 : 0.001 * (this.currentTime - this.startTime);
        }
        if (this.onFrameStart) {
            this.onFrameStart();
        }
        if (this._updateTextures.size) {
            this._updateTextures.forEach((texture) => {
                texture._performUpdateSource();
            });
            this._updateTextures = new Set();
        }
        if (this.onUpdate) {
            this.onUpdate();
        }
        const changes = this.context.hasRenderUpdates();
        if (changes) {
            this._updatingFrame = true;
            this.context.updateAndRender();
            this._updatingFrame = false;
        }
        this.platform.nextFrame(changes);
        if (this.onFrameEnd) {
            this.onFrameEnd();
        }
        this.frameCounter++;
    }
    isUpdatingFrame() {
        return this._updatingFrame;
    }
    forceRenderUpdate() {
        this.context.setRenderUpdatesFlag();
    }
    setClearColor(clearColor) {
        if (clearColor === null) {
            // Do not clear.
            this.clearColor = null;
        }
        else {
            this.clearColor = clearColor;
        }
        this.forceRenderUpdate();
    }
    getClearColor() {
        return this.clearColor;
    }
    createElement(settings) {
        return patch_1.Patcher.createObject(settings, Element_1.Element, this);
    }
    createShader(settings) {
        return patch_1.Patcher.createObject(settings, undefined, this);
    }
    get coordsWidth() {
        return this.canvasWidth / this.pixelRatio;
    }
    get coordsHeight() {
        return this.canvasHeight / this.pixelRatio;
    }
    addMemoryUsage(delta) {
        this._usedMemory += delta;
        if (this._lastGcFrame !== this.frameCounter) {
            if (this._usedMemory > this.gpuPixelsMemory) {
                this.gc(false);
                if (this._usedMemory > this.gpuPixelsMemory - 2e6) {
                    // Too little memory could be recovered. Aggressive cleanup.
                    this.gc(true);
                }
            }
        }
    }
    get usedMemory() {
        return this._usedMemory;
    }
    gc(aggressive) {
        if (this._lastGcFrame !== this.frameCounter) {
            this._lastGcFrame = this.frameCounter;
            const memoryUsageBefore = this._usedMemory;
            this.gcTextureMemory(aggressive);
            this.gcRenderTextureMemory(aggressive);
            this.renderer.gc(aggressive);
            console.log(`GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) /
                1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
            const other = this._usedMemory - this.textureManager.usedMemory - this.context.usedMemory;
            console.log(` Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.context.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
        }
    }
    gcTextureMemory(aggressive = false) {
        if (aggressive && this.root.visible) {
            // Make sure that ALL textures are cleaned;
            this.root.visible = false;
            this.textureManager.gc();
            this.root.visible = true;
        }
        else {
            this.textureManager.gc();
        }
    }
    gcRenderTextureMemory(aggressive = false) {
        if (aggressive && this.root.visible) {
            // Make sure that ALL render textures are cleaned;
            this.root.visible = false;
            this.context.freeUnusedRenderTextures(0);
            this.root.visible = true;
        }
        else {
            this.context.freeUnusedRenderTextures(0);
        }
    }
    getDrawingCanvas() {
        return this.platform.getDrawingCanvas();
    }
    update() {
        this.context.update();
    }
    isDestroyed() {
        return this.destroyed;
    }
    checkCanvasDimensions() {
        const rect = this.canvas.getBoundingClientRect();
        let changed = false;
        // Prevent resize recursion in dynamic layouts (flexbox etc).
        // Notice that when you would like to use dynamic resize, you should wrap the canvas element in a dynamically
        // resized div, and absolutely position the canvas in it with 100% width and height.
        const cssWidth = rect.width || this.canvas.width;
        if (Math.round(cssWidth) !== Math.round(this.canvasWidth)) {
            const newCanvasWidth = cssWidth * this.pixelRatio;
            changed = changed || newCanvasWidth !== this.canvasWidth;
            this.canvasWidth = newCanvasWidth;
        }
        const cssHeight = rect.height || this.canvas.height;
        if (Math.round(cssHeight) !== Math.round(this.canvasHeight)) {
            const newCanvasHeight = cssHeight * this.pixelRatio;
            changed = changed || newCanvasHeight !== this.canvasHeight;
            this.canvasHeight = newCanvasHeight;
        }
        if (changed) {
            this.updateCanvasSize();
        }
    }
    updateCanvasSize() {
        // Make sure that the canvas looks 'crisp'.
        this.canvas.width = Math.round(this.canvasWidth);
        this.canvas.height = Math.round(this.canvasHeight);
        // Reset dimensions.
        this.root.core.setupAsRoot();
        this.renderer.onResizeCanvasSize();
    }
    getElementsAtCoordinates(worldX, worldY) {
        const results = [];
        this.root.core.update();
        this.root.core.gatherElementsAtCoordinates(worldX, worldY, results);
        return results.reverse();
    }
    getDefaultPixelRatio() {
        return Math.min(window.devicePixelRatio, 2);
    }
    addId(id, element) {
        let elements = this.idsMap.get(id);
        if (!elements) {
            elements = [];
            this.idsMap.set(id, elements);
        }
        elements.push(element);
    }
    removeId(id, element) {
        const elements = this.idsMap.get(id);
        if (elements) {
            this.idsMap.set(id, elements.filter((el) => el !== element));
        }
    }
    getById(id) {
        const elements = this.idsMap.get(id);
        return elements ? elements[0] : undefined;
    }
    getMaxTextureSize() {
        if (this.gl) {
            return this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
        }
        else {
            return 2048;
        }
    }
}
exports.Stage = Stage;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SingleReferenceHandler_1 = __webpack_require__(50);
const Element_1 = __webpack_require__(16);
const Texture_1 = __webpack_require__(8);
const TextHandler_1 = __webpack_require__(109);
const ChildrenHandler_1 = __webpack_require__(110);
const ShaderHandler_1 = __webpack_require__(112);
exports.handlers = [
    new SingleReferenceHandler_1.SingleReferenceHandler(Element_1.Element, "texture", Texture_1.Texture, (obj) => [obj.stage]),
    new ShaderHandler_1.ShaderHandler(Element_1.Element, "shader"),
    new TextHandler_1.TextHandler(Element_1.Element, "text"),
    new ChildrenHandler_1.ChildrenHandler(Element_1.Element, "children"),
];


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Handler_1 = __webpack_require__(26);
const text_1 = __webpack_require__(41);
const Utils_1 = __webpack_require__(7);
const Patcher_1 = __webpack_require__(12);
class TextHandler extends Handler_1.Handler {
    handle(obj, settings) {
        if (!obj.texture || !(obj.texture instanceof text_1.TextTexture)) {
            obj.enableTextTexture();
        }
        if (Utils_1.Utils.isString(settings)) {
            Patcher_1.Patcher.patchObjectProperty(obj.texture, "text", settings);
        }
        else {
            Patcher_1.Patcher.patchObject(obj.texture, settings);
        }
    }
}
exports.TextHandler = TextHandler;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Handler_1 = __webpack_require__(26);
const ChildList_1 = __webpack_require__(111);
class ChildrenHandler extends Handler_1.Handler {
    handle(obj, settings) {
        const childList = new ChildList_1.ChildList(obj);
        childList.patch(settings);
    }
}
exports.ChildrenHandler = ChildrenHandler;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Element_1 = __webpack_require__(16);
const Utils_1 = __webpack_require__(7);
const Patcher_1 = __webpack_require__(12);
class ChildList {
    constructor(obj) {
        this.element = obj;
        this.c = this.element.childList;
    }
    patch(settings) {
        if (Utils_1.Utils.isObjectLiteral(settings)) {
            this._setByObject(settings);
        }
        else if (Array.isArray(settings)) {
            this._setByArray(settings);
        }
    }
    getRefs() {
        return this.c.getRefs();
    }
    getIndex(item) {
        return this.c.getIndex(item);
    }
    add(item) {
        this.c.add(item);
    }
    setAt(item, index) {
        this.c.setAt(item, index);
    }
    _setByObject(settings) {
        // Overrule settings of known referenced items.
        const refs = this.getRefs();
        const crefs = Object.keys(settings);
        for (let i = 0, n = crefs.length; i < n; i++) {
            const cref = crefs[i];
            const s = settings[cref];
            let c = refs[cref];
            if (!c) {
                if (this.isItem(s)) {
                    // Replace previous item;
                    s.ref = cref;
                    this.add(s);
                }
                else {
                    // Create new item.
                    c = this.createItem(s);
                    c.ref = cref;
                    Patcher_1.Patcher.patchObject(c, s);
                    this.add(c);
                }
            }
            else {
                if (this.isItem(s)) {
                    if (c !== s) {
                        // Replace previous item;
                        const idx = this.getIndex(c);
                        s.ref = cref;
                        this.setAt(s, idx);
                    }
                }
                else {
                    Patcher_1.Patcher.patchObject(c, s);
                }
            }
        }
    }
    _equalsArray(array) {
        let same = true;
        const items = this.c.getItems();
        if (array.length === items.length) {
            for (let i = 0, n = items.length; i < n && same; i++) {
                same = same && items[i] === array[i];
            }
        }
        else {
            same = false;
        }
        return same;
    }
    _setByArray(array) {
        // For performance reasons, first check if the arrays match exactly and bail out if they do.
        if (this._equalsArray(array)) {
            return;
        }
        let refs;
        const newItems = [];
        for (let i = 0, n = array.length; i < n; i++) {
            const s = array[i];
            if (this.isItem(s)) {
                newItems.push(s);
            }
            else {
                const cref = s.ref;
                let c;
                if (cref) {
                    if (!refs)
                        refs = this.getRefs();
                    c = refs[cref];
                }
                if (!c) {
                    // Create new item.
                    c = this.createItem(s);
                }
                if (Utils_1.Utils.isObjectLiteral(s)) {
                    Patcher_1.Patcher.patchObject(c, s);
                }
                newItems.push(c);
            }
        }
        this.c.setItems(newItems);
    }
    createItem(object) {
        return Patcher_1.Patcher.createObject(object, Element_1.Element, this.element.stage);
    }
    isItem(object) {
        return object instanceof Element_1.Element;
    }
}
exports.ChildList = ChildList;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const SingleReferenceHandler_1 = __webpack_require__(50);
const Shader_1 = __webpack_require__(14);
class ShaderHandler extends SingleReferenceHandler_1.SingleReferenceHandler {
    constructor(sourceType, name) {
        super(sourceType, name, Shader_1.Shader, (obj) => [obj.stage.context]);
    }
    handle(obj, settings) {
        if (settings && settings.type) {
            const type = obj.stage.renderer.getSupportedShaderType(settings.type);
            if (!type) {
                console.warn("Shader has no implementation for render target: " + settings.type.name);
                obj[this.name] = undefined;
                return;
            }
            if (type !== settings.type) {
                return super.handle(obj, Object.assign({}, settings, { type }));
            }
        }
        super.handle(obj, settings);
    }
}
exports.ShaderHandler = ShaderHandler;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = __webpack_require__(7);
const WebGLCoreQuadList_1 = __webpack_require__(114);
const WebGLCoreQuadOperation_1 = __webpack_require__(115);
const WebGLCoreRenderExecutor_1 = __webpack_require__(116);
const WebGLDefaultShader_1 = __webpack_require__(5);
const WebGLShader_1 = __webpack_require__(23);
const Renderer_1 = __webpack_require__(54);
const WebGLCoreRenderState_1 = __webpack_require__(117);
class WebGLRenderer extends Renderer_1.Renderer {
    constructor() {
        super(...arguments);
        this.shaderPrograms = new Map();
    }
    destroy() {
        this.shaderPrograms.forEach((shaderProgram) => shaderProgram.destroy());
    }
    _createDefaultShader(context) {
        return new WebGLDefaultShader_1.WebGLDefaultShader(context);
    }
    _getShaderBaseType() {
        return WebGLShader_1.WebGLShader;
    }
    _getShaderAlternative(shaderType) {
        return shaderType.getWebGL();
    }
    createCoreQuadList() {
        return new WebGLCoreQuadList_1.WebGLCoreQuadList(this.stage.bufferMemory);
    }
    createCoreQuadOperation(context, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new WebGLCoreQuadOperation_1.WebGLCoreQuadOperation(context, shader, shaderOwner, renderTextureInfo, scissor, index);
    }
    createCoreRenderExecutor(context) {
        return new WebGLCoreRenderExecutor_1.WebGLCoreRenderExecutor(context);
    }
    createCoreRenderState(context) {
        return new WebGLCoreRenderState_1.WebGLCoreRenderState(context);
    }
    createRenderTexture(w, h, pw, ph) {
        const gl = this.stage.gl;
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        glTexture.params = {};
        glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
        glTexture.options = { format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE };
        // We need a specific framebuffer for every render texture.
        glTexture.framebuffer = gl.createFramebuffer();
        glTexture.projection = new Float32Array([2 / w, 2 / h]);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
        return glTexture;
    }
    freeRenderTexture(glTexture) {
        const gl = this.stage.gl;
        gl.deleteFramebuffer(glTexture.framebuffer);
        gl.deleteTexture(glTexture);
    }
    uploadTextureSource(textureSource, options) {
        const gl = this.stage.gl;
        const source = options.source;
        const format = {
            premultiplyAlpha: true,
            hasAlpha: true,
            texParams: {},
            texOptions: {
                format: 0,
                internalFormat: 0,
                type: gl.UNSIGNED_BYTE,
            },
        };
        if (options && options.premultiplyAlpha !== undefined) {
            format.premultiplyAlpha = options.premultiplyAlpha;
        }
        if (options && options.hasAlpha !== undefined) {
            format.hasAlpha = options.hasAlpha;
        }
        if (!format.hasAlpha) {
            format.premultiplyAlpha = false;
        }
        format.texParams = options.texParams || {};
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);
        const texParams = format.texParams;
        if (!texParams[gl.TEXTURE_MAG_FILTER])
            texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_MIN_FILTER])
            texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_WRAP_S])
            texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        if (!texParams[gl.TEXTURE_WRAP_T])
            texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
        for (const [key, value] of Object.entries(texParams)) {
            gl.texParameteri(gl.TEXTURE_2D, parseInt(key, 10), value);
        }
        const texOptions = format.texOptions;
        texOptions.format = (texOptions && texOptions.format) || (format.hasAlpha ? gl.RGBA : gl.RGB);
        texOptions.type = (texOptions && texOptions.type) || gl.UNSIGNED_BYTE;
        texOptions.internalFormat = (texOptions && texOptions.internalFormat) || texOptions.format;
        this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);
        glTexture.params = Utils_1.Utils.cloneObjShallow(texParams);
        glTexture.options = Utils_1.Utils.cloneObjShallow(texOptions);
        return glTexture;
    }
    freeTextureSource(textureSource) {
        this.stage.gl.deleteTexture(textureSource.nativeTexture);
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
        const gl = this.stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
        const pixelRatio = renderTexture.pixelRatio;
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, pixelRatio * (options.sx || 0), pixelRatio * (options.sy || 0), pixelRatio * (options.x || 0), pixelRatio * (options.y || 0), pixelRatio * (options.w || renderTexture.ow), pixelRatio * (options.h || renderTexture.oh));
    }
    getShaderProgram(shaderType) {
        return this.shaderPrograms.get(shaderType);
    }
    setShaderProgram(shaderType, program) {
        this.shaderPrograms.set(shaderType, program);
    }
    onResizeCanvasSize() {
        this.stage.context.renderExecutor.updateProjectionVector();
    }
}
exports.WebGLRenderer = WebGLRenderer;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreQuadList_1 = __webpack_require__(51);
class WebGLCoreQuadList extends CoreQuadList_1.CoreQuadList {
    constructor(bufferMemory) {
        super();
        this.dataLength = 0;
        this.data = new ArrayBuffer(bufferMemory);
        this.floats = new Float32Array(this.data);
        this.uints = new Uint32Array(this.data);
    }
    getDataLength() {
        return this.dataLength;
    }
    setDataLength(dataLength) {
        this.dataLength = dataLength;
    }
    reset() {
        super.reset();
        this.dataLength = 0;
    }
    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return index * 80;
    }
    getQuadContents() {
        // Debug: log contents of quad buffer.
        const floats = this.floats;
        const uints = this.uints;
        const lines = [];
        for (let i = 1; i <= this.length; i++) {
            let str = "entry " + i + ": ";
            for (let j = 0; j < 4; j++) {
                const b = i * 20 + j * 4;
                str +=
                    floats[b] +
                        "," +
                        floats[b + 1] +
                        ":" +
                        floats[b + 2] +
                        "," +
                        floats[b + 3] +
                        "[" +
                        uints[b + 4].toString(16) +
                        "] ";
            }
            lines.push(str);
        }
        return lines;
    }
}
exports.WebGLCoreQuadList = WebGLCoreQuadList;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreQuadOperation_1 = __webpack_require__(52);
class WebGLCoreQuadOperation extends CoreQuadOperation_1.CoreQuadOperation {
    constructor(context, shader, shaderOwner, renderTextureInfo, scissor, index) {
        super(context, shader, shaderOwner, renderTextureInfo, scissor, index);
        this.extraAttribsDataByteOffset = 0;
    }
    get quadList() {
        return super.quadList;
    }
    getWebGLShader() {
        return this.shader;
    }
    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return this.quadList.getAttribsDataByteOffset(this.index + index);
    }
    // Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
    getNormalRenderTextureCoords(x, y) {
        const coords = this.shaderOwner.getRenderTextureCoords(x, y);
        coords[0] /= this.getRenderWidth();
        coords[1] /= this.getRenderHeight();
        coords[0] = coords[0] * 2 - 1;
        coords[1] = 1 - coords[1] * 2;
        return coords;
    }
    getProjection() {
        if (this.renderTextureInfo && this.renderTextureInfo.renderTexture) {
            return this.renderTextureInfo.renderTexture.projection;
        }
        else {
            return this.context.renderExecutor.projection;
        }
    }
}
exports.WebGLCoreQuadOperation = WebGLCoreQuadOperation;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreRenderExecutor_1 = __webpack_require__(53);
class WebGLCoreRenderExecutor extends CoreRenderExecutor_1.CoreRenderExecutor {
    constructor(context) {
        super(context);
        this.currentShaderProgram = undefined;
        this.quadIndexType = WebGLRenderingContext.UNSIGNED_SHORT;
        this.gl = this.context.stage.gl;
        this.attribsBuffer = this.gl.createBuffer();
        this.quadsBuffer = this.gl.createBuffer();
        this.projection = this.getProjectionVector();
        this.init();
    }
    updateProjectionVector() {
        this.projection = this.getProjectionVector();
    }
    getProjectionVector() {
        return new Float32Array([2 / this.context.stage.coordsWidth, -2 / this.context.stage.coordsHeight]);
    }
    init() {
        const gl = this.gl;
        const maxQuads = Math.floor(this.renderState.quadList.data.byteLength / 80);
        const indexUintExtension = gl.getExtension("OES_element_index_uint");
        this.quadIndexType = indexUintExtension
            ? WebGLRenderingContext.UNSIGNED_INT
            : WebGLRenderingContext.UNSIGNED_SHORT;
        const arrayType = this.quadIndexType === WebGLRenderingContext.UNSIGNED_INT ? Uint32Array : Uint16Array;
        const allIndices = new arrayType(maxQuads * 6);
        // fill the indices with the quads to draw.
        for (let i = 0, j = 0; i < maxQuads * 6; i += 6, j += 4) {
            allIndices[i] = j;
            allIndices[i + 1] = j + 1;
            allIndices[i + 2] = j + 2;
            allIndices[i + 3] = j;
            allIndices[i + 4] = j + 2;
            allIndices[i + 5] = j + 3;
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quadsBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);
    }
    destroy() {
        super.destroy();
        this.gl.deleteBuffer(this.attribsBuffer);
        this.gl.deleteBuffer(this.quadsBuffer);
    }
    _reset() {
        super._reset();
        const gl = this.gl;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        this._stopShaderProgram();
        this._setupBuffers();
    }
    _setupBuffers() {
        const gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quadsBuffer);
        const element = new DataView(this.renderState.quadList.data, 0, this.renderState.quadList.getDataLength());
        gl.bindBuffer(gl.ARRAY_BUFFER, this.attribsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
    }
    _setupQuadOperation(quadOperation) {
        super._setupQuadOperation(quadOperation);
        this._useShaderProgram(quadOperation.getWebGLShader(), quadOperation);
    }
    _renderQuadOperation(op) {
        const shader = op.getWebGLShader();
        if (op.length || op.shader.addEmpty()) {
            shader.beforeDraw(op);
            shader.draw(op);
            shader.afterDraw(op);
        }
    }
    _useShaderProgram(shader, operation) {
        if (!shader.hasSameProgram(this.currentShaderProgram)) {
            if (this.currentShaderProgram) {
                this.currentShaderProgram.stopProgram();
            }
            shader.useProgram();
            this.currentShaderProgram = shader;
        }
        shader.setupUniforms(operation);
    }
    _stopShaderProgram() {
        if (this.currentShaderProgram) {
            // The currently used shader program should be stopped gracefully.
            this.currentShaderProgram.stopProgram();
            this.currentShaderProgram = undefined;
        }
    }
    _bindRenderTexture(renderTexture) {
        super._bindRenderTexture(renderTexture);
        const gl = this.gl;
        if (!renderTexture) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, this.context.stage.w, this.context.stage.h);
        }
        else {
            const rt = renderTexture;
            gl.bindFramebuffer(gl.FRAMEBUFFER, rt.framebuffer);
            gl.viewport(0, 0, rt.w, rt.h);
        }
    }
    _clearRenderTexture() {
        super._clearRenderTexture();
        const gl = this.gl;
        if (!this._renderTexture) {
            const glClearColor = this.context.stage.getClearColor();
            if (glClearColor) {
                gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
        }
        else {
            // Clear texture.
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    }
    _setScissor(area) {
        super._setScissor(area);
        if (this.scissor === area) {
            return;
        }
        this.scissor = area;
        const gl = this.gl;
        if (!area) {
            gl.disable(gl.SCISSOR_TEST);
        }
        else {
            gl.enable(gl.SCISSOR_TEST);
            const pixelRatio = this.context.stage.getPixelRatio();
            let y = area[1];
            if (this._renderTexture === undefined) {
                // Flip, for the main framebuffer the coordinates are inversed.
                y = this.context.stage.coordsHeight - (area[1] + area[3]);
            }
            gl.scissor(Math.round(area[0] * pixelRatio), Math.round(y * pixelRatio), Math.round(area[2] * pixelRatio), Math.round(area[3] * pixelRatio));
        }
    }
}
exports.WebGLCoreRenderExecutor = WebGLCoreRenderExecutor;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreRenderState_1 = __webpack_require__(27);
const ColorUtils_1 = __webpack_require__(10);
class WebGLCoreRenderState extends CoreRenderState_1.CoreRenderState {
    isRenderTextureReusable(renderTextureInfo) {
        const offset = (this.renderTextureInfo.reusableRenderStateOffset * 80) / 4;
        const floats = this.quadList.floats;
        const uints = this.quadList.uints;
        return (floats[offset] === 0 &&
            floats[offset + 1] === 0 &&
            floats[offset + 2] === 0 &&
            floats[offset + 3] === 0 &&
            uints[offset + 4] === 0xffffffff &&
            floats[offset + 5] === renderTextureInfo.w &&
            floats[offset + 6] === 0 &&
            floats[offset + 7] === 1 &&
            floats[offset + 8] === 0 &&
            uints[offset + 9] === 0xffffffff &&
            floats[offset + 10] === renderTextureInfo.w &&
            floats[offset + 11] === renderTextureInfo.h &&
            floats[offset + 12] === 1 &&
            floats[offset + 13] === 1 &&
            uints[offset + 14] === 0xffffffff &&
            floats[offset + 15] === 0 &&
            floats[offset + 16] === renderTextureInfo.h &&
            floats[offset + 17] === 0 &&
            floats[offset + 18] === 1 &&
            uints[offset + 19] === 0xffffffff);
    }
    finishRenderState() {
        // Set extra shader attribute data.
        let offset = this.length * 80;
        for (let i = 0, n = this.quadOperations.length; i < n; i++) {
            const quadOperation = this.quadOperations[i];
            quadOperation.extraAttribsDataByteOffset = offset;
            const extra = quadOperation.getWebGLShader().getExtraAttribBytesPerVertex() * 4 * quadOperation.length;
            offset += extra;
            if (extra) {
                quadOperation.getWebGLShader().setExtraAttribsInBuffer(quadOperation);
            }
        }
        this.quadList.setDataLength(offset);
    }
    addQuad(texture, elementCore) {
        const index = this.length;
        const quadList = this.quadList;
        let offset = index * 20;
        quadList.add(texture, elementCore);
        const r = elementCore.getRenderContext();
        const floats = quadList.floats;
        const uints = quadList.uints;
        const mca = ColorUtils_1.ColorUtils.mergeColorAlpha;
        const w = elementCore.getLayoutW();
        const h = elementCore.getLayoutH();
        if (r.tb !== 0 || r.tc !== 0) {
            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore.ulx;
            floats[offset++] = elementCore.uly;
            uints[offset++] = mca(elementCore.colorUl, r.alpha);
            floats[offset++] = r.px + w * r.ta;
            floats[offset++] = r.py + w * r.tc;
            floats[offset++] = elementCore.brx;
            floats[offset++] = elementCore.uly;
            uints[offset++] = mca(elementCore.colorUr, r.alpha);
            floats[offset++] = r.px + w * r.ta + h * r.tb;
            floats[offset++] = r.py + w * r.tc + h * r.td;
            floats[offset++] = elementCore.brx;
            floats[offset++] = elementCore.bry;
            uints[offset++] = mca(elementCore.colorBr, r.alpha);
            floats[offset++] = r.px + h * r.tb;
            floats[offset++] = r.py + h * r.td;
            floats[offset++] = elementCore.ulx;
            floats[offset++] = elementCore.bry;
            uints[offset] = mca(elementCore.colorBl, r.alpha);
        }
        else {
            // Simple.
            const cx = r.px + w * r.ta;
            const cy = r.py + h * r.td;
            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore.ulx;
            floats[offset++] = elementCore.uly;
            uints[offset++] = mca(elementCore.colorUl, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = r.py;
            floats[offset++] = elementCore.brx;
            floats[offset++] = elementCore.uly;
            uints[offset++] = mca(elementCore.colorUr, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = cy;
            floats[offset++] = elementCore.brx;
            floats[offset++] = elementCore.bry;
            uints[offset++] = mca(elementCore.colorBr, r.alpha);
            floats[offset++] = r.px;
            floats[offset++] = cy;
            floats[offset++] = elementCore.ulx;
            floats[offset++] = elementCore.bry;
            uints[offset] = mca(elementCore.colorBl, r.alpha);
        }
    }
}
exports.WebGLCoreRenderState = WebGLCoreRenderState;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dCoreQuadList_1 = __webpack_require__(119);
const C2dCoreQuadOperation_1 = __webpack_require__(120);
const C2dCoreRenderExecutor_1 = __webpack_require__(121);
const C2dDefaultShader_1 = __webpack_require__(15);
const C2dShader_1 = __webpack_require__(22);
const Renderer_1 = __webpack_require__(54);
const C2dTextureTintManager_1 = __webpack_require__(122);
const C2dCoreRenderState_1 = __webpack_require__(124);
class C2dRenderer extends Renderer_1.Renderer {
    constructor(stage) {
        super(stage);
        this.tintManager = new C2dTextureTintManager_1.C2dTextureTintManager(this.stage);
        this.setupCanvasAsRenderTexture(stage.canvas);
    }
    destroy() {
        this.tintManager.destroy();
    }
    _createDefaultShader(context) {
        return new C2dDefaultShader_1.C2dDefaultShader(context);
    }
    _getShaderBaseType() {
        return C2dShader_1.C2dShader;
    }
    _getShaderAlternative(shaderType) {
        return shaderType.getC2d();
    }
    createCoreQuadList() {
        return new C2dCoreQuadList_1.C2dCoreQuadList();
    }
    createCoreQuadOperation(context, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new C2dCoreQuadOperation_1.C2dCoreQuadOperation(context, shader, shaderOwner, renderTextureInfo, scissor, index);
    }
    createCoreRenderExecutor(context) {
        return new C2dCoreRenderExecutor_1.C2dCoreRenderExecutor(context);
    }
    createCoreRenderState(context) {
        return new C2dCoreRenderState_1.C2dCoreRenderState(context);
    }
    createRenderTexture(w, h, pw, ph) {
        const canvas = document.createElement("canvas");
        canvas.width = pw;
        canvas.height = ph;
        this.setupCanvasAsRenderTexture(canvas);
        return canvas;
    }
    freeRenderTexture(renderTexture) {
        this.tintManager.delete(renderTexture);
    }
    gc(aggressive) {
        this.tintManager.gc(aggressive);
    }
    uploadTextureSource(textureSource, options) {
        // In case of Context2d, we usually do not need to upload.
        // Only in case of ArrayBuffer
        // For canvas, we do not need to upload.
        if (options.source instanceof Uint8ClampedArray) {
            // Convert RGBA buffer to canvas.
            const canvas = document.createElement("canvas");
            canvas.width = options.width;
            canvas.height = options.height;
            const imageData = new ImageData(options.source, options.width, options.height);
            canvas.getContext("2d").putImageData(imageData, 0, 0);
            return canvas;
        }
        return options.source;
    }
    freeTextureSource(textureSource) {
        this.tintManager.delete(textureSource.nativeTexture);
    }
    setupCanvasAsRenderTexture(canvas) {
        const context = canvas.getContext("2d");
        canvas.context = context;
        canvas.context.scissor = undefined;
        // Save base state so we can restore the defaults later.
        context.save();
    }
    copyRenderTexture(renderTexture, nativeTexture, options) {
        throw new Error("Copy render texture not implemented");
    }
}
exports.C2dRenderer = C2dRenderer;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreQuadList_1 = __webpack_require__(51);
class C2dCoreQuadList extends CoreQuadList_1.CoreQuadList {
    constructor() {
        super(...arguments);
        this.renderContexts = [];
        this.modes = [];
    }
    setRenderContext(index, v) {
        this.renderContexts[index] = v;
    }
    setSimpleTc(index, v) {
        if (v) {
            this.modes[index] |= 1;
        }
        else {
            this.modes[index] -= this.modes[index] & 1;
        }
    }
    setWhite(index, v) {
        if (v) {
            this.modes[index] |= 2;
        }
        else {
            this.modes[index] -= this.modes[index] & 2;
        }
    }
    getRenderContext(index) {
        return this.renderContexts[index];
    }
    getSimpleTc(index) {
        return this.modes[index] & 1;
    }
    getWhite(index) {
        return this.modes[index] & 2;
    }
}
exports.C2dCoreQuadList = C2dCoreQuadList;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreQuadOperation_1 = __webpack_require__(52);
class C2dCoreQuadOperation extends CoreQuadOperation_1.CoreQuadOperation {
    get quadList() {
        return super.quadList;
    }
    getC2dShader() {
        return this.shader;
    }
    getRenderContext(index) {
        return this.quadList.getRenderContext(this.index + index);
    }
    getSimpleTc(index) {
        return this.quadList.getSimpleTc(this.index + index);
    }
    getWhite(index) {
        return this.quadList.getWhite(this.index + index);
    }
}
exports.C2dCoreQuadOperation = C2dCoreQuadOperation;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreRenderExecutor_1 = __webpack_require__(53);
const ColorUtils_1 = __webpack_require__(10);
const CoreRenderState_1 = __webpack_require__(27);
class C2dCoreRenderExecutor extends CoreRenderExecutor_1.CoreRenderExecutor {
    constructor() {
        super(...arguments);
        this._mainRenderTexture = this.context.stage.getCanvas();
    }
    _renderQuadOperation(op) {
        const shader = op.getC2dShader();
        if (op.length || op.shader.addEmpty()) {
            const target = (this._renderTexture || this._mainRenderTexture);
            shader.beforeDraw(op, target);
            shader.draw(op, target);
            shader.afterDraw(op, target);
        }
    }
    _clearRenderTexture() {
        const context = this._getContext();
        const renderTexture = context.canvas;
        context.setTransform(1, 0, 0, 1, 0, 0);
        let clearColor = [0, 0, 0, 0];
        if (this._mainRenderTexture.context === context) {
            clearColor = this.context.stage.getClearColor();
        }
        if (clearColor) {
            if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
                context.clearRect(0, 0, renderTexture.width, renderTexture.height);
            }
            else {
                context.fillStyle = ColorUtils_1.ColorUtils.getRgbaStringFromArray(clearColor);
                // Do not use fillRect because it produces artifacts.
                context.globalCompositeOperation = "copy";
                context.beginPath();
                context.rect(0, 0, renderTexture.width, renderTexture.height);
                context.closePath();
                context.fill();
                context.globalCompositeOperation = "source-over";
            }
        }
    }
    _getContext() {
        if (this._renderTexture) {
            return this._renderTexture.context;
        }
        else {
            return this._mainRenderTexture.context;
        }
    }
    _restoreContext() {
        const context = this._getContext();
        context.restore();
        context.save();
        context.scissor = undefined;
    }
    _setScissor(area) {
        const context = this._getContext();
        if (!CoreRenderState_1.CoreRenderState.scissorsEqual(context.scissor, area)) {
            // Clipping is stored in the canvas context state.
            // We can't reset clipping alone so we need to restore the full context.
            this._restoreContext();
            const pixelRatio = this.context.stage.getPixelRatio();
            if (area) {
                context.beginPath();
                context.rect(Math.round(area[0] * pixelRatio), Math.round(area[1] * pixelRatio), Math.round(area[2] * pixelRatio), Math.round(area[3] * pixelRatio));
                context.closePath();
                context.clip();
            }
            context.scissor = area;
        }
    }
}
exports.C2dCoreRenderExecutor = C2dCoreRenderExecutor;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const C2dTintCache_1 = __webpack_require__(123);
class C2dTextureTintManager {
    constructor(stage) {
        this.stage = stage;
        this._usedMemory = 0;
        this._cachedNativeTextures = new Set();
    }
    destroy() {
        this.gc(true);
    }
    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    delete(nativeTexture) {
        // Should be called when native texture is cleaned up.
        if (this._hasCache(nativeTexture)) {
            const cache = this._getCache(nativeTexture);
            const prevMemUsage = cache.memoryUsage;
            cache.clear();
            this._cachedNativeTextures.delete(nativeTexture);
            this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
        }
    }
    getTintTexture(nativeTexture, color) {
        const frame = this.stage.frameCounter;
        this._cachedNativeTextures.add(nativeTexture);
        const cache = this._getCache(nativeTexture);
        const item = cache.get(color);
        item.lf = frame;
        if (item.tx) {
            if (nativeTexture.updateFrame > item.u) {
                // Native texture was updated in the mean time: renew.
                this._tintTexture(item.tx, nativeTexture, color);
            }
            return item.tx;
        }
        else {
            const before = cache.memoryUsage;
            // Find blanco tint texture.
            let target = cache.reuseTexture(frame);
            if (target) {
                target.context.clearRect(0, 0, target.w, target.h);
            }
            else {
                // Allocate new.
                target = document.createElement("canvas");
                target.w = nativeTexture.w;
                target.h = nativeTexture.h;
                target.width = nativeTexture.width;
                target.height = nativeTexture.height;
                target.context = target.getContext("2d");
            }
            this._tintTexture(target, nativeTexture, color);
            cache.set(color, target, frame);
            const after = cache.memoryUsage;
            if (after !== before) {
                this._addMemoryUsage(after - before);
            }
            return target;
        }
    }
    _tintTexture(target, source, color) {
        let col = color.toString(16);
        while (col.length < 6) {
            col = "0" + col;
        }
        target.context.fillStyle = "#" + col;
        target.context.globalCompositeOperation = "copy";
        target.context.fillRect(0, 0, source.w, source.h);
        target.context.globalCompositeOperation = "multiply";
        target.context.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.w, target.h);
        // Alpha-mix the texture.
        target.context.globalCompositeOperation = "destination-in";
        target.context.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.w, target.h);
    }
    _hasCache(nativeTexture) {
        return !!nativeTexture.tintCache;
    }
    _getCache(nativeTexture) {
        if (!nativeTexture.tintCache) {
            nativeTexture.tintCache = new C2dTintCache_1.C2dTintCache(nativeTexture);
        }
        return nativeTexture.tintCache;
    }
    gc(aggressive = false) {
        const frame = this.stage.frameCounter;
        let delta = 0;
        this._cachedNativeTextures.forEach((texture) => {
            const cache = this._getCache(texture);
            const before = cache.memoryUsage;
            cache.cleanup(frame);
            cache.releaseBlancoTextures();
            delta += cache.memoryUsage - before;
        });
        if (aggressive) {
            this._cachedNativeTextures.clear();
        }
        if (delta) {
            this._addMemoryUsage(delta);
        }
    }
}
exports.C2dTextureTintManager = C2dTextureTintManager;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class C2dTintCache {
    constructor(nativeTexture) {
        this.nativeTexture = nativeTexture;
        this._colors = new Map();
        this._blancoTextures = [];
        this._lastCleanupFrame = 0;
        this._memTextures = 0;
    }
    get memoryUsage() {
        return this._memTextures * this.nativeTexture.w * this.nativeTexture.h;
    }
    releaseBlancoTextures() {
        this._memTextures -= this._blancoTextures.length;
        this._blancoTextures = [];
    }
    clear() {
        this._blancoTextures = [];
        this._colors.clear();
        this._memTextures = 0;
    }
    get(color) {
        let item = this._colors.get(color);
        if (!item) {
            item = { lf: -1, tx: undefined, u: -1 };
            this._colors.set(color, item);
        }
        return item;
    }
    set(color, texture, frame) {
        const item = this.get(color);
        item.lf = frame;
        item.tx = texture;
        item.u = frame;
        this._memTextures++;
    }
    cleanup(frame) {
        // We only need to clean up once per frame.
        if (this._lastCleanupFrame !== frame) {
            // We limit blanco textures reuse to one frame only to prevent memory usage growth.
            this._blancoTextures = [];
            this._colors.forEach((item, color) => {
                // Clean up entries that were not used last frame.
                if (item.lf < frame - 1) {
                    if (item.tx) {
                        // Keep as reusable blanco texture.
                        this._blancoTextures.push(item.tx);
                    }
                    this._colors.delete(color);
                }
            });
            this._lastCleanupFrame = frame;
        }
    }
    reuseTexture(frame) {
        // Try to reuse textures, because creating them every frame is expensive.
        this.cleanup(frame);
        if (this._blancoTextures && this._blancoTextures.length) {
            this._memTextures--;
            return this._blancoTextures.pop();
        }
    }
}
exports.C2dTintCache = C2dTintCache;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const CoreRenderState_1 = __webpack_require__(27);
class C2dCoreRenderState extends CoreRenderState_1.CoreRenderState {
    isRenderTextureReusable(renderTextureInfo) {
        return false;
    }
    finishRenderState() {
        // Noop
    }
    addQuad(texture, elementCore) {
        const index = this.length;
        // Render context changes while traversing so we save it by ref.
        const quadList = this.quadList;
        quadList.add(texture, elementCore);
        quadList.setRenderContext(index, elementCore.getRenderContext());
        quadList.setWhite(index, elementCore.isWhite());
        quadList.setSimpleTc(index, elementCore.hasSimpleTexCoords());
    }
}
exports.C2dCoreRenderState = C2dCoreRenderState;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ImageWorker_1 = __webpack_require__(126);
/**
 * Platform-specific functionality.
 * Copyright Metrological, 2017
 * Copyright Bas van Meurs, 2020
 */
class WebPlatform {
    constructor(stage) {
        this.stage = stage;
        this._looping = false;
        this._awaitingLoop = false;
        this._imageWorker = undefined;
    }
    init() {
        if (this.stage.useImageWorker) {
            if (!window.createImageBitmap || !window.Worker) {
                console.warn("Can't use image worker because browser does not have createImageBitmap and Web Worker support");
            }
            else {
                // Firefox does support createImageBitmap, but not with the required paramater signature.
                const canvas = this.stage.getDrawingCanvas();
                canvas.width = 1;
                canvas.height = 1;
                window.createImageBitmap(canvas, {
                    premultiplyAlpha: "premultiply",
                    colorSpaceConversion: "none",
                    imageOrientation: "none",
                })
                    .then(() => {
                    console.log("Using image worker!");
                    this._imageWorker = new ImageWorker_1.ImageWorker();
                })
                    .catch(() => {
                    console.warn("Can't use image worker: createImageBitmap does not support signature. Using on-thread image parsing.");
                });
            }
        }
    }
    destroy() {
        if (this._imageWorker) {
            this._imageWorker.destroy();
        }
    }
    startLoop() {
        this._looping = true;
        if (!this._awaitingLoop) {
            this.loop();
        }
    }
    stopLoop() {
        this._looping = false;
    }
    loop() {
        const lp = () => {
            this._awaitingLoop = false;
            if (this._looping) {
                this.stage.drawFrame();
                requestAnimationFrame(lp);
                this._awaitingLoop = true;
            }
        };
        requestAnimationFrame(lp);
    }
    uploadGlTexture(gl, textureSource, source, options) {
        if (source.buffer) {
            // Uint8Array
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
        }
        else {
            // Web-specific data types.
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
        }
    }
    loadSrcTexture(info, cb) {
        const { src, hasAlpha } = info;
        let cancelCb;
        const isPng = src.indexOf(".png") >= 0;
        if (this._imageWorker) {
            // WPE-specific image parser.
            const image = this._imageWorker.create(src);
            image.onError = (err) => {
                return cb(err);
            };
            image.onLoad = (imageInfo) => {
                cb(undefined, {
                    source: imageInfo.imageBitmap,
                    renderInfo: { src },
                    hasAlpha: imageInfo.hasAlphaChannel,
                    premultiplyAlpha: true,
                });
            };
            cancelCb = () => {
                image.cancel();
            };
        }
        else {
            const image = new Image();
            if (!(src.substr(0, 5) === "data:")) {
                // Base64.
                image.crossOrigin = "Anonymous";
            }
            image.onerror = (err) => {
                // Ignore error message when cancelled.
                if (image.src) {
                    return cb(new Error("Image loading error: " + err));
                }
            };
            image.onload = () => {
                cb(undefined, {
                    source: image,
                    renderInfo: { src },
                    hasAlpha: isPng || hasAlpha,
                });
            };
            image.src = src;
            cancelCb = () => {
                image.onerror = null;
                image.onload = null;
                image.removeAttribute("src");
            };
        }
        return cancelCb;
    }
    createWebGLContext() {
        const canvas = this.stage.canvas;
        const opts = {
            alpha: true,
            antialias: false,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false,
        };
        const gl = (canvas.getContext("webgl", opts) ||
            canvas.getContext("experimental-webgl", opts));
        if (!gl) {
            throw new Error("This browser does not support webGL.");
        }
        return gl;
    }
    createCanvasContext() {
        const canvas = this.stage.canvas;
        const c2d = canvas.getContext("2d");
        if (!c2d) {
            throw new Error("This browser does not support 2d canvas.");
        }
        return c2d;
    }
    getHrTime() {
        return window.performance ? window.performance.now() : new Date().getTime();
    }
    getDrawingCanvas() {
        // We can't reuse this canvas because textures may load async.
        return document.createElement("canvas");
    }
    getTextureOptionsForDrawingCanvas(canvas) {
        const options = {
            source: canvas,
        };
        return options;
    }
    nextFrame(changes) {
        /* WebGL blits automatically */
    }
}
exports.WebPlatform = WebPlatform;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const createWorker_1 = __webpack_require__(127);
const ImageWorkerImage_1 = __webpack_require__(128);
class ImageWorker {
    constructor() {
        this._items = new Map();
        this._id = 0;
        this._worker = createWorker_1.createWorker();
        this._worker.postMessage({ type: "config", config: { path: window.location.href } });
        this._worker.onmessage = (e) => {
            if (e.data && e.data.id) {
                const id = e.data.id;
                const item = this._items.get(id);
                if (item) {
                    if (e.data.type === "data") {
                        this.finish(item, e.data.info);
                    }
                    else {
                        this.error(item, new Error(`Image loading error type ${e.data.info.type}: ${e.data.info.message}`));
                    }
                }
            }
        };
    }
    destroy() {
        if (this._worker) {
            this._worker.terminate();
        }
    }
    create(src) {
        const id = ++this._id;
        const item = new ImageWorkerImage_1.ImageWorkerImage(this, id, src);
        this._items.set(id, item);
        this._worker.postMessage({ type: "add", id, src });
        return item;
    }
    cancel(image) {
        this._worker.postMessage({ type: "cancel", id: image.id });
        this._items.delete(image.id);
    }
    error(image, info) {
        image.error(info);
        this._items.delete(image.id);
    }
    finish(image, info) {
        image.load(info);
        this._items.delete(image.id);
    }
}
exports.ImageWorker = ImageWorker;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function createWorker() {
    const code = `(${createWorkerServer.toString()})()`;
    const blob = new Blob([code.replace('"use strict";', "")]); // firefox adds "use strict"; to any function which might block worker execution so knock it off
    const blobURL = (window.URL ? URL : window.webkitURL).createObjectURL(blob, {
        type: "application/javascript; charset=utf-8",
    });
    return new Worker(blobURL);
}
exports.createWorker = createWorker;
/**
 * Notice that, within the createWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
 *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
 */
function createWorkerServer() {
    class ImageWorkerServer {
        constructor() {
            this.items = new Map();
            this.config = undefined;
            this.relativeBase = undefined;
            onmessage = (e) => {
                this._receiveMessage(e);
            };
        }
        static isPathAbsolute(path) {
            return /^(?:\/|[a-z]+:\/\/)/.test(path);
        }
        _receiveMessage(e) {
            if (e.data.type === "config") {
                this.config = e.data.config;
                const base = this.config.path;
                const parts = base.split("/");
                parts.pop();
                this.relativeBase = parts.join("/") + "/";
            }
            else if (e.data.type === "add") {
                this.add(e.data.id, e.data.src);
            }
            else if (e.data.type === "cancel") {
                this.cancel(e.data.id);
            }
        }
        add(id, src) {
            // Convert relative URLs.
            if (this.relativeBase && !ImageWorkerServer.isPathAbsolute(src)) {
                src = this.relativeBase + src;
            }
            if (src.substr(0, 2) === "//") {
                // This doesn't work for image workers.
                src = "http:" + src;
            }
            const item = new ImageWorkerServerItem(id, src);
            item.onFinish = (result) => {
                this.finish(item, result);
            };
            item.onError = (info) => {
                this.error(item, info);
            };
            this.items.set(id, item);
            item.start();
        }
        cancel(id) {
            const item = this.items.get(id);
            if (item) {
                item.cancel();
                this.items.delete(id);
            }
        }
        finish(item, info) {
            const { imageBitmap, hasAlphaChannel } = info;
            postMessage({
                type: "data",
                id: item.id,
                info: {
                    imageBitmap,
                    hasAlphaChannel,
                },
            }, [imageBitmap]);
            this.items.delete(item.id);
        }
        error(item, info) {
            const { type, message } = info;
            postMessage({
                type: "error",
                id: item.id,
                info: {
                    type,
                    message,
                },
            });
            this.items.delete(item.id);
        }
    }
    class ImageWorkerServerItem {
        constructor(id, src) {
            this.id = id;
            this.src = src;
            this.onError = undefined;
            this.onFinish = undefined;
            this.xhr = undefined;
            this.mimeType = undefined;
            this.canceled = false;
        }
        start() {
            this.xhr = new XMLHttpRequest();
            this.xhr.open("GET", this.src, true);
            this.xhr.responseType = "blob";
            this.xhr.onerror = (oEvent) => {
                this.error("connection", "Connection error");
            };
            this.xhr.onload = (oEvent) => {
                const blob = this.xhr.response;
                this.mimeType = blob.type;
                this.createImageBitmap(blob);
            };
            this.xhr.send();
        }
        createImageBitmap(blob) {
            createImageBitmap(blob, {
                premultiplyAlpha: "premultiply",
                colorSpaceConversion: "none",
                imageOrientation: "none",
            })
                .then((imageBitmap) => {
                this.finish({
                    imageBitmap,
                    hasAlphaChannel: this.hasAlphaChannel(),
                });
            })
                .catch(() => {
                this.error("parse", "Error parsing image data");
            });
        }
        hasAlphaChannel() {
            return this.mimeType && this.mimeType.indexOf("image/png") !== -1;
        }
        cancel() {
            if (this.canceled)
                return;
            if (this.xhr) {
                this.xhr.abort();
            }
            this.canceled = true;
        }
        error(type, message) {
            if (!this.canceled && this.onError) {
                this.onError({ type, message });
            }
        }
        finish(info) {
            if (!this.canceled && this.onFinish) {
                this.onFinish(info);
            }
        }
    }
    const worker = new ImageWorkerServer();
}


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ImageWorkerImage {
    constructor(manager, id, src) {
        this.manager = manager;
        this.id = id;
        this.src = src;
    }
    set onError(f) {
        this._onError = f;
    }
    set onLoad(f) {
        this._onLoad = f;
    }
    cancel() {
        this.manager.cancel(this);
    }
    load(info) {
        if (this._onLoad) {
            this._onLoad(info);
        }
    }
    error(info) {
        if (this._onError) {
            this._onError(info);
        }
    }
}
exports.ImageWorkerImage = ImageWorkerImage;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const mouseEvents_1 = __webpack_require__(30);
const touchEvents_1 = __webpack_require__(32);
const focusEvents_1 = __webpack_require__(33);
const keyboardEvents_1 = __webpack_require__(34);
exports.eventTranslators = Object.assign(Object.assign(Object.assign(Object.assign({}, mouseEvents_1.mouseEventTranslator), touchEvents_1.touchEventTranslator), focusEvents_1.focusEventTranslator), keyboardEvents_1.keyboardEventTranslator);


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function augmentTree2dElementEvent(e) {
    const node = e.element.data;
    const stage = node.stage;
    return Object.assign(Object.assign({}, e), { node, stage });
}
exports.augmentTree2dElementEvent = augmentTree2dElementEvent;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
const tree2d_1 = __webpack_require__(4);
class Picture extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.tex = new tree2d_1.ImageTexture(stage);
        this.el.texture = this.tex;
    }
    get src() {
        return this.tex.src;
    }
    set src(value) {
        this.tex.src = value;
    }
}
exports.Picture = Picture;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
class Rectangle extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.el.texture = stage.rectangleTexture;
    }
}
exports.Rectangle = Rectangle;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TypeUtils_1 = __webpack_require__(11);
const tree2d_1 = __webpack_require__(4);
const DynamicSizeTexture_1 = __webpack_require__(17);
class StyledRectangle extends DynamicSizeTexture_1.DynamicSizeTexture {
    constructor(stage) {
        super(stage);
        this.options = {};
        this.roundRectTexture = new tree2d_1.RoundRectTexture(this.stage);
        this.textureElement.texture = this.roundRectTexture;
    }
    get radius() {
        return this.options["radius"] ? this.options["radius"][0] : 0;
    }
    set radius(radius) {
        const r = TypeUtils_1.ensureFloat(radius);
        this.setOption("radius", [r, r, r, r]);
    }
    get "stroke-width"() {
        return this.options["strokeWidth"] ? this.options["strokeWidth"] : 0;
    }
    set "stroke-width"(v) {
        this.setOption("strokeWidth", TypeUtils_1.ensureInt(v));
    }
    get "stroke-color"() {
        return this.options["strokeColor"] ? this.options["strokeColor"] : 0xffffffff;
    }
    set "stroke-color"(v) {
        this.setOption("strokeColor", TypeUtils_1.ensureColor(v));
    }
    get fill() {
        return this.options["fill"] ? this.options["fill"] : true;
    }
    set fill(v) {
        this.setOption("fill", TypeUtils_1.ensureBoolean(v));
    }
    get "fill-color"() {
        return this.options["fillColor"] ? this.options["fillColor"] : 0xffffffff;
    }
    set "fill-color"(v) {
        this.setOption("fillColor", TypeUtils_1.ensureColor(v));
    }
    get "shadow-blur"() {
        return this.options["shadowBlur"] ? this.options["shadowBlur"] : 0;
    }
    set "shadow-blur"(v) {
        this.setOption("shadowBlur", TypeUtils_1.ensureFloat(v));
    }
    get "shadow-color"() {
        return this.options["shadowColor"] ? this.options["shadowColor"] : 0xffffffff;
    }
    set "shadow-color"(v) {
        this.setOption("shadowColor", TypeUtils_1.ensureColor(v));
    }
    get "shadow-offset-x"() {
        return this.options["shadowOffsetX"] ? this.options["shadowOffsetX"] : 0;
    }
    set "shadow-offset-x"(v) {
        this.setOption("shadowOffsetX", TypeUtils_1.ensureFloat(v));
    }
    get "shadow-offset-y"() {
        return this.options["shadowOffsetY"] ? this.options["shadowOffsetY"] : 0;
    }
    set "shadow-offset-y"(v) {
        this.setOption("shadowOffsetY", TypeUtils_1.ensureFloat(v));
    }
    updateDimensions(w, h) {
        this.options.w = w;
        this.options.h = h;
        this.updateRoundedRectangleTextureOptions();
    }
    setOption(property, value) {
        this.options[property] = value;
        this.updateRoundedRectangleTextureOptions();
    }
    updateRoundedRectangleTextureOptions() {
        this.roundRectTexture.options = this.options;
    }
    handleResize(element, w, h) {
        if (this.options) {
            this.updateDimensions(w, h);
        }
    }
}
exports.StyledRectangle = StyledRectangle;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const tree2d_1 = __webpack_require__(4);
const DynamicSizeTexture_1 = __webpack_require__(17);
class Svg extends DynamicSizeTexture_1.DynamicSizeTexture {
    constructor(stage) {
        super(stage);
        this.options = { w: 0, h: 0, src: "" };
        this.svgTexture = new tree2d_1.SvgTexture(this.stage);
        this.textureElement.texture = this.svgTexture;
    }
    get src() {
        return this.options.src;
    }
    set src(v) {
        this.options.src = v;
        this.updateTextureOptions();
    }
    updateDimensions(w, h) {
        this.options.w = w;
        this.options.h = h;
        this.updateTextureOptions();
    }
    updateTextureOptions() {
        this.svgTexture.options = this.options;
    }
    handleResize(element, w, h) {
        if (this.options) {
            this.updateDimensions(w, h);
        }
    }
}
exports.Svg = Svg;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Node_1 = __webpack_require__(18);
const tree2d_1 = __webpack_require__(4);
const TextTextureSettings_1 = __webpack_require__(57);
const Delegator_1 = __webpack_require__(58);
class TextTexture extends Node_1.Node {
    constructor(stage) {
        super(stage);
        this.texture = new tree2d_1.TextTexture(this.stage);
        this.settings = new TextTextureSettings_1.TextTextureSettings(() => this.update());
        this.el.texture = this.texture;
    }
    get text() {
        return this.texture.text;
    }
    set text(text) {
        this.texture.text = text;
        this.update();
    }
    setElementText(text) {
        this.texture.text = text.trim();
    }
    update() {
        this.texture.setSettings(this.settings.textSettings);
    }
}
exports.TextTexture = TextTexture;
Delegator_1.Delegator.delegate(TextTexture, TextTextureSettings_1.TextTextureSettings, "settings");


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
class Texture extends Container_1.Container {
    get texture() {
        return this.el.texture;
    }
    set texture(v) {
        this.el.texture = v;
    }
    set ["texture-factory"](v) {
        this.texture = v(this.stage);
    }
}
exports.Texture = Texture;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
const tree2d_1 = __webpack_require__(4);
const TypeUtils_1 = __webpack_require__(11);
class Grayscale extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.shader = new tree2d_1.WebGLGrayscaleShader(this.stage.context);
        this.el.renderToTexture = true;
        this.el.shader = this.shader;
    }
    get amount() {
        return this.shader.amount;
    }
    set amount(v) {
        this.shader.amount = TypeUtils_1.ensureFloat(v);
    }
}
exports.Grayscale = Grayscale;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
const tree2d_1 = __webpack_require__(4);
const TypeUtils_1 = __webpack_require__(11);
class Rounded extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.shader = new tree2d_1.WebGLRoundedRectangleShader(this.stage.context);
        this.el.shader = this.shader;
        this.el.renderToTexture = true;
    }
    get radius() {
        return this.shader.radius;
    }
    set radius(v) {
        this.shader.radius = TypeUtils_1.ensureFloat(v);
    }
}
exports.Rounded = Rounded;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
const tree2d_1 = __webpack_require__(4);
class BoxBlur extends Container_1.Container {
    constructor(stage) {
        super(stage);
        this.shader = new tree2d_1.WebGLBoxBlurShader(this.stage.context);
        this.el.shader = this.shader;
        this.el.renderToTexture = true;
    }
}
exports.BoxBlur = BoxBlur;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
class Shader extends Container_1.Container {
    get shader() {
        return this.el.shader;
    }
    set shader(v) {
        this.el.shader = v;
    }
    set ["shader-factory"](v) {
        this.shader = v(this.stage.context);
    }
}
exports.Shader = Shader;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(28);
class Comment extends Base_1.Base {
    constructor(text) {
        super(undefined);
        this.text = text;
    }
}
exports.Comment = Comment;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __webpack_require__(28);
class TextNode extends Base_1.Base {
    constructor(text) {
        super(undefined);
        this.text = text;
    }
}
exports.TextNode = TextNode;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function patchProp(el, key, prevValue, nextValue, isSVG, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    getSetter(key)(el, nextValue);
}
exports.patchProp = patchProp;
const obj = {};
const getSetter = (key) => {
    if (!obj[key]) {
        obj[key] = new Function("el", "value", `el["${key}"] = value`);
    }
    return obj[key];
};


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(18));
var Container_1 = __webpack_require__(6);
exports.Container = Container_1.Container;
var Paragraph_1 = __webpack_require__(59);
exports.Paragraph = Paragraph_1.Paragraph;
var DirectContainer_1 = __webpack_require__(35);
exports.DirectContainer = DirectContainer_1.DirectContainer;
__export(__webpack_require__(9));
__export(__webpack_require__(13));
__export(__webpack_require__(61));


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const runtime_1 = __webpack_require__(21);
const runtime_core_1 = __webpack_require__(3);
const tree2d_1 = __webpack_require__(4);
const events_1 = __webpack_require__(29);
const Root_1 = __webpack_require__(146);
exports.Vugel = runtime_core_1.defineComponent({
    props: {
        settings: { type: Object },
        position: { type: String, default: "relative" },
    },
    setup(props, setupContext) {
        const elRef = runtime_core_1.ref();
        const maxWidth = runtime_core_1.ref(4096);
        const maxHeight = runtime_core_1.ref(4096);
        runtime_core_1.onMounted(() => {
            let rendered = false;
            let vugelRenderer;
            let stage;
            let stageRoot;
            runtime_core_1.watchEffect(() => {
                var _a;
                if (!rendered && elRef.value) {
                    rendered = true;
                    stage = new tree2d_1.Stage(elRef.value, Object.assign({}, props.settings));
                    stage.eventHelpers = events_1.setupEvents(((_a = props.settings) === null || _a === void 0 ? void 0 : _a.eventsTarget) || elRef.value, stage);
                    vugelRenderer = runtime_1.createRendererForStage(stage);
                    stageRoot = new Root_1.Root(stage, stage.root);
                    // Auto-inherit dimensions.
                    stageRoot["func-w"] = (w) => w;
                    stageRoot["func-h"] = (w, h) => h;
                    // Keep correct aspect-ratio issues when the page is zoomed out.
                    const maxTextureSize = stage.getMaxTextureSize();
                    maxWidth.value = maxTextureSize / stage.pixelRatio;
                    maxHeight.value = maxTextureSize / stage.pixelRatio;
                }
                const defaultSlot = setupContext.slots.default;
                if (defaultSlot) {
                    vugelRenderer(runtime_core_1.h(runtime_core_1.Fragment, defaultSlot()), stageRoot);
                }
                else {
                    console.warn("No default slot is defined");
                }
            });
        });
        // We need to use a wrapper for flexible size layouting to work with tree2d pixelRatio canvas auto-resizing.
        return () => runtime_core_1.h("div", {
            class: "custom-renderer-wrapper",
            style: { position: props.position, maxWidth: maxWidth.value, maxHeight: maxHeight.value },
        }, [
            runtime_core_1.h("canvas", {
                class: "custom-renderer",
                style: { position: "absolute", width: "100%", height: "100%" },
                ref: elRef,
            }),
        ]);
    },
});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(6);
class Root extends Container_1.Container {
}
exports.Root = Root;


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var runtime_dom_esm_bundler = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/App.vue?vue&type=template&id=8e648fae


const _hoisted_1 = { style: {"position":"absolute","width":"100%","height":"100%","min-height":"750px","overflow":"hidden","display":"flex","flex-direction":"column"} }
const _hoisted_2 = { style: {"display":"flex","align-items":"center","background":"#ffffff","padding":"10px"} }
const _hoisted_3 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("p", { style: {"font-family":"sans-serif","margin":"0"} }, [
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("em", null, "Vugel example"),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createTextVNode"])(" ( "),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("a", {
    href: "https://github.com/Planning-nl/vugel-example",
    target: "_blank"
  }, "View source code on Github"),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createTextVNode"])(" ) ")
], -1 /* HOISTED */)

function render(_ctx, _cache) {
  const _component_examples = Object(runtime_core_esm_bundler["resolveComponent"])("examples")
  const _component_vugel = Object(runtime_core_esm_bundler["resolveComponent"])("vugel")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("div", null, [
    Object(runtime_core_esm_bundler["createVNode"])("div", _hoisted_1, [
      Object(runtime_core_esm_bundler["createVNode"])("div", _hoisted_2, [
        _hoisted_3,
        Object(runtime_core_esm_bundler["withDirectives"])(Object(runtime_core_esm_bundler["createVNode"])("select", {
          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (_ctx.example = $event)),
          style: {"margin-left":"50px"},
          onClick: _cache[2] || (_cache[2] = $event => (_ctx.myvar = 1)),
          onMousedown: _cache[3] || (_cache[3] = $event => (_ctx.myobj.x = 1))
        }, [
          (Object(runtime_core_esm_bundler["openBlock"])(true), Object(runtime_core_esm_bundler["createBlock"])(runtime_core_esm_bundler["Fragment"], null, Object(runtime_core_esm_bundler["renderList"])(_ctx.examples, (e) => {
            return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("option", {
              value: e.name
            }, Object(runtime_core_esm_bundler["toDisplayString"])(e.text), 9 /* TEXT, PROPS */, ["value"]))
          }), 256 /* UNKEYED_FRAGMENT */))
        ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
          [runtime_dom_esm_bundler["vModelSelect"], _ctx.example]
        ])
      ]),
      Object(runtime_core_esm_bundler["createVNode"])(_component_vugel, {
        settings: { clearColor: '#000000' },
        style: {"flex-grow":"1","position":"relative"}
      }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createCommentVNode"])(" notice that you must always use a single component tag (without v-if) here! "),
          Object(runtime_core_esm_bundler["createCommentVNode"])(" otherwise you'll run into trouble as we are mixin compilers at this level "),
          Object(runtime_core_esm_bundler["createVNode"])(_component_examples, { selected: _ctx.example }, null, 8 /* PROPS */, ["selected"])
        ]),
        _: 1
      })
    ])
  ]))
}
// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=8e648fae

// EXTERNAL MODULE: ./node_modules/vugel/lib/index.js
var lib = __webpack_require__(19);

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/Examples.vue?vue&type=template&id=284ca3d8&compiler=vugel


const Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_1 = {
  "func-w": "w",
  "func-h": "h"
}
const Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_2 = { "skip-in-layout": true }
const Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_3 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("container", { id: "teleport" }, null, -1 /* HOISTED */)

function Examplesvue_type_template_id_284ca3d8_compiler_vugel_render(_ctx, _cache) {
  const _component_picture_example = Object(runtime_core_esm_bundler["resolveComponent"])("picture-example")
  const _component_rectangle_example = Object(runtime_core_esm_bundler["resolveComponent"])("rectangle-example")
  const _component_text_example = Object(runtime_core_esm_bundler["resolveComponent"])("text-example")
  const _component_styled_rectangle_example = Object(runtime_core_esm_bundler["resolveComponent"])("styled-rectangle-example")
  const _component_drawing_example = Object(runtime_core_esm_bundler["resolveComponent"])("drawing-example")
  const _component_position_example = Object(runtime_core_esm_bundler["resolveComponent"])("position-example")
  const _component_center_example = Object(runtime_core_esm_bundler["resolveComponent"])("center-example")
  const _component_transforms_example = Object(runtime_core_esm_bundler["resolveComponent"])("transforms-example")
  const _component_visibility_example = Object(runtime_core_esm_bundler["resolveComponent"])("visibility-example")
  const _component_tinting_example = Object(runtime_core_esm_bundler["resolveComponent"])("tinting-example")
  const _component_clipping_example = Object(runtime_core_esm_bundler["resolveComponent"])("clipping-example")
  const _component_paragraph_example = Object(runtime_core_esm_bundler["resolveComponent"])("paragraph-example")
  const _component_particles_example = Object(runtime_core_esm_bundler["resolveComponent"])("particles-example")
  const _component_teleport_example = Object(runtime_core_esm_bundler["resolveComponent"])("teleport-example")
  const _component_direct_example = Object(runtime_core_esm_bundler["resolveComponent"])("direct-example")
  const _component_many_components = Object(runtime_core_esm_bundler["resolveComponent"])("many-components")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])("container", Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_2, [
      (_ctx.check('picture'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_picture_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('rectangle'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_rectangle_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('text'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_text_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('styled-rectangle'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_styled_rectangle_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('drawing'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_drawing_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('position'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_position_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('center'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_center_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('transforms'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_transforms_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('visibility'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_visibility_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('tinting'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_tinting_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('clipping'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_clipping_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('paragraph'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_paragraph_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('particles'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_particles_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('teleport'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_teleport_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('direct'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_direct_example, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true),
      (_ctx.check('many-components'))
        ? Object(runtime_core_esm_bundler["createVNode"])(_component_many_components, { key: 0 })
        : Object(runtime_core_esm_bundler["createCommentVNode"])("v-if", true)
    ]),
    Examplesvue_type_template_id_284ca3d8_compiler_vugel_hoisted_3
  ]))
}
// CONCATENATED MODULE: ./src/Examples.vue?vue&type=template&id=284ca3d8&compiler=vugel

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/TextExample.vue?vue&type=template&id=e052f044&compiler=vugel


const TextExamplevue_type_template_id_e052f044_compiler_vugel_hoisted_1 = {
  x: 10,
  y: 10,
  color: 0xffffffff,
  "font-size": 60,
  "font-weight": 900,
  "font-style": "italic",
  "font-face": "Serif",
  "margin-bottom": 20
}

function TextExamplevue_type_template_id_e052f044_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("text", TextExamplevue_type_template_id_e052f044_compiler_vugel_hoisted_1, " basic text rendering "))
}
// CONCATENATED MODULE: ./src/examples/TextExample.vue?vue&type=template&id=e052f044&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/TextExample.vue?vue&type=script&lang=ts
/* harmony default export */ var TextExamplevue_type_script_lang_ts = ({});

// CONCATENATED MODULE: ./src/examples/TextExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/TextExample.vue



TextExamplevue_type_script_lang_ts.render = TextExamplevue_type_template_id_e052f044_compiler_vugel_render

/* harmony default export */ var TextExample = (TextExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/PositionExample.vue?vue&type=template&id=098f86ba&compiler=vugel


function PositionExamplevue_type_template_id_098f86ba_compiler_vugel_render(_ctx, _cache) {
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("picture", {
        src: "./assets/rotterdam.jpg",
        "mount-x": _ctx.mountx,
        "mount-y": _ctx.mounty,
        x: _ctx.x,
        y: _ctx.y,
        w: _ctx.w,
        h: _ctx.h
      }, null, 8 /* PROPS */, ["mount-x", "mount-y", "x", "y", "w", "h"])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "x" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_x($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "y" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_y($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "w" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[3] || (_cache[3] = $event => (_ctx.set_w($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "h" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[4] || (_cache[4] = $event => (_ctx.set_h($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "mount-x" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            suffix: "px",
            onChange: _cache[5] || (_cache[5] = $event => (_ctx.set_mountx($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "mount-y" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            suffix: "px",
            onChange: _cache[6] || (_cache[6] = $event => (_ctx.set_mounty($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/PositionExample.vue?vue&type=template&id=098f86ba&compiler=vugel

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/form/DragBar.vue?vue&type=template&id=7b632915&compiler=vugel


const DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_1 = {
  h: 20,
  "flex-grow": 1,
  "min-width": 80,
  flex: true
}
const DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_2 = { ref: "dragTarget" }
const DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_3 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("styled-rectangle", {
  radius: 4,
  "stroke-width": 4,
  "stroke-color": 0xff000000,
  y: 0,
  h: 20,
  x: -5,
  w: 10,
  "fill-color": 0xffffffff
}, null, -1 /* HOISTED */)

function DragBarvue_type_template_id_7b632915_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])("container", {
      "flex-item": false,
      "func-w": "w",
      "func-h": "h",
      scale: _ctx.containerScale,
      "z-index": _ctx.containerScale,
      onMousedown: _cache[1] || (_cache[1] = $event => (_ctx.start($event))),
      onMousemove: _cache[2] || (_cache[2] = $event => (_ctx.move($event))),
      onMouseup: _cache[3] || (_cache[3] = $event => (_ctx.end($event))),
      onMouseout: _cache[4] || (_cache[4] = $event => (_ctx.end($event)))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["scale", "z-index"]),
    Object(runtime_core_esm_bundler["createVNode"])("styled-rectangle", {
      ref: "bar",
      radius: 4,
      "stroke-width": 4,
      "flex-grow": 1,
      "fill-color": _ctx.background,
      "stroke-color": 0xff000000,
      "pointer-events": false,
      onResize: _cache[5] || (_cache[5] = $event => (_ctx.updateValue($event)))
    }, [
      Object(runtime_core_esm_bundler["createVNode"])("text", {
        "func-x": "w/2",
        "func-y": "h/2+1",
        mount: 0.5,
        "font-face": "monospace",
        "font-size": 14,
        color: _ctx.foreground
      }, Object(runtime_core_esm_bundler["toDisplayString"])(_ctx.formattedValue), 9 /* TEXT, PROPS */, ["color"]),
      Object(runtime_core_esm_bundler["createVNode"])("container", DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_2, [
        DragBarvue_type_template_id_7b632915_compiler_vugel_hoisted_3
      ], 512 /* NEED_PATCH */)
    ], 40 /* PROPS, HYDRATE_EVENTS */, ["fill-color"])
  ]))
}
// CONCATENATED MODULE: ./src/examples/form/DragBar.vue?vue&type=template&id=7b632915&compiler=vugel

// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/form/DragBar.vue?vue&type=script&lang=ts

/* harmony default export */ var DragBarvue_type_script_lang_ts = ({
    props: {
        initialValue: { type: Number, default: 0 },
        min: { type: Number, default: 0 },
        max: { type: Number, default: 1 },
        suffix: { type: String, default: "" },
        digits: { type: Number, default: 2 },
        background: { type: Number, default: 0xffddddff },
        foreground: { type: Number, default: 0xff000000 },
    },
    setup(props, context) {
        const bar = Object(reactivity_esm_bundler["shallowRef"])(null);
        const dragTarget = Object(reactivity_esm_bundler["shallowRef"])(null);
        const value = Object(reactivity_esm_bundler["ref"])(-1);
        let startEvent = null;
        const start = (e) => {
            if (dragTarget.value) {
                startEvent = e;
            }
            containerScale.value = 100;
            update(e);
        };
        const update = (e) => {
            const localCoords = bar.value.getLocalOffset(e.canvasOffsetX, e.canvasOffsetY);
            const max = bar.value.el.renderWidth;
            const v = Math.min(max, Math.max(0, localCoords[0]));
            value.value = v / max;
        };
        const move = (e) => {
            if (startEvent) {
                update(e);
            }
        };
        const end = (e) => {
            startEvent = null;
            containerScale.value = 1;
        };
        const updateValue = () => {
            dragTarget.value.x = value.value * (bar.value.el.renderWidth - 10) + 5;
        };
        Object(runtime_core_esm_bundler["watch"])([value, bar], updateValue);
        const convertValue = (value) => {
            return props.min + (props.max - props.min) * value;
        };
        Object(runtime_core_esm_bundler["watch"])(value, (v) => {
            const convertedValue = convertValue(value.value);
            context.emit("change", { value: convertedValue });
        });
        const formatValue = (v) => {
            return (props.min + (props.max - props.min) * v).toFixed(props.digits) + props.suffix;
        };
        const formattedValue = Object(runtime_core_esm_bundler["computed"])(() => {
            return formatValue(value.value);
        });
        const convertToAmount = (value) => {
            return Math.max(0, Math.min(1, (value - props.min) / (props.max - props.min)));
        };
        value.value = convertToAmount(props.initialValue || 0);
        const containerScale = Object(reactivity_esm_bundler["ref"])(1);
        return {
            containerScale,
            start,
            move,
            end,
            bar,
            dragTarget,
            value,
            formattedValue,
            updateValue,
        };
    },
});

// CONCATENATED MODULE: ./src/examples/form/DragBar.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/form/DragBar.vue



DragBarvue_type_script_lang_ts.render = DragBarvue_type_template_id_7b632915_compiler_vugel_render

/* harmony default export */ var DragBar = (DragBarvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/form/Editor.vue?vue&type=template&id=07f4d231&compiler=vugel


const Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_1 = {
  "func-w": "w",
  flex: true,
  "flex-align-items": "flex-start"
}
const Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_2 = {
  "flex-grow": 1,
  w: 400,
  "min-height": 750
}
const Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_3 = {
  flex: true,
  w: 300,
  "flex-grow": 0.5,
  padding: 10,
  "flex-direction": "column",
  color: 0xeeffffff
}

function Editorvue_type_template_id_07f4d231_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])("container", Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_2, [
      Object(runtime_core_esm_bundler["renderSlot"])(_ctx.$slots, "content")
    ]),
    Object(runtime_core_esm_bundler["createVNode"])("rectangle", Editorvue_type_template_id_07f4d231_compiler_vugel_hoisted_3, [
      Object(runtime_core_esm_bundler["renderSlot"])(_ctx.$slots, "form-items")
    ])
  ]))
}
// CONCATENATED MODULE: ./src/examples/form/Editor.vue?vue&type=template&id=07f4d231&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/form/Editor.vue?vue&type=script&lang=ts
/* harmony default export */ var Editorvue_type_script_lang_ts = ({
    props: {
        description: { type: String, default: "" },
    },
});

// CONCATENATED MODULE: ./src/examples/form/Editor.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/form/Editor.vue



Editorvue_type_script_lang_ts.render = Editorvue_type_template_id_07f4d231_compiler_vugel_render

/* harmony default export */ var Editor = (Editorvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/form/FormItem.vue?vue&type=template&id=7c70d3f2&compiler=vugel


const FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_1 = {
  flex: true,
  "flex-direction": "column",
  padding: 5
}
const FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_2 = {
  color: 0xff000000,
  "font-size": 18,
  "font-face": "monospace"
}
const FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_3 = {
  flex: true,
  "flex-grow": 1,
  "margin-top": 5
}

function FormItemvue_type_template_id_7c70d3f2_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])("text", FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_2, Object(runtime_core_esm_bundler["toDisplayString"])(_ctx.name), 1 /* TEXT */),
    Object(runtime_core_esm_bundler["createVNode"])("container", FormItemvue_type_template_id_7c70d3f2_compiler_vugel_hoisted_3, [
      Object(runtime_core_esm_bundler["renderSlot"])(_ctx.$slots, "default")
    ])
  ]))
}
// CONCATENATED MODULE: ./src/examples/form/FormItem.vue?vue&type=template&id=7c70d3f2&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/form/FormItem.vue?vue&type=script&lang=ts
/* harmony default export */ var FormItemvue_type_script_lang_ts = ({
    props: {
        name: { type: String, default: "" },
        type: { type: String, default: "" },
        config: { type: Object, default: () => ({}) },
    },
    setup(props) {
        return {};
    },
});

// CONCATENATED MODULE: ./src/examples/form/FormItem.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/form/FormItem.vue



FormItemvue_type_script_lang_ts.render = FormItemvue_type_template_id_7c70d3f2_compiler_vugel_render

/* harmony default export */ var FormItem = (FormItemvue_type_script_lang_ts);
// CONCATENATED MODULE: ./src/examples/form/utils.ts

const passToRef = (r) => {
    return (e) => {
        r.value = e.value;
    };
};
const createChangeHandlers = (refNames) => {
    const result = {};
    refNames.forEach((refName) => {
        const r = Object(reactivity_esm_bundler["ref"])(0);
        result[refName] = r;
        result["set_" + refName] = passToRef(r);
    });
    return result;
};

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/PositionExample.vue?vue&type=script&lang=ts




/* harmony default export */ var PositionExamplevue_type_script_lang_ts = ({
    components: { DragBar: DragBar, Editor: Editor, item: FormItem },
    setup() {
        return Object.assign({}, createChangeHandlers(["x", "y", "mountx", "mounty", "w", "h"]));
    },
});

// CONCATENATED MODULE: ./src/examples/PositionExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/PositionExample.vue



PositionExamplevue_type_script_lang_ts.render = PositionExamplevue_type_template_id_098f86ba_compiler_vugel_render

/* harmony default export */ var PositionExample = (PositionExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/TransformsExample.vue?vue&type=template&id=5274ce4c&compiler=vugel


function TransformsExamplevue_type_template_id_5274ce4c_compiler_vugel_render(_ctx, _cache) {
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("picture", {
        src: "./assets/rotterdam.jpg",
        "scale-x": _ctx.scalex,
        "scale-y": _ctx.scaley,
        "pivot-x": _ctx.pivotx,
        "pivot-y": _ctx.pivoty,
        x: _ctx.x,
        y: _ctx.y,
        rotation: _ctx.rotation
      }, null, 8 /* PROPS */, ["scale-x", "scale-y", "pivot-x", "pivot-y", "x", "y", "rotation"])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "x" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_x($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "y" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 800,
            suffix: "px",
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_y($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "scalex" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 1,
            max: 4,
            onChange: _cache[3] || (_cache[3] = $event => (_ctx.set_scalex($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "scaley" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 1,
            max: 4,
            onChange: _cache[4] || (_cache[4] = $event => (_ctx.set_scaley($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "pivotx" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 0.5,
            onChange: _cache[5] || (_cache[5] = $event => (_ctx.set_pivotx($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "pivoty" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 0.5,
            onChange: _cache[6] || (_cache[6] = $event => (_ctx.set_pivoty($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "rotation" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            max: 2 * Math.PI,
            suffix: "rad",
            onChange: _cache[7] || (_cache[7] = $event => (_ctx.set_rotation($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/TransformsExample.vue?vue&type=template&id=5274ce4c&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/TransformsExample.vue?vue&type=script&lang=ts




/* harmony default export */ var TransformsExamplevue_type_script_lang_ts = ({
    components: { Editor: Editor, item: FormItem, DragBar: DragBar },
    setup() {
        return Object.assign({}, createChangeHandlers(["x", "y", "scalex", "scaley", "pivotx", "pivoty", "rotation"]));
    },
});

// CONCATENATED MODULE: ./src/examples/TransformsExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/TransformsExample.vue



TransformsExamplevue_type_script_lang_ts.render = TransformsExamplevue_type_template_id_5274ce4c_compiler_vugel_render

/* harmony default export */ var TransformsExample = (TransformsExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/ClippingExample.vue?vue&type=template&id=1595b592&compiler=vugel


const ClippingExamplevue_type_template_id_1595b592_compiler_vugel_hoisted_1 = {
  ref: "dragTarget",
  src: "./assets/rotterdam.jpg",
  x: -100,
  y: -100
}
const ClippingExamplevue_type_template_id_1595b592_compiler_vugel_hoisted_2 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", {
  x: 100,
  y: 420,
  color: 0xffffffff,
  "font-size": 14,
  "pointer-events": false
}, "drag and drop the logo to test clipping", -1 /* HOISTED */)

function ClippingExamplevue_type_template_id_1595b592_compiler_vugel_render(_ctx, _cache) {
  const _component_toggle = Object(runtime_core_esm_bundler["resolveComponent"])("toggle")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("container", {
        "func-w": "w",
        "func-h": "h",
        onMousedown: _cache[1] || (_cache[1] = $event => (_ctx.start($event))),
        onMousemove: _cache[2] || (_cache[2] = $event => (_ctx.move($event))),
        onMouseup: _cache[3] || (_cache[3] = $event => (_ctx.end($event))),
        onMouseleave: _cache[4] || (_cache[4] = $event => (_ctx.end($event)))
      }, [
        Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
          x: 100,
          y: 100,
          w: 300,
          h: 300,
          color: 0xffffffff,
          clipping: _ctx.clipping
        }, [
          Object(runtime_core_esm_bundler["createVNode"])("picture", ClippingExamplevue_type_template_id_1595b592_compiler_vugel_hoisted_1, null, 512 /* NEED_PATCH */)
        ], 8 /* PROPS */, ["clipping"]),
        ClippingExamplevue_type_template_id_1595b592_compiler_vugel_hoisted_2
      ], 32 /* HYDRATE_EVENTS */)
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "clipping" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_toggle, {
            "initial-value": true,
            onChange: _cache[5] || (_cache[5] = $event => (_ctx.set_clipping($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/ClippingExample.vue?vue&type=template&id=1595b592&compiler=vugel

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/form/Toggle.vue?vue&type=template&id=399bfc7c&compiler=vugel


const Togglevue_type_template_id_399bfc7c_compiler_vugel_hoisted_1 = {
  w: 40,
  h: 20
}

function Togglevue_type_template_id_399bfc7c_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", Togglevue_type_template_id_399bfc7c_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])("styled-rectangle", {
      w: 40,
      h: 20,
      radius: 10,
      "stroke-width": 4,
      "flex-grow": 1,
      "fill-color": _ctx.value ? 0xffaaffaa : 0xffffaaaa,
      "stroke-color": 0xff000000,
      onClick: _cache[1] || (_cache[1] = $event => (_ctx.click($event)))
    }, [
      Object(runtime_core_esm_bundler["createVNode"])("styled-rectangle", {
        radius: 10,
        x: _ctx.circleX,
        w: 20,
        h: 20,
        "mount-x": 0.5,
        "stroke-width": 4,
        "flex-grow": 1,
        "fill-color": 0xffffffff,
        "stroke-color": 0xff000000
      }, null, 8 /* PROPS */, ["x"])
    ], 8 /* PROPS */, ["fill-color"])
  ]))
}
// CONCATENATED MODULE: ./src/examples/form/Toggle.vue?vue&type=template&id=399bfc7c&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/form/Toggle.vue?vue&type=script&lang=ts

/* harmony default export */ var Togglevue_type_script_lang_ts = ({
    props: {
        initialValue: { type: Boolean, default: false },
    },
    setup(props, context) {
        const value = Object(reactivity_esm_bundler["ref"])(false);
        const click = (e) => {
            value.value = !value.value;
        };
        Object(runtime_core_esm_bundler["watch"])(value, (v) => {
            context.emit("change", { value: value.value });
        });
        value.value = props.initialValue;
        const circleX = Object(runtime_core_esm_bundler["computed"])(() => {
            return value.value ? 30 : 10;
        });
        return {
            value,
            click,
            circleX,
        };
    },
});

// CONCATENATED MODULE: ./src/examples/form/Toggle.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/form/Toggle.vue



Togglevue_type_script_lang_ts.render = Togglevue_type_template_id_399bfc7c_compiler_vugel_render

/* harmony default export */ var Toggle = (Togglevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/ClippingExample.vue?vue&type=script&lang=ts





/* harmony default export */ var ClippingExamplevue_type_script_lang_ts = ({
    components: { Editor: Editor, Toggle: Toggle, item: FormItem },
    setup() {
        const dragTarget = Object(reactivity_esm_bundler["ref"])(null);
        let startEvent = null;
        let startX = 0;
        let startY = 0;
        const start = (e) => {
            if (dragTarget.value) {
                startEvent = e;
                // As Vugel doesn't expose the properties, we refer directly to the element.
                startX = dragTarget.value.el.x;
                startY = dragTarget.value.el.y;
            }
        };
        const move = (e) => {
            if (startEvent) {
                const deltaX = e.canvasOffsetX - startEvent.canvasOffsetX;
                const deltaY = e.canvasOffsetY - startEvent.canvasOffsetY;
                dragTarget.value.x = startX + deltaX;
                dragTarget.value.y = startY + deltaY;
                // Do not scroll on mobile.
                e.originalEvent.preventDefault();
            }
        };
        const end = (e) => {
            startEvent = null;
        };
        return Object.assign({ start,
            move,
            end,
            dragTarget }, createChangeHandlers(["clipping"]));
    },
});

// CONCATENATED MODULE: ./src/examples/ClippingExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/ClippingExample.vue



ClippingExamplevue_type_script_lang_ts.render = ClippingExamplevue_type_template_id_1595b592_compiler_vugel_render

/* harmony default export */ var ClippingExample = (ClippingExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/VisibilityExample.vue?vue&type=template&id=5fc162ea&compiler=vugel


function VisibilityExamplevue_type_template_id_5fc162ea_compiler_vugel_render(_ctx, _cache) {
  const _component_toggle = Object(runtime_core_esm_bundler["resolveComponent"])("toggle")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("container", null, [
        Object(runtime_core_esm_bundler["createVNode"])("picture", {
          src: "./assets/rotterdam.jpg",
          alpha: _ctx.alpha,
          visible: _ctx.visible
        }, null, 8 /* PROPS */, ["alpha", "visible"])
      ])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "visible" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_toggle, {
            "initial-value": true,
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_visible($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "alpha" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 1,
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_alpha($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/VisibilityExample.vue?vue&type=template&id=5fc162ea&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/VisibilityExample.vue?vue&type=script&lang=ts





/* harmony default export */ var VisibilityExamplevue_type_script_lang_ts = ({
    components: { DragBar: DragBar, Toggle: Toggle, Editor: Editor, item: FormItem },
    setup() {
        return Object.assign({}, createChangeHandlers(["alpha", "visible"]));
    },
});

// CONCATENATED MODULE: ./src/examples/VisibilityExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/VisibilityExample.vue



VisibilityExamplevue_type_script_lang_ts.render = VisibilityExamplevue_type_template_id_5fc162ea_compiler_vugel_render

/* harmony default export */ var VisibilityExample = (VisibilityExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/CenterExample.vue?vue&type=template&id=6722a6db&compiler=vugel


const CenterExamplevue_type_template_id_6722a6db_compiler_vugel_hoisted_1 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
  "func-w": "w",
  h: 500,
  color: 0xff000000
}, [
  /*#__PURE__*/Object(runtime_core_esm_bundler["createCommentVNode"])(" calc functions for width and height "),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
    "func-w": "w",
    "func-h": "h",
    "color-left": 0xffff0000,
    "color-right": 0xff0000ff
  }),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createCommentVNode"])(" use mount to position an element relative to its size (can be used for centering with unknown width) "),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", {
    "func-x": "w/2",
    "func-y": "h/2",
    "mount-x": 0.5,
    "mount-y": 0.5
  }, "Centered"),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", {
    x: 0,
    y: 0,
    "mount-x": 0,
    "mount-y": 0
  }, "Top left"),
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", {
    "func-x": "w",
    "func-y": "h",
    "mount-x": 1,
    "mount-y": 1
  }, "Bottom right")
], -1 /* HOISTED */)

function CenterExamplevue_type_template_id_6722a6db_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(runtime_core_esm_bundler["Fragment"], null, [
    Object(runtime_core_esm_bundler["createCommentVNode"])("full width/height using relative functions "),
    CenterExamplevue_type_template_id_6722a6db_compiler_vugel_hoisted_1
  ], 64 /* STABLE_FRAGMENT */))
}
// CONCATENATED MODULE: ./src/examples/CenterExample.vue?vue&type=template&id=6722a6db&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/CenterExample.vue?vue&type=script&lang=ts
/* harmony default export */ var CenterExamplevue_type_script_lang_ts = ({});

// CONCATENATED MODULE: ./src/examples/CenterExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/CenterExample.vue



CenterExamplevue_type_script_lang_ts.render = CenterExamplevue_type_template_id_6722a6db_compiler_vugel_render

/* harmony default export */ var CenterExample = (CenterExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/PictureExample.vue?vue&type=template&id=19720206&compiler=vugel


const PictureExamplevue_type_template_id_19720206_compiler_vugel_hoisted_1 = {
  x: 10,
  y: 10,
  src: "./assets/rotterdam.jpg"
}

function PictureExamplevue_type_template_id_19720206_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("picture", PictureExamplevue_type_template_id_19720206_compiler_vugel_hoisted_1))
}
// CONCATENATED MODULE: ./src/examples/PictureExample.vue?vue&type=template&id=19720206&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/PictureExample.vue?vue&type=script&lang=ts
/* harmony default export */ var PictureExamplevue_type_script_lang_ts = ({});

// CONCATENATED MODULE: ./src/examples/PictureExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/PictureExample.vue



PictureExamplevue_type_script_lang_ts.render = PictureExamplevue_type_template_id_19720206_compiler_vugel_render

/* harmony default export */ var PictureExample = (PictureExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/RectangleExample.vue?vue&type=template&id=18c2691e&compiler=vugel


const RectangleExamplevue_type_template_id_18c2691e_compiler_vugel_hoisted_1 = {
  h: 400,
  x: 10,
  y: 10,
  "func-w": "w-20",
  color: "rgb(0, 255, 0)"
}

function RectangleExamplevue_type_template_id_18c2691e_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("rectangle", RectangleExamplevue_type_template_id_18c2691e_compiler_vugel_hoisted_1))
}
// CONCATENATED MODULE: ./src/examples/RectangleExample.vue?vue&type=template&id=18c2691e&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/RectangleExample.vue?vue&type=script&lang=ts
/* harmony default export */ var RectangleExamplevue_type_script_lang_ts = ({});

// CONCATENATED MODULE: ./src/examples/RectangleExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/RectangleExample.vue



RectangleExamplevue_type_script_lang_ts.render = RectangleExamplevue_type_template_id_18c2691e_compiler_vugel_render

/* harmony default export */ var RectangleExample = (RectangleExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/StyledRectangleExample.vue?vue&type=template&id=f09d49e2&compiler=vugel


const StyledRectangleExamplevue_type_template_id_f09d49e2_compiler_vugel_hoisted_1 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", { "font-size": "50" }, "contents..", -1 /* HOISTED */)

function StyledRectangleExamplevue_type_template_id_f09d49e2_compiler_vugel_render(_ctx, _cache) {
  const _component_toggle = Object(runtime_core_esm_bundler["resolveComponent"])("toggle")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_color_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("color-drag-bar")
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("styled-rectangle", {
        x: 20,
        y: 20,
        radius: _ctx.radius,
        "stroke-width": _ctx.strokeWidth,
        "stroke-color": _ctx.strokeColor,
        fill: _ctx.fill,
        "fill-color": _ctx.fillColor,
        "shadow-blur": _ctx.shadowBlur,
        "shadow-color": _ctx.shadowColor,
        flex: true,
        padding: 80
      }, [
        StyledRectangleExamplevue_type_template_id_f09d49e2_compiler_vugel_hoisted_1
      ], 8 /* PROPS */, ["radius", "stroke-width", "stroke-color", "fill", "fill-color", "shadow-blur", "shadow-color"])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "fill" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_toggle, {
            "initial-value": true,
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_fill($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, {
        name: "fill-color",
        visible: _ctx.fill
      }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_color_drag_bar, {
            "initial-value": 0xffff00ff,
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_fillColor($event)))
          })
        ]),
        _: 1
      }, 8 /* PROPS */, ["visible"]),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "radius" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 10,
            min: 0,
            max: 80,
            suffix: "px",
            onChange: _cache[3] || (_cache[3] = $event => (_ctx.set_radius($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "stroke-width" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 4,
            min: 0,
            max: 60,
            suffix: "px",
            onChange: _cache[4] || (_cache[4] = $event => (_ctx.set_strokeWidth($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "stroke-color" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_color_drag_bar, {
            "initial-value": 0xffffffff,
            onChange: _cache[5] || (_cache[5] = $event => (_ctx.set_strokeColor($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "shadow-blur" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 10,
            min: 0,
            max: 50,
            suffix: "px",
            onChange: _cache[6] || (_cache[6] = $event => (_ctx.set_shadowBlur($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "shadow-color" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_color_drag_bar, {
            "initial-value": 0xffffffff,
            onChange: _cache[7] || (_cache[7] = $event => (_ctx.set_shadowColor($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/StyledRectangleExample.vue?vue&type=template&id=f09d49e2&compiler=vugel

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/form/ColorDragBar.vue?vue&type=template&id=21c3d41d&compiler=vugel


const ColorDragBarvue_type_template_id_21c3d41d_compiler_vugel_hoisted_1 = {
  flex: true,
  "flex-grow": 1,
  "flex-direction": "column"
}

function ColorDragBarvue_type_template_id_21c3d41d_compiler_vugel_render(_ctx, _cache) {
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("container", ColorDragBarvue_type_template_id_21c3d41d_compiler_vugel_hoisted_1, [
    Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
      "initial-value": _ctx.initialComponents[0],
      "margin-bottom": 10,
      background: _ctx.redBackground,
      foreground: 0xffffffff,
      onChange: _cache[1] || (_cache[1] = $event => (_ctx.updateRed($event)))
    }, null, 8 /* PROPS */, ["initial-value", "background"]),
    Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
      "initial-value": _ctx.initialComponents[1],
      "margin-bottom": 10,
      background: _ctx.greenBackground,
      foreground: 0xffffffff,
      onChange: _cache[2] || (_cache[2] = $event => (_ctx.updateGreen($event)))
    }, null, 8 /* PROPS */, ["initial-value", "background"]),
    Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
      "initial-value": _ctx.initialComponents[2],
      "margin-bottom": 10,
      background: _ctx.blueBackground,
      foreground: 0xffffffff,
      onChange: _cache[3] || (_cache[3] = $event => (_ctx.updateBlue($event)))
    }, null, 8 /* PROPS */, ["initial-value", "background"]),
    Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
      "margin-bottom": 10,
      "initial-value": _ctx.initialComponents[3],
      background: _ctx.alphaBackground,
      foreground: _ctx.alphaForeground,
      onChange: _cache[4] || (_cache[4] = $event => (_ctx.updateAlpha($event)))
    }, null, 8 /* PROPS */, ["initial-value", "background", "foreground"])
  ]))
}
// CONCATENATED MODULE: ./src/examples/form/ColorDragBar.vue?vue&type=template&id=21c3d41d&compiler=vugel

// EXTERNAL MODULE: ./node_modules/tree2d/lib/index.js
var tree2d_lib = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/form/ColorDragBar.vue?vue&type=script&lang=ts



/* harmony default export */ var ColorDragBarvue_type_script_lang_ts = ({
    components: { DragBar: DragBar },
    props: {
        initialValue: { type: Number, default: 0 },
    },
    setup: function (props, context) {
        const red = Object(reactivity_esm_bundler["ref"])(-1);
        const green = Object(reactivity_esm_bundler["ref"])(-1);
        const blue = Object(reactivity_esm_bundler["ref"])(-1);
        const alpha = Object(reactivity_esm_bundler["ref"])(-1);
        const updateRed = (v) => {
            red.value = v.value;
        };
        const updateGreen = (v) => {
            green.value = v.value;
        };
        const updateBlue = (v) => {
            blue.value = v.value;
        };
        const updateAlpha = (v) => {
            alpha.value = v.value;
        };
        const initialComponents = tree2d_lib["ColorUtils"].getRgbaComponentsNormalized(props.initialValue);
        Object(runtime_core_esm_bundler["watch"])([red, green, blue, alpha], (values) => {
            const color = tree2d_lib["ColorUtils"].getArgbNumber([
                red.value * 255,
                green.value * 255,
                blue.value * 255,
                alpha.value * 255,
            ]);
            context.emit("change", { value: color });
        });
        const redBackground = Object(runtime_core_esm_bundler["computed"])(() => {
            return tree2d_lib["ColorUtils"].getArgbNumber([red.value * 255, 0, 0, 255]);
        });
        const greenBackground = Object(runtime_core_esm_bundler["computed"])(() => {
            return tree2d_lib["ColorUtils"].getArgbNumber([0, green.value * 255, 0, 255]);
        });
        const blueBackground = Object(runtime_core_esm_bundler["computed"])(() => {
            return tree2d_lib["ColorUtils"].getArgbNumber([0, 0, blue.value * 255, 255]);
        });
        const alphaBackground = Object(runtime_core_esm_bundler["computed"])(() => {
            return tree2d_lib["ColorUtils"].getArgbNumber([alpha.value * 255, alpha.value * 255, alpha.value * 255, 255]);
        });
        const alphaForeground = Object(runtime_core_esm_bundler["computed"])(() => {
            return alpha.value > 0.5 ? 0xff000000 : 0xffffffff;
        });
        return {
            red,
            green,
            blue,
            alpha,
            initialComponents,
            updateRed,
            updateGreen,
            updateBlue,
            updateAlpha,
            redBackground,
            greenBackground,
            blueBackground,
            alphaBackground,
            alphaForeground,
        };
    },
});

// CONCATENATED MODULE: ./src/examples/form/ColorDragBar.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/form/ColorDragBar.vue



ColorDragBarvue_type_script_lang_ts.render = ColorDragBarvue_type_template_id_21c3d41d_compiler_vugel_render

/* harmony default export */ var ColorDragBar = (ColorDragBarvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/StyledRectangleExample.vue?vue&type=script&lang=ts






/* harmony default export */ var StyledRectangleExamplevue_type_script_lang_ts = ({
    components: { ColorDragBar: ColorDragBar, DragBar: DragBar, Toggle: Toggle, Editor: Editor, item: FormItem },
    setup() {
        return Object.assign({}, createChangeHandlers([
            "radius",
            "fill",
            "fillColor",
            "strokeWidth",
            "strokeColor",
            "shadowBlur",
            "shadowColor",
        ]));
    },
});

// CONCATENATED MODULE: ./src/examples/StyledRectangleExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/StyledRectangleExample.vue



StyledRectangleExamplevue_type_script_lang_ts.render = StyledRectangleExamplevue_type_template_id_f09d49e2_compiler_vugel_render

/* harmony default export */ var StyledRectangleExample = (StyledRectangleExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/TintingExample.vue?vue&type=template&id=b6dc5c8c&compiler=vugel


function TintingExamplevue_type_template_id_b6dc5c8c_compiler_vugel_render(_ctx, _cache) {
  const _component_color_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("color-drag-bar")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
        h: 100,
        x: 20,
        y: 20,
        "func-w": "w-40",
        "color-left": _ctx.colorLeft,
        "color-right": _ctx.colorRight,
        "margin-bottom": 20
      }, null, 8 /* PROPS */, ["color-left", "color-right"]),
      Object(runtime_core_esm_bundler["createVNode"])("picture", {
        x: 20,
        y: 140,
        "color-left": _ctx.colorLeft,
        "color-right": _ctx.colorRight,
        src: "./assets/rotterdam.jpg"
      }, null, 8 /* PROPS */, ["color-left", "color-right"])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "color-left" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_color_drag_bar, {
            "initial-value": 0xffff00ff,
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_colorLeft($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "color-right" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_color_drag_bar, {
            "initial-value": 0xff00ffff,
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_colorRight($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/TintingExample.vue?vue&type=template&id=b6dc5c8c&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/TintingExample.vue?vue&type=script&lang=ts




/* harmony default export */ var TintingExamplevue_type_script_lang_ts = ({
    components: { ColorDragBar: ColorDragBar, Editor: Editor, item: FormItem },
    setup() {
        return Object.assign({}, createChangeHandlers(["colorLeft", "colorRight"]));
    },
});

// CONCATENATED MODULE: ./src/examples/TintingExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/TintingExample.vue



TintingExamplevue_type_script_lang_ts.render = TintingExamplevue_type_template_id_b6dc5c8c_compiler_vugel_render

/* harmony default export */ var TintingExample = (TintingExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/ParagraphExample.vue?vue&type=template&id=0443dbfc&compiler=vugel


const ParagraphExamplevue_type_template_id_0443dbfc_compiler_vugel_hoisted_1 = {
  x: 20,
  y: 20,
  "func-w": "w-40",
  "func-h": "h-40",
  "font-size": 40,
  "font-color": "red"
}

function ParagraphExamplevue_type_template_id_0443dbfc_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("paragraph", ParagraphExamplevue_type_template_id_0443dbfc_compiler_vugel_hoisted_1, " The paragraph has the ability to wrap text. Drag the width of the window to see it in action. "))
}
// CONCATENATED MODULE: ./src/examples/ParagraphExample.vue?vue&type=template&id=0443dbfc&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/ParagraphExample.vue?vue&type=script&lang=ts
/* harmony default export */ var ParagraphExamplevue_type_script_lang_ts = ({});

// CONCATENATED MODULE: ./src/examples/ParagraphExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/ParagraphExample.vue



ParagraphExamplevue_type_script_lang_ts.render = ParagraphExamplevue_type_template_id_0443dbfc_compiler_vugel_render

/* harmony default export */ var ParagraphExample = (ParagraphExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/DrawingExample.vue?vue&type=template&id=5242467c&compiler=vugel


function DrawingExamplevue_type_template_id_5242467c_compiler_vugel_render(_ctx, _cache) {
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("drawing", {
        ref: "drawing",
        w: _ctx.w,
        h: _ctx.h,
        onDraw: _cache[1] || (_cache[1] = $event => (_ctx.draw($event)))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["w", "h"])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "w" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 100,
            max: 600,
            suffix: "px",
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_w($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "h" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 100,
            max: 600,
            suffix: "px",
            onChange: _cache[3] || (_cache[3] = $event => (_ctx.set_h($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "x" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 170,
            max: 300,
            suffix: "px",
            onChange: _cache[4] || (_cache[4] = $event => (_ctx.set_gradient($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/DrawingExample.vue?vue&type=template&id=5242467c&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/DrawingExample.vue?vue&type=script&lang=ts





/* harmony default export */ var DrawingExamplevue_type_script_lang_ts = ({
    components: { DragBar: DragBar, Editor: Editor, item: FormItem },
    setup() {
        const handlers = createChangeHandlers(["gradient", "w", "h"]);
        const drawing = Object(reactivity_esm_bundler["ref"])(null);
        // Make sure that the drawing is updated after a change.
        Object(runtime_core_esm_bundler["watch"])(handlers.gradient, () => {
            if (drawing.value) {
                drawing.value.update();
            }
        });
        return Object.assign({ drawing,
            draw(info) {
                const ctx = info.context;
                ctx.beginPath();
                const rectangle = new Path2D();
                rectangle.rect(0, 0, info.w, info.h);
                const gradient = ctx.createLinearGradient(0, 0, handlers.gradient.value, 0);
                gradient.addColorStop(0, "magenta");
                gradient.addColorStop(0.5, "blue");
                gradient.addColorStop(1.0, "red");
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 20;
                ctx.stroke(rectangle);
                return {};
            } }, handlers);
    },
});

// CONCATENATED MODULE: ./src/examples/DrawingExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/DrawingExample.vue



DrawingExamplevue_type_script_lang_ts.render = DrawingExamplevue_type_template_id_5242467c_compiler_vugel_render

/* harmony default export */ var DrawingExample = (DrawingExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/ParticlesExample.vue?vue&type=template&id=3bc83456&compiler=vugel


function ParticlesExamplevue_type_template_id_3bc83456_compiler_vugel_render(_ctx, _cache) {
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_toggle = Object(runtime_core_esm_bundler["resolveComponent"])("toggle")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("container", {
        ref: "container",
        "func-w": "w",
        "func-h": "h",
        onMousemove: _cache[1] || (_cache[1] = $event => (_ctx.mousemove($event)))
      }, [
        (Object(runtime_core_esm_bundler["openBlock"])(true), Object(runtime_core_esm_bundler["createBlock"])(runtime_core_esm_bundler["Fragment"], null, Object(runtime_core_esm_bundler["renderList"])(_ctx.items, (item) => {
          return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("texture", {
            key: item.id,
            "texture-factory": _ctx.createCircle,
            x: item.x,
            y: item.y,
            mount: 0.5,
            color: item.color
          }, null, 8 /* PROPS */, ["texture-factory", "x", "y", "color"]))
        }), 128 /* KEYED_FRAGMENT */))
      ], 544 /* HYDRATE_EVENTS, NEED_PATCH */)
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "amount" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 6000,
            max: 20000,
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.changeAmount($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "direct updates" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_toggle, {
            "initial-value": false,
            onChange: _cache[3] || (_cache[3] = $event => (_ctx.changeCustom($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/ParticlesExample.vue?vue&type=template&id=3bc83456&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/ParticlesExample.vue?vue&type=script&lang=ts






class Item {
    constructor() {
        this.id = 0;
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.color = 0;
    }
}
/* harmony default export */ var ParticlesExamplevue_type_script_lang_ts = ({
    components: { DragBar: DragBar, Toggle: Toggle, Editor: Editor, item: FormItem },
    setup() {
        const amount = Object(reactivity_esm_bundler["ref"])(0);
        const items = Object(reactivity_esm_bundler["shallowRef"])([]);
        const container = Object(reactivity_esm_bundler["ref"])(null);
        let frames = 0;
        const loop = () => {
            var _a;
            frames++;
            if (frames === 100) {
                console.profile("frame 100-300");
            }
            if (frames === 300) {
                console.profileEnd("frame 100-300");
            }
            const n = Math.floor(amount.value);
            if (container.value) {
                const objs = items.value;
                objs.forEach((obj) => {
                    const dx = pos.value[0] - obj.x;
                    const dy = pos.value[1] - obj.y;
                    const dist2 = 0.1 * (dx * dx + dy * dy) + 100;
                    obj.vx = 0.995 * obj.vx + dx / dist2;
                    obj.vy = 0.995 * obj.vy + dy / dist2;
                    obj.x += obj.vx;
                    obj.y += obj.vy;
                });
                if (custom.value) {
                    update();
                }
                else {
                    // Force reactivity.
                    Object(reactivity_esm_bundler["triggerRef"])(items);
                }
                if (((_a = container.value) === null || _a === void 0 ? void 0 : _a.getChildren().length) !== n) {
                    const newItems = [];
                    const rw = container.value.el.renderWidth;
                    const rh = container.value.el.renderHeight;
                    for (let i = 0; i < n; i++) {
                        const item = new Item();
                        item.id = i;
                        item.x = Math.random() * rw;
                        item.y = Math.random() * rh;
                        item.vx = Math.random();
                        item.vy = Math.random();
                        item.color = tree2d_lib["ColorUtils"].getArgbNumber([
                            Math.random() * 255,
                            Math.random() * 255,
                            Math.random() * 255,
                            255,
                        ]);
                        newItems.push(item);
                    }
                    items.value = newItems;
                }
            }
            requestAnimationFrame(loop);
        };
        const update = () => {
            const ctr = container.value;
            if (ctr) {
                const children = ctr.getChildren();
                const objs = items.value;
                children.forEach((child, index) => {
                    child.x = objs[index].x;
                    child.y = objs[index].y;
                });
            }
        };
        loop();
        const pos = Object(reactivity_esm_bundler["shallowRef"])([0, 0]);
        const custom = Object(reactivity_esm_bundler["ref"])(false);
        const texture = Object(reactivity_esm_bundler["shallowRef"])(undefined);
        const textureNode = Object(reactivity_esm_bundler["shallowRef"])(undefined);
        let circleTexture = undefined;
        return {
            mousemove(e) {
                const offset = e.currentTarget.getLocalOffset(e.canvasOffsetX, e.canvasOffsetY);
                pos.value[0] = offset[0];
                pos.value[1] = offset[1];
            },
            changeAmount(e) {
                amount.value = e.value;
            },
            changeCustom(e) {
                custom.value = e.value;
            },
            amount,
            items,
            container,
            textureNode,
            texture,
            createCircle(stage) {
                if (!circleTexture) {
                    const tx = new tree2d_lib["RoundRectTexture"](stage);
                    tx.options = { w: 10, h: 10, radius: [5, 5, 5, 5], shadowBlur: 2, shadowColor: 0xffffffff };
                    circleTexture = tx;
                }
                return circleTexture;
            },
        };
    },
});

// CONCATENATED MODULE: ./src/examples/ParticlesExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/ParticlesExample.vue



ParticlesExamplevue_type_script_lang_ts.render = ParticlesExamplevue_type_template_id_3bc83456_compiler_vugel_render

/* harmony default export */ var ParticlesExample = (ParticlesExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/TeleportExample.vue?vue&type=template&id=1b69f624&compiler=vugel


const TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_hoisted_1 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("picture", { src: "./assets/rotterdam.jpg" }, [
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
    x: 10,
    y: 10,
    color: 0xaa000000,
    flex: true,
    padding: 10
  }, [
    /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("text", { "font-size": 16 }, "This content is teleported! ")
  ])
], -1 /* HOISTED */)
const TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_hoisted_2 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("container", null, [
  /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
    h: 400,
    x: 10,
    y: 10,
    "func-w": "w-20",
    color: "rgb(0, 255, 0)"
  })
], -1 /* HOISTED */)

function TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(runtime_core_esm_bundler["Fragment"], null, [
    Object(runtime_core_esm_bundler["createVNode"])(runtime_core_esm_bundler["Teleport"], { to: "#teleport" }, [
      TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_hoisted_1
    ]),
    TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_hoisted_2
  ], 64 /* STABLE_FRAGMENT */))
}
// CONCATENATED MODULE: ./src/examples/TeleportExample.vue?vue&type=template&id=1b69f624&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/TeleportExample.vue?vue&type=script&lang=ts

/* harmony default export */ var TeleportExamplevue_type_script_lang_ts = ({
    components: { Teleport: runtime_core_esm_bundler["Teleport"] },
});

// CONCATENATED MODULE: ./src/examples/TeleportExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/TeleportExample.vue



TeleportExamplevue_type_script_lang_ts.render = TeleportExamplevue_type_template_id_1b69f624_compiler_vugel_render

/* harmony default export */ var TeleportExample = (TeleportExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/DirectExample.vue?vue&type=template&id=72ef8c46&compiler=vugel


const DirectExamplevue_type_template_id_72ef8c46_compiler_vugel_hoisted_1 = { ref: "container" }

function DirectExamplevue_type_template_id_72ef8c46_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("direct-container", DirectExamplevue_type_template_id_72ef8c46_compiler_vugel_hoisted_1, null, 512 /* NEED_PATCH */))
}
// CONCATENATED MODULE: ./src/examples/DirectExample.vue?vue&type=template&id=72ef8c46&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/DirectExample.vue?vue&type=script&lang=ts


/**
 * Direct containers give direct access to Vugel nodes, allowing to circumvent vue patching.
 * It is insanely fast.
 */
/* harmony default export */ var DirectExamplevue_type_script_lang_ts = ({
    setup() {
        const container = Object(reactivity_esm_bundler["shallowRef"])(null);
        const loop = () => {
            const ctr = container.value;
            if (ctr) {
                const rectangle = ctr.create(lib["Rectangle"]);
                rectangle.x = Math.random() * 1000;
                rectangle.y = Math.random() * 1000;
                rectangle.w = 10;
                rectangle.h = 10;
                ctr.add(rectangle);
                ctr.getDirectChildren().forEach(c => {
                    c.alpha *= 0.95;
                    if (c.alpha < 0.01) {
                        ctr.remove(c);
                    }
                });
            }
            requestAnimationFrame(loop);
        };
        loop();
        return {
            container,
        };
    },
});

// CONCATENATED MODULE: ./src/examples/DirectExample.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/DirectExample.vue



DirectExamplevue_type_script_lang_ts.render = DirectExamplevue_type_template_id_72ef8c46_compiler_vugel_render

/* harmony default export */ var DirectExample = (DirectExamplevue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/performance/ManyComponents.vue?vue&type=template&id=1655ed01&compiler=vugel


const ManyComponentsvue_type_template_id_1655ed01_compiler_vugel_hoisted_1 = /*#__PURE__*/Object(runtime_core_esm_bundler["createVNode"])("rectangle", {
  w: 50,
  h: 100,
  color: "red"
}, null, -1 /* HOISTED */)

function ManyComponentsvue_type_template_id_1655ed01_compiler_vugel_render(_ctx, _cache) {
  const _component_stateful_component = Object(runtime_core_esm_bundler["resolveComponent"])("stateful-component")
  const _component_toggle = Object(runtime_core_esm_bundler["resolveComponent"])("toggle")
  const _component_item = Object(runtime_core_esm_bundler["resolveComponent"])("item")
  const _component_drag_bar = Object(runtime_core_esm_bundler["resolveComponent"])("drag-bar")
  const _component_editor = Object(runtime_core_esm_bundler["resolveComponent"])("editor")

  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_editor, null, {
    content: Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])("container", null, [
        ManyComponentsvue_type_template_id_1655ed01_compiler_vugel_hoisted_1,
        (Object(runtime_core_esm_bundler["openBlock"])(true), Object(runtime_core_esm_bundler["createBlock"])(runtime_core_esm_bundler["Fragment"], null, Object(runtime_core_esm_bundler["renderList"])(_ctx.items, (item) => {
          return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])(_component_stateful_component, {
            key: item.id,
            x: item.x,
            y: item.y,
            color: item.color
          }, null, 8 /* PROPS */, ["x", "y", "color"]))
        }), 128 /* KEYED_FRAGMENT */))
      ])
    ]),
    "form-items": Object(runtime_core_esm_bundler["withCtx"])(() => [
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "recreate" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_toggle, {
            "initial-value": true,
            onChange: _cache[1] || (_cache[1] = $event => (_ctx.set_recreate($event)))
          })
        ]),
        _: 1
      }),
      Object(runtime_core_esm_bundler["createVNode"])(_component_item, { name: "amount" }, {
        default: Object(runtime_core_esm_bundler["withCtx"])(() => [
          Object(runtime_core_esm_bundler["createVNode"])(_component_drag_bar, {
            "initial-value": 100,
            min: 0,
            max: 10000,
            onChange: _cache[2] || (_cache[2] = $event => (_ctx.set_amount($event)))
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  }))
}
// CONCATENATED MODULE: ./src/examples/performance/ManyComponents.vue?vue&type=template&id=1655ed01&compiler=vugel

// CONCATENATED MODULE: ./node_modules/vue-loader/dist/templateLoader.js??ref--5!./node_modules/vue-loader/dist??ref--0!./src/examples/performance/StatefulComponent.vue?vue&type=template&id=37fa75c0&compiler=vugel


function StatefulComponentvue_type_template_id_37fa75c0_compiler_vugel_render(_ctx, _cache) {
  return (Object(runtime_core_esm_bundler["openBlock"])(), Object(runtime_core_esm_bundler["createBlock"])("rectangle", {
    color: _ctx.color,
    w: _ctx.width,
    h: _ctx.height,
    x: _ctx.x,
    y: _ctx.y
  }, null, 8 /* PROPS */, ["color", "w", "h", "x", "y"]))
}
// CONCATENATED MODULE: ./src/examples/performance/StatefulComponent.vue?vue&type=template&id=37fa75c0&compiler=vugel

// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/performance/StatefulComponent.vue?vue&type=script&lang=ts

/* harmony default export */ var StatefulComponentvue_type_script_lang_ts = ({
    props: {
        color: { type: Number, default: 0xffffffff },
        x: { type: Number, default: 0 },
        y: { type: Number, default: 0 },
    },
    setup() {
        const width = Object(reactivity_esm_bundler["ref"])(100 * Math.random());
        const height = Object(reactivity_esm_bundler["ref"])(100 * Math.random());
        return {
            width,
            height,
        };
    },
});

// CONCATENATED MODULE: ./src/examples/performance/StatefulComponent.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/performance/StatefulComponent.vue



StatefulComponentvue_type_script_lang_ts.render = StatefulComponentvue_type_template_id_37fa75c0_compiler_vugel_render

/* harmony default export */ var StatefulComponent = (StatefulComponentvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/examples/performance/ManyComponents.vue?vue&type=script&lang=ts








/* harmony default export */ var ManyComponentsvue_type_script_lang_ts = ({
    components: { StatefulComponent: StatefulComponent, DragBar: DragBar, Toggle: Toggle, Editor: Editor, item: FormItem },
    setup() {
        const changeHandlers = createChangeHandlers(["recreate", "amount"]);
        const items = Object(reactivity_esm_bundler["shallowRef"])([]);
        Object(runtime_core_esm_bundler["watchEffect"])(() => {
            const amount = changeHandlers.amount.value;
            const recreate = changeHandlers.recreate.value;
            const newItems = [];
            for (let i = 0; i < amount; i++) {
                const item = {};
                item.color = tree2d_lib["ColorUtils"].getArgbNumber([
                    Math.random() * 255,
                    Math.random() * 255,
                    Math.random() * 255,
                    255,
                ]);
                item.x = Math.random() * 500;
                item.y = Math.random() * 500;
                item.id = recreate ? Math.random() : i;
                newItems.push(item);
            }
            items.value = newItems;
        });
        let raf = 0;
        let frames = 0;
        const loop = () => {
            frames++;
            if (frames === 100) {
                console.profile("[create] frame 100-300");
            }
            if (frames === 300) {
                console.profileEnd("[create] frame 100-300");
                changeHandlers.recreate.value = false;
            }
            if (frames === 400) {
                console.log("start");
                console.profile("[reuse] frame 400-600");
            }
            if (frames === 600) {
                console.log("end");
                console.profileEnd("[reuse] frame 400-600");
            }
            Object(reactivity_esm_bundler["triggerRef"])(changeHandlers.amount);
            raf = requestAnimationFrame(loop);
        };
        Object(runtime_core_esm_bundler["onMounted"])(() => {
            loop();
        });
        Object(runtime_core_esm_bundler["onUnmounted"])(() => {
            cancelAnimationFrame(raf);
        });
        return Object.assign({ items }, changeHandlers);
    },
});

// CONCATENATED MODULE: ./src/examples/performance/ManyComponents.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/examples/performance/ManyComponents.vue



ManyComponentsvue_type_script_lang_ts.render = ManyComponentsvue_type_template_id_1655ed01_compiler_vugel_render

/* harmony default export */ var ManyComponents = (ManyComponentsvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/Examples.vue?vue&type=script&lang=ts
















/* harmony default export */ var Examplesvue_type_script_lang_ts = ({
    components: {
        PictureExample: PictureExample,
        RectangleExample: RectangleExample,
        TextExample: TextExample,
        StyledRectangleExample: StyledRectangleExample,
        DrawingExample: DrawingExample,
        PositionExample: PositionExample,
        CenterExample: CenterExample,
        TransformsExample: TransformsExample,
        VisibilityExample: VisibilityExample,
        TintingExample: TintingExample,
        ClippingExample: ClippingExample,
        ParagraphExample: ParagraphExample,
        ParticlesExample: ParticlesExample,
        TeleportExample: TeleportExample,
        DirectExample: DirectExample,
        ManyComponents: ManyComponents,
    },
    props: {
        selected: { type: String, default: "" },
    },
    setup(props) {
        const check = (exampleName) => {
            return props.selected === exampleName;
        };
        return { check };
    },
});

// CONCATENATED MODULE: ./src/Examples.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/Examples.vue



Examplesvue_type_script_lang_ts.render = Examplesvue_type_template_id_284ca3d8_compiler_vugel_render

/* harmony default export */ var Examples = (Examplesvue_type_script_lang_ts);
// CONCATENATED MODULE: ./node_modules/ts-loader??ref--1!./node_modules/vue-loader/dist??ref--0!./src/App.vue?vue&type=script&lang=ts



/* harmony default export */ var Appvue_type_script_lang_ts = ({
    components: { Vugel: lib["Vugel"], Examples: Examples },
    setup() {
        const examples = Object(reactivity_esm_bundler["ref"])([
            { name: "picture", text: "Picture" },
            { name: "rectangle", text: "Rectangle" },
            { name: "text", text: "Text" },
            { name: "styled-rectangle", text: "Styled rectangle" },
            { name: "drawing", text: "Drawing" },
            { name: "position", text: "Position and size" },
            { name: "center", text: "Center" },
            { name: "transforms", text: "Transforms" },
            { name: "visibility", text: "Visibility" },
            { name: "tinting", text: "Tinting" },
            { name: "clipping", text: "Clipping" },
            // { name: "texture-clipping", text: "Texture clipping" },
            // { name: "z-index", text: "Z-index" },
            // { name: "flexbox", text: "Flexbox" },
            // { name: "effects", text: "Effects" },
            { name: "paragraph", text: "Paragraph" },
            // { name: "mouse-events", text: "Mouse events" },
            // { name: "focus-events", text: "Focus events" },
            // { name: "intersection", text: "Intersection" },
            { name: "particles", text: "Particles" },
            { name: "teleport", text: "Teleport" },
            { name: "direct", text: "Direct" },
            { name: "many-components", text: "Many components performance" },
        ]);
        const example = Object(reactivity_esm_bundler["ref"])("picture");
        const check = (exampleName) => {
            return example.value === exampleName;
        };
        const exampleObject = Object(runtime_core_esm_bundler["computed"])(() => examples.value.find((obj) => obj.name === example.value) || { name: "", text: "" });
        const myvar = Object(reactivity_esm_bundler["ref"])(1);
        const myobj = Object(reactivity_esm_bundler["reactive"])({ x: 0, y: 0 });
        return { examples, example, check, exampleObject, myvar, myobj };
    },
});

// CONCATENATED MODULE: ./src/App.vue?vue&type=script&lang=ts
 
// CONCATENATED MODULE: ./src/App.vue



Appvue_type_script_lang_ts.render = render

/* harmony default export */ var App = (Appvue_type_script_lang_ts);
// CONCATENATED MODULE: ./src/main.ts


Object(runtime_dom_esm_bundler["createApp"])(App).mount("#app");


/***/ })
/******/ ]);
//# sourceMappingURL=main.js.map